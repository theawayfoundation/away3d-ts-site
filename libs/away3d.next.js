var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var away;
(function (away) {
    (function (errors) {
        var AnimationSetError = (function (_super) {
            __extends(AnimationSetError, _super);
            function AnimationSetError(message) {
                _super.call(this, message);
            }
            return AnimationSetError;
        })(errors.Error);
        errors.AnimationSetError = AnimationSetError;
    })(away.errors || (away.errors = {}));
    var errors = away.errors;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    /**
    * @module away.events
    */
    (function (events) {
        var LightEvent = (function (_super) {
            __extends(LightEvent, _super);
            function LightEvent(type) {
                _super.call(this, type);
            }
            //@override
            LightEvent.prototype.clone = function () {
                return new away.events.LightEvent(this.type);
            };
            LightEvent.CASTS_SHADOW_CHANGE = "castsShadowChange";
            return LightEvent;
        })(away.events.Event);
        events.LightEvent = LightEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        //import away3d.arcane;
        //import away3d.containers.ObjectContainer3D;
        //import away3d.containers.View;
        //import away3d.core.base.IRenderable;
        //import away3d.materials.MaterialBase;
        //import flash.events.Event;
        //import flash.geom.Point;
        //import flash.geom.Vector3D;
        //use namespace arcane;
        /**
        * A MouseEvent3D is dispatched when a mouse event occurs over a mouseEnabled object in View.
        * todo: we don't have screenZ data, tho this should be easy to implement
        */
        var MouseEvent3D = (function (_super) {
            __extends(MouseEvent3D, _super);
            /**
            * Create a new MouseEvent3D object.
            * @param type The type of the MouseEvent3D.
            */
            function MouseEvent3D(type) {
                _super.call(this, type);
                // Private.
                this._iAllowedToPropagate = true;
            }
            Object.defineProperty(MouseEvent3D.prototype, "bubbles", {
                get: /**
                * @inheritDoc
                */
                function () {
                    var doesBubble = this._iAllowedToPropagate;
                    this._iAllowedToPropagate = true;

                    // Don't bubble if propagation has been stopped.
                    return doesBubble;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            MouseEvent3D.prototype.stopPropagation = function () {
                this._iAllowedToPropagate = false;

                if (this._iParentEvent) {
                    this._iParentEvent.stopPropagation();
                }
            };

            /**
            * @inheritDoc
            */
            MouseEvent3D.prototype.stopImmediatePropagation = function () {
                this._iAllowedToPropagate = false;

                if (this._iParentEvent) {
                    this._iParentEvent.stopImmediatePropagation();
                }
            };

            /**
            * Creates a copy of the MouseEvent3D object and sets the value of each property to match that of the original.
            */
            MouseEvent3D.prototype.clone = function () {
                var result = new away.events.MouseEvent3D(this.type);

                /* TODO: Debug / test - look into isDefaultPrevented
                if (isDefaultPrevented())
                result.preventDefault();
                */
                result.screenX = this.screenX;
                result.screenY = this.screenY;

                result.view = this.view;
                result.object = this.object;
                result.materialOwner = this.materialOwner;
                result.material = this.material;
                result.uv = this.uv;
                result.localPosition = this.localPosition;
                result.localNormal = this.localNormal;
                result.index = this.index;
                result.subGeometryIndex = this.subGeometryIndex;
                result.delta = this.delta;

                result.ctrlKey = this.ctrlKey;
                result.shiftKey = this.shiftKey;

                result._iParentEvent = this;
                result._iAllowedToPropagate = this._iAllowedToPropagate;

                return result;
            };

            Object.defineProperty(MouseEvent3D.prototype, "scenePosition", {
                get: /**
                * The position in scene space where the event took place
                */
                function () {
                    if (this.object instanceof away.containers.DisplayObjectContainer) {
                        var objContainer = this.object;
                        return objContainer.sceneTransform.transformVector(this.localPosition);
                    } else {
                        return this.localPosition;
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MouseEvent3D.prototype, "sceneNormal", {
                get: /**
                * The normal in scene space where the event took place
                */
                function () {
                    if (this.object instanceof away.containers.DisplayObjectContainer) {
                        var objContainer = this.object;
                        var sceneNormal = objContainer.sceneTransform.deltaTransformVector(this.localNormal);

                        sceneNormal.normalize();

                        return sceneNormal;
                    } else {
                        return this.localNormal;
                    }
                    /*
                    if (object is ObjectContainer3D) {
                    var sceneNormal:Vector3D = ObjectContainer3D(object)
                    sceneNormal.normalize();
                    return sceneNormal;
                    } else
                    return localNormal;
                    */
                },
                enumerable: true,
                configurable: true
            });
            MouseEvent3D.MOUSE_OVER = "mouseOver3d";

            MouseEvent3D.MOUSE_OUT = "mouseOut3d";

            MouseEvent3D.MOUSE_UP = "mouseUp3d";

            MouseEvent3D.MOUSE_DOWN = "mouseDown3d";

            MouseEvent3D.MOUSE_MOVE = "mouseMove3d";

            MouseEvent3D.CLICK = "click3d";

            MouseEvent3D.DOUBLE_CLICK = "doubleClick3d";

            MouseEvent3D.MOUSE_WHEEL = "mouseWheel3d";
            return MouseEvent3D;
        })(events.Event);
        events.MouseEvent3D = MouseEvent3D;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (events) {
        /**
        * Dispatched to notify changes in an animation state's state.
        */
        var AnimationStateEvent = (function (_super) {
            __extends(AnimationStateEvent, _super);
            /**
            * Create a new <code>AnimatonStateEvent</code>
            *
            * @param type The event type.
            * @param animator The animation state object that is the subject of this event.
            * @param animationNode The animation node inside the animation state from which the event originated.
            */
            function AnimationStateEvent(type, animator, animationState, animationNode) {
                _super.call(this, type);

                this._animator = animator;
                this._animationState = animationState;
                this._animationNode = animationNode;
            }
            Object.defineProperty(AnimationStateEvent.prototype, "animator", {
                get: /**
                * The animator object that is the subject of this event.
                */
                function () {
                    return this._animator;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationStateEvent.prototype, "animationState", {
                get: /**
                * The animation state object that is the subject of this event.
                */
                function () {
                    return this._animationState;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationStateEvent.prototype, "animationNode", {
                get: /**
                * The animation node inside the animation state from which the event originated.
                */
                function () {
                    return this._animationNode;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Clones the event.
            *
            * @return An exact duplicate of the current object.
            */
            AnimationStateEvent.prototype.clone = function () {
                return new AnimationStateEvent(this.type, this._animator, this._animationState, this._animationNode);
            };
            AnimationStateEvent.PLAYBACK_COMPLETE = "playbackComplete";

            AnimationStateEvent.TRANSITION_COMPLETE = "transitionComplete";
            return AnimationStateEvent;
        })(events.Event);
        events.AnimationStateEvent = AnimationStateEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (events) {
        /**
        * Dispatched to notify changes in an animator's state.
        */
        var AnimatorEvent = (function (_super) {
            __extends(AnimatorEvent, _super);
            /**
            * Create a new <code>AnimatorEvent</code> object.
            *
            * @param type The event type.
            * @param animator The animator object that is the subject of this event.
            */
            function AnimatorEvent(type, animator) {
                _super.call(this, type);
                this._animator = animator;
            }
            Object.defineProperty(AnimatorEvent.prototype, "animator", {
                get: function () {
                    return this._animator;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Clones the event.
            *
            * @return An exact duplicate of the current event object.
            */
            AnimatorEvent.prototype.clone = function () {
                return new AnimatorEvent(this.type, this._animator);
            };
            AnimatorEvent.START = "start";

            AnimatorEvent.STOP = "stop";

            AnimatorEvent.CYCLE_COMPLETE = "cycle_complete";
            return AnimatorEvent;
        })(events.Event);
        events.AnimatorEvent = AnimatorEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        //import flash.events.Event;
        var ShadingMethodEvent = (function (_super) {
            __extends(ShadingMethodEvent, _super);
            function ShadingMethodEvent(type) {
                _super.call(this, type);
            }
            ShadingMethodEvent.SHADER_INVALIDATED = "ShaderInvalidated";
            return ShadingMethodEvent;
        })(away.events.Event);
        events.ShadingMethodEvent = ShadingMethodEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (events) {
        /**
        * Dispatched to notify changes in a geometry object's state.
        *
        * @class away.events.GeometryEvent
        * @see away3d.core.base.Geometry
        */
        var GeometryEvent = (function (_super) {
            __extends(GeometryEvent, _super);
            /**
            * Create a new GeometryEvent
            * @param type The event type.
            * @param subGeometry An optional SubGeometry object that is the subject of this event.
            */
            function GeometryEvent(type, subGeometry) {
                if (typeof subGeometry === "undefined") { subGeometry = null; }
                _super.call(this, type);
                this._subGeometry = subGeometry;
            }
            Object.defineProperty(GeometryEvent.prototype, "subGeometry", {
                get: /**
                * The SubGeometry object that is the subject of this event, if appropriate.
                */
                function () {
                    return this._subGeometry;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Clones the event.
            * @return An exact duplicate of the current object.
            */
            GeometryEvent.prototype.clone = function () {
                return new GeometryEvent(this.type, this._subGeometry);
            };
            GeometryEvent.SUB_GEOMETRY_ADDED = "SubGeometryAdded";

            GeometryEvent.SUB_GEOMETRY_REMOVED = "SubGeometryRemoved";

            GeometryEvent.BOUNDS_INVALID = "BoundsInvalid";
            return GeometryEvent;
        })(away.events.Event);
        events.GeometryEvent = GeometryEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        /**
        * SubMesh wraps a SubGeometry as a scene graph instantiation. A SubMesh is owned by a Mesh object.
        *
        *
        * @see away.base.SubGeometry
        * @see away.entities.Mesh
        *
        * @class away.base.SubMesh
        */
        var SubMesh = (function (_super) {
            __extends(SubMesh, _super);
            /**
            * Creates a new SubMesh object
            * @param subGeometry The SubGeometry object which provides the geometry data for this SubMesh.
            * @param parentMesh The Mesh object to which this SubMesh belongs.
            * @param material An optional material used to render this SubMesh.
            */
            function SubMesh(subGeometry, parentMesh, material) {
                if (typeof material === "undefined") { material = null; }
                _super.call(this);
                this._iIndex = 0;

                this._parentMesh = parentMesh;
                this._subGeometry = subGeometry;
                this.material = material;

                this._uvTransform = new away.geom.UVTransform(this);
            }
            Object.defineProperty(SubMesh.prototype, "animator", {
                get: //TODO test shader picking
                //		public get shaderPickingDetails():boolean
                //		{
                //
                //			return this.sourceEntity.shaderPickingDetails;
                //		}
                /**
                * The animator object that provides the state for the SubMesh's animation.
                */
                function () {
                    return this._parentMesh.animator;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "material", {
                get: /**
                * The material used to render the current SubMesh. If set to null, its parent Mesh's material will be used instead.
                */
                function () {
                    return this._iMaterial || this._parentMesh.material;
                },
                set: function (value) {
                    if (this._iMaterial)
                        this._iMaterial.iRemoveOwner(this);

                    this._iMaterial = value;

                    if (this._iMaterial)
                        this._iMaterial.iAddOwner(this);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubMesh.prototype, "sceneTransform", {
                get: /**
                * The scene transform object that transforms from model to world space.
                */
                function () {
                    return this._parentMesh.sceneTransform;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "sourceEntity", {
                get: /**
                * The entity that that initially provided the IRenderable to the render pipeline (ie: the owning Mesh object).
                */
                function () {
                    return this._parentMesh;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "subGeometry", {
                get: /**
                * The SubGeometry object which provides the geometry data for this SubMesh.
                */
                function () {
                    return this._subGeometry;
                },
                set: function (value) {
                    this._subGeometry = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubMesh.prototype, "uvTransform", {
                get: /**
                *
                */
                function () {
                    return this._uvTransform;
                },
                enumerable: true,
                configurable: true
            });

            /**
            *
            */
            SubMesh.prototype.dispose = function () {
                this.material = null;
            };

            /**
            *
            * @param camera
            * @returns {away.geom.Matrix3D}
            */
            SubMesh.prototype.getRenderSceneTransform = function (camera) {
                return this._parentMesh.getRenderSceneTransform(camera);
            };

            /**
            * @internal
            */
            SubMesh.prototype._iSetUVMatrixComponents = function (offsetU, offsetV, scaleU, scaleV, rotationUV) {
            };
            return SubMesh;
        })(away.library.NamedAssetBase);
        base.SubMesh = SubMesh;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (base) {
        var Segment = (function () {
            function Segment(start, end, anchor, colorStart, colorEnd, thickness) {
                if (typeof colorStart === "undefined") { colorStart = 0x333333; }
                if (typeof colorEnd === "undefined") { colorEnd = 0x333333; }
                if (typeof thickness === "undefined") { thickness = 1; }
                this._index = -1;
                this._subSetIndex = -1;
                // TODO: not yet used: for CurveSegment support
                anchor = null;

                this._pThickness = thickness * 0.5;

                // TODO: add support for curve using anchor v1
                // Prefer removing v1 from this, and make Curve a separate class extending Segment? (- David)
                this._pStart = start;
                this._pEnd = end;
                this.startColor = colorStart;
                this.endColor = colorEnd;
            }
            Segment.prototype.updateSegment = function (start, end, anchor, colorStart, colorEnd, thickness) {
                if (typeof colorStart === "undefined") { colorStart = 0x333333; }
                if (typeof colorEnd === "undefined") { colorEnd = 0x333333; }
                if (typeof thickness === "undefined") { thickness = 1; }
                // TODO: not yet used: for CurveSegment support
                anchor = null;
                this._pStart = start;
                this._pEnd = end;

                if (this._startColor != colorStart) {
                    this.startColor = colorStart;
                }
                if (this._endColor != colorEnd) {
                    this.endColor = colorEnd;
                }
                this._pThickness = thickness * 0.5;
                this.update();
            };

            Object.defineProperty(Segment.prototype, "start", {
                get: function () {
                    return this._pStart;
                },
                set: function (value) {
                    this._pStart = value;
                    this.update();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Segment.prototype, "end", {
                get: function () {
                    return this._pEnd;
                },
                set: function (value) {
                    this._pEnd = value;
                    this.update();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Segment.prototype, "thickness", {
                get: function () {
                    return this._pThickness * 2;
                },
                set: function (value) {
                    this._pThickness = value * 0.5;
                    this.update();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Segment.prototype, "startColor", {
                get: function () {
                    return this._startColor;
                },
                set: function (color) {
                    this._pStartR = ((color >> 16) & 0xff) / 255;
                    this._pStartG = ((color >> 8) & 0xff) / 255;
                    this._pStartB = (color & 0xff) / 255;

                    this._startColor = color;

                    this.update();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Segment.prototype, "endColor", {
                get: function () {
                    return this._endColor;
                },
                set: function (color) {
                    this._pEndR = ((color >> 16) & 0xff) / 255;
                    this._pEndG = ((color >> 8) & 0xff) / 255;
                    this._pEndB = (color & 0xff) / 255;

                    this._endColor = color;

                    this.update();
                },
                enumerable: true,
                configurable: true
            });


            Segment.prototype.dispose = function () {
                this._pStart = null;
                this._pEnd = null;
            };

            Object.defineProperty(Segment.prototype, "iIndex", {
                get: function () {
                    return this._index;
                },
                set: function (ind) {
                    this._index = ind;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Segment.prototype, "iSubSetIndex", {
                get: function () {
                    return this._subSetIndex;
                },
                set: function (ind) {
                    this._subSetIndex = ind;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Segment.prototype, "iSegmentsBase", {
                set: function (segBase) {
                    this._pSegmentsBase = segBase;
                },
                enumerable: true,
                configurable: true
            });

            Segment.prototype.update = function () {
                if (!this._pSegmentsBase) {
                    return;
                }
                this._pSegmentsBase.iUpdateSegment(this);
            };
            return Segment;
        })();
        base.Segment = Segment;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        /**
        * @class away.base.SubGeometryBase
        */
        var SubGeometryBase = (function (_super) {
            __extends(SubGeometryBase, _super);
            function SubGeometryBase() {
                _super.call(this);
                this._faceNormalsDirty = true;
                this._faceTangentsDirty = true;
                this._indexBuffer = new Array(8);
                this._indexBufferContext = new Array(8);
                this._indicesInvalid = new Array(8);
                this._autoDeriveVertexNormals = true;
                this._autoDeriveVertexTangents = true;
                this._autoGenerateUVs = false;
                this._useFaceWeights = false;
                this._vertexNormalsDirty = true;
                this._vertexTangentsDirty = true;
                this._scaleU = 1;
                this._scaleV = 1;
                this._uvsDirty = true;
            }
            Object.defineProperty(SubGeometryBase.prototype, "autoGenerateDummyUVs", {
                get: /**
                * Defines whether a UV buffer should be automatically generated to contain dummy UV coordinates.
                * Set to true if a geometry lacks UV data but uses a material that requires it, or leave as false
                * in cases where UV data is explicitly defined or the material does not require UV data.
                */
                function () {
                    return this._autoGenerateUVs;
                },
                set: function (value) {
                    this._autoGenerateUVs = value;
                    this._uvsDirty = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubGeometryBase.prototype, "autoDeriveVertexNormals", {
                get: /**
                * True if the vertex normals should be derived from the geometry, false if the vertex normals are set
                * explicitly.
                */
                function () {
                    return this._autoDeriveVertexNormals;
                },
                set: function (value) {
                    this._autoDeriveVertexNormals = value;
                    this._vertexNormalsDirty = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubGeometryBase.prototype, "useFaceWeights", {
                get: /**
                * Indicates whether or not to take the size of faces into account when auto-deriving vertex normals and tangents.
                */
                function () {
                    return this._useFaceWeights;
                },
                set: function (value) {
                    this._useFaceWeights = value;

                    if (this._autoDeriveVertexNormals) {
                        this._vertexNormalsDirty = true;
                    }

                    if (this._autoDeriveVertexTangents) {
                        this._vertexTangentsDirty = true;
                    }

                    this._faceNormalsDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubGeometryBase.prototype, "numTriangles", {
                get: /**
                * The total amount of triangles in the SubGeometry.
                */
                function () {
                    return this._numTriangles;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Retrieves the VertexBuffer object that contains triangle indices.
            * @param context The ContextGL for which we request the buffer
            * @return The VertexBuffer object that contains triangle indices.
            */
            SubGeometryBase.prototype.getIndexBuffer = function (stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                if (!this._indexBuffer[contextIndex] || this._indexBufferContext[contextIndex] != context) {
                    this._indexBuffer[contextIndex] = context.createIndexBuffer(this._numIndices);
                    this._indexBufferContext[contextIndex] = context;
                    this._indicesInvalid[contextIndex] = true;
                }

                if (this._indicesInvalid[contextIndex]) {
                    this._indexBuffer[contextIndex].uploadFromArray(this._indices, 0, this._numIndices);
                    this._indicesInvalid[contextIndex] = false;
                }

                return this._indexBuffer[contextIndex];
            };

            /**
            * Updates the tangents for each face.
            */
            SubGeometryBase.prototype.pUpdateFaceTangents = function () {
                var i = 0;
                var index1;
                var index2;
                var index3;
                var len = this._indices.length;
                var ui;
                var vi;
                var v0;
                var dv1;
                var dv2;
                var denom;
                var x0, y0, z0;
                var dx1, dy1, dz1;
                var dx2, dy2, dz2;
                var cx, cy, cz;
                var vertices = this._vertexData;
                var uvs = this.UVData;
                var posStride = this.vertexStride;
                var posOffset = this.vertexOffset;
                var texStride = this.UVStride;
                var texOffset = this.UVOffset;

                if (this._faceTangents == null) {
                    this._faceTangents = new Array(this._indices.length);
                }

                while (i < len) {
                    index1 = this._indices[i];
                    index2 = this._indices[i + 1];
                    index3 = this._indices[i + 2];

                    ui = texOffset + index1 * texStride + 1;
                    v0 = uvs[ui];
                    ui = texOffset + index2 * texStride + 1;
                    dv1 = uvs[ui] - v0;
                    ui = texOffset + index3 * texStride + 1;
                    dv2 = uvs[ui] - v0;

                    vi = posOffset + index1 * posStride;
                    x0 = vertices[vi];
                    y0 = vertices[(vi + 1)];
                    z0 = vertices[(vi + 2)];
                    vi = posOffset + index2 * posStride;
                    dx1 = vertices[(vi)] - x0;
                    dy1 = vertices[(vi + 1)] - y0;
                    dz1 = vertices[(vi + 2)] - z0;
                    vi = posOffset + index3 * posStride;
                    dx2 = vertices[(vi)] - x0;
                    dy2 = vertices[(vi + 1)] - y0;
                    dz2 = vertices[(vi + 2)] - z0;

                    cx = dv2 * dx1 - dv1 * dx2;
                    cy = dv2 * dy1 - dv1 * dy2;
                    cz = dv2 * dz1 - dv1 * dz2;
                    denom = 1 / Math.sqrt(cx * cx + cy * cy + cz * cz);

                    this._faceTangents[i++] = denom * cx;
                    this._faceTangents[i++] = denom * cy;
                    this._faceTangents[i++] = denom * cz;
                }

                this._faceTangentsDirty = false;
            };

            /**
            * Updates the normals for each face.
            */
            SubGeometryBase.prototype.updateFaceNormals = function () {
                var i = 0;
                var j = 0;
                var k = 0;
                var index;

                var len = this._indices.length;
                var x1, x2, x3;
                var y1, y2, y3;
                var z1, z2, z3;
                var dx1, dy1, dz1;
                var dx2, dy2, dz2;
                var cx, cy, cz;
                var d;
                var vertices = this._vertexData;
                var posStride = this.vertexStride;
                var posOffset = this.vertexOffset;

                if (this._faceNormals == null) {
                    this._faceNormals = new Array(len);
                }

                if (this._useFaceWeights) {
                    if (this._faceWeights == null) {
                        this._faceWeights = new Array(len / 3);
                    }
                }

                while (i < len) {
                    index = posOffset + this._indices[i++] * posStride;
                    x1 = vertices[index];
                    y1 = vertices[index + 1];
                    z1 = vertices[index + 2];
                    index = posOffset + this._indices[i++] * posStride;
                    x2 = vertices[index];
                    y2 = vertices[index + 1];
                    z2 = vertices[index + 2];
                    index = posOffset + this._indices[i++] * posStride;
                    x3 = vertices[index];
                    y3 = vertices[index + 1];
                    z3 = vertices[index + 2];
                    dx1 = x3 - x1;
                    dy1 = y3 - y1;
                    dz1 = z3 - z1;
                    dx2 = x2 - x1;
                    dy2 = y2 - y1;
                    dz2 = z2 - z1;
                    cx = dz1 * dy2 - dy1 * dz2;
                    cy = dx1 * dz2 - dz1 * dx2;
                    cz = dy1 * dx2 - dx1 * dy2;
                    d = Math.sqrt(cx * cx + cy * cy + cz * cz);

                    if (this._useFaceWeights) {
                        var w = d * 10000;

                        if (w < 1) {
                            w = 1;
                        }

                        this._faceWeights[k++] = w;
                    }

                    d = 1 / d;

                    this._faceNormals[j++] = cx * d;
                    this._faceNormals[j++] = cy * d;
                    this._faceNormals[j++] = cz * d;
                }

                this._faceNormalsDirty = false;
            };

            /**
            * Updates the vertex normals based on the geometry.
            */
            SubGeometryBase.prototype.pUpdateVertexNormals = function (target) {
                if (this._faceNormalsDirty) {
                    this.updateFaceNormals();
                }

                var v1;
                var f1 = 0;
                var f2 = 1;
                var f3 = 2;
                var lenV = this._vertexData.length;
                var normalStride = this.vertexNormalStride;
                var normalOffset = this.vertexNormalOffset;

                if (target == null) {
                    target = new Array(lenV);
                }

                v1 = normalOffset;

                while (v1 < lenV) {
                    target[v1] = 0.0;
                    target[v1 + 1] = 0.0;
                    target[v1 + 2] = 0.0;
                    v1 += normalStride;
                }

                var i = 0;
                var k = 0;
                var lenI = this._indices.length;
                var index;
                var weight;

                while (i < lenI) {
                    weight = this._useFaceWeights ? this._faceWeights[k++] : 1;
                    index = normalOffset + this._indices[i++] * normalStride;
                    target[index++] += this._faceNormals[f1] * weight;
                    target[index++] += this._faceNormals[f2] * weight;
                    target[index] += this._faceNormals[f3] * weight;
                    index = normalOffset + this._indices[i++] * normalStride;
                    target[index++] += this._faceNormals[f1] * weight;
                    target[index++] += this._faceNormals[f2] * weight;
                    target[index] += this._faceNormals[f3] * weight;
                    index = normalOffset + this._indices[i++] * normalStride;
                    target[index++] += this._faceNormals[f1] * weight;
                    target[index++] += this._faceNormals[f2] * weight;
                    target[index] += this._faceNormals[f3] * weight;
                    f1 += 3;
                    f2 += 3;
                    f3 += 3;
                }

                v1 = normalOffset;
                while (v1 < lenV) {
                    var vx = target[v1];
                    var vy = target[v1 + 1];
                    var vz = target[v1 + 2];
                    var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                    target[v1] = vx * d;
                    target[v1 + 1] = vy * d;
                    target[v1 + 2] = vz * d;
                    v1 += normalStride;
                }

                this._vertexNormalsDirty = false;

                return target;
            };

            /**
            * Updates the vertex tangents based on the geometry.
            */
            SubGeometryBase.prototype.pUpdateVertexTangents = function (target) {
                if (this._faceTangentsDirty) {
                    this.pUpdateFaceTangents();
                }

                var i;
                var lenV = this._vertexData.length;
                var tangentStride = this.vertexTangentStride;
                var tangentOffset = this.vertexTangentOffset;

                if (target == null) {
                    target = new Array(lenV);
                }

                i = tangentOffset;

                while (i < lenV) {
                    target[i] = 0.0;
                    target[i + 1] = 0.0;
                    target[i + 2] = 0.0;
                    i += tangentStride;
                }

                var k = 0;
                var lenI = this._indices.length;
                var index;
                var weight;
                var f1 = 0;
                var f2 = 1;
                var f3 = 2;

                i = 0;

                while (i < lenI) {
                    weight = this._useFaceWeights ? this._faceWeights[k++] : 1;
                    index = tangentOffset + this._indices[i++] * tangentStride;
                    target[index++] += this._faceTangents[f1] * weight;
                    target[index++] += this._faceTangents[f2] * weight;
                    target[index] += this._faceTangents[f3] * weight;
                    index = tangentOffset + this._indices[i++] * tangentStride;
                    target[index++] += this._faceTangents[f1] * weight;
                    target[index++] += this._faceTangents[f2] * weight;
                    target[index] += this._faceTangents[f3] * weight;
                    index = tangentOffset + this._indices[i++] * tangentStride;
                    target[index++] += this._faceTangents[f1] * weight;
                    target[index++] += this._faceTangents[f2] * weight;
                    target[index] += this._faceTangents[f3] * weight;
                    f1 += 3;
                    f2 += 3;
                    f3 += 3;
                }

                i = tangentOffset;

                while (i < lenV) {
                    var vx = target[i];
                    var vy = target[i + 1];
                    var vz = target[i + 2];
                    var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                    target[i] = vx * d;
                    target[i + 1] = vy * d;
                    target[i + 2] = vz * d;
                    i += tangentStride;
                }

                this._vertexTangentsDirty = false;

                return target;
            };

            SubGeometryBase.prototype.dispose = function () {
                this.pDisposeIndexBuffers(this._indexBuffer);
                this._indices = null;
                this._indexBufferContext = null;
                this._faceNormals = null;
                this._faceWeights = null;
                this._faceTangents = null;
                this._vertexData = null;
            };

            Object.defineProperty(SubGeometryBase.prototype, "indexData", {
                get: /**
                * The raw index data that define the faces.
                *
                * @private
                */
                function () {
                    return this._indices;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the face indices of the SubGeometry.
            * @param indices The face indices to upload.
            */
            SubGeometryBase.prototype.updateIndexData = function (indices/*uint*/ ) {
                this._indices = indices;
                this._numIndices = indices.length;

                var numTriangles = this._numIndices / 3;

                if (this._numTriangles != numTriangles) {
                    this.pDisposeIndexBuffers(this._indexBuffer);
                }

                this._numTriangles = numTriangles;
                this.pInvalidateBuffers(this._indicesInvalid);
                this._faceNormalsDirty = true;

                if (this._autoDeriveVertexNormals) {
                    this._vertexNormalsDirty = true;
                }

                if (this._autoDeriveVertexTangents) {
                    this._vertexTangentsDirty = true;
                }
            };

            /**
            * Disposes all buffers in a given vector.
            * @param buffers The vector of buffers to dispose.
            */
            SubGeometryBase.prototype.pDisposeIndexBuffers = function (buffers) {
                for (var i = 0; i < 8; ++i) {
                    if (buffers[i]) {
                        buffers[i].dispose();
                        buffers[i] = null;
                    }
                }
            };

            /**
            * Disposes all buffers in a given vector.
            * @param buffers The vector of buffers to dispose.
            */
            SubGeometryBase.prototype.pDisposeVertexBuffers = function (buffers) {
                for (var i = 0; i < 8; ++i) {
                    if (buffers[i]) {
                        buffers[i].dispose();
                        buffers[i] = null;
                    }
                }
            };

            Object.defineProperty(SubGeometryBase.prototype, "autoDeriveVertexTangents", {
                get: /**
                * True if the vertex tangents should be derived from the geometry, false if the vertex normals are set
                * explicitly.
                */
                function () {
                    return this._autoDeriveVertexTangents;
                },
                set: function (value) {
                    this._autoDeriveVertexTangents = value;
                    this._vertexTangentsDirty = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubGeometryBase.prototype, "faceNormals", {
                get: /**
                * The raw data of the face normals, in the same order as the faces are listed in the index list.
                *
                * @private
                */
                function () {
                    if (this._faceNormalsDirty) {
                        this.updateFaceNormals();
                    }

                    return this._faceNormals;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Invalidates all buffers in a vector, causing them the update when they are first requested.
            * @param buffers The vector of buffers to invalidate.
            */
            SubGeometryBase.prototype.pInvalidateBuffers = function (invalid) {
                for (var i = 0; i < 8; ++i) {
                    invalid[i] = true;
                }
            };

            Object.defineProperty(SubGeometryBase.prototype, "UVStride", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexData", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexPositionData", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexNormalData", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexTangentData", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "UVData", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexStride", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexNormalStride", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexTangentStride", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexOffset", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexNormalOffset", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexTangentOffset", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "UVOffset", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            SubGeometryBase.prototype.pInvalidateBounds = function () {
                if (this._parentGeometry) {
                    var me = this;
                    this._parentGeometry.iInvalidateBounds(me);
                }
            };

            Object.defineProperty(SubGeometryBase.prototype, "parentGeometry", {
                get: /**
                * The Geometry object that 'owns' this SubGeometry object.
                *
                * @private
                */
                function () {
                    return this._parentGeometry;
                },
                set: function (value) {
                    this._parentGeometry = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubGeometryBase.prototype, "scaleU", {
                get: /**
                * Scales the uv coordinates
                * @param scaleU The amount by which to scale on the u axis. Default is 1;
                * @param scaleV The amount by which to scale on the v axis. Default is 1;
                */
                function () {
                    return this._scaleU;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "scaleV", {
                get: function () {
                    return this._scaleV;
                },
                enumerable: true,
                configurable: true
            });

            SubGeometryBase.prototype.scaleUV = function (scaleU, scaleV) {
                if (typeof scaleU === "undefined") { scaleU = 1; }
                if (typeof scaleV === "undefined") { scaleV = 1; }
                var offset = this.UVOffset;
                var stride = this.UVStride;
                var uvs = this.UVData;
                var len = uvs.length;
                var ratioU = scaleU / this._scaleU;
                var ratioV = scaleV / this._scaleV;

                for (var i = offset; i < len; i += stride) {
                    uvs[i] *= ratioU;
                    uvs[i + 1] *= ratioV;
                }

                this._scaleU = scaleU;
                this._scaleV = scaleV;
            };

            /**
            * Scales the geometry.
            * @param scale The amount by which to scale.
            */
            SubGeometryBase.prototype.scale = function (scale) {
                var vertices = this.UVData;
                var len = vertices.length;
                var offset = this.vertexOffset;
                var stride = this.vertexStride;

                for (var i = offset; i < len; i += stride) {
                    vertices[i] *= scale;
                    vertices[i + 1] *= scale;
                    vertices[i + 2] *= scale;
                }
            };

            SubGeometryBase.prototype.applyTransformation = function (transform) {
                var vertices = this._vertexData;
                var normals = this.vertexNormalData;
                var tangents = this.vertexTangentData;
                var posStride = this.vertexStride;
                var normalStride = this.vertexNormalStride;
                var tangentStride = this.vertexTangentStride;
                var posOffset = this.vertexOffset;
                var normalOffset = this.vertexNormalOffset;
                var tangentOffset = this.vertexTangentOffset;
                var len = vertices.length / posStride;
                var i;
                var i1;
                var i2;
                var vector = new away.geom.Vector3D();

                var bakeNormals = normals != null;
                var bakeTangents = tangents != null;
                var invTranspose;

                if (bakeNormals || bakeTangents) {
                    invTranspose = transform.clone();
                    invTranspose.invert();
                    invTranspose.transpose();
                }

                var vi0 = posOffset;
                var ni0 = normalOffset;
                var ti0 = tangentOffset;

                for (i = 0; i < len; ++i) {
                    i1 = vi0 + 1;
                    i2 = vi0 + 2;

                    // bake position
                    vector.x = vertices[vi0];
                    vector.y = vertices[i1];
                    vector.z = vertices[i2];
                    vector = transform.transformVector(vector);
                    vertices[vi0] = vector.x;
                    vertices[i1] = vector.y;
                    vertices[i2] = vector.z;
                    vi0 += posStride;

                    if (bakeNormals) {
                        i1 = ni0 + 1;
                        i2 = ni0 + 2;
                        vector.x = normals[ni0];
                        vector.y = normals[i1];
                        vector.z = normals[i2];
                        vector = invTranspose.deltaTransformVector(vector);
                        vector.normalize();
                        normals[ni0] = vector.x;
                        normals[i1] = vector.y;
                        normals[i2] = vector.z;
                        ni0 += normalStride;
                    }

                    if (bakeTangents) {
                        i1 = ti0 + 1;
                        i2 = ti0 + 2;
                        vector.x = tangents[ti0];
                        vector.y = tangents[i1];
                        vector.z = tangents[i2];
                        vector = invTranspose.deltaTransformVector(vector);
                        vector.normalize();
                        tangents[ti0] = vector.x;
                        tangents[i1] = vector.y;
                        tangents[i2] = vector.z;
                        ti0 += tangentStride;
                    }
                }
            };

            SubGeometryBase.prototype.pUpdateDummyUVs = function (target) {
                this._uvsDirty = false;
                var idx;
                var uvIdx;
                var stride = this.UVStride;
                var skip = stride - 2;
                var len = this._vertexData.length / this.vertexStride * stride;

                if (!target) {
                    target = new Array();
                }

                target.length = len;

                idx = this.UVOffset;
                uvIdx = 0;

                while (idx < len) {
                    target[idx++] = uvIdx * .5;
                    target[idx++] = 1.0 - (uvIdx & 1);
                    idx += skip;

                    if (++uvIdx == 3) {
                        uvIdx = 0;
                    }
                }

                return target;
            };
            return SubGeometryBase;
        })(away.library.NamedAssetBase);
        base.SubGeometryBase = SubGeometryBase;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        /**
        * @class away.base.CompactSubGeometry
        */
        var CompactSubGeometry = (function (_super) {
            __extends(CompactSubGeometry, _super);
            function CompactSubGeometry() {
                _super.call(this);
                this._pVertexDataInvalid = Array(8);
                this._vertexBuffer = new Array(8);
                this._bufferContext = new Array(8);

                this._autoDeriveVertexNormals = false;
                this._autoDeriveVertexTangents = false;
            }
            Object.defineProperty(CompactSubGeometry.prototype, "numVertices", {
                get: function () {
                    return this._pNumVertices;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the vertex data. All vertex properties are contained in a single Vector, and the order is as follows:
            * 0 - 2: vertex position X, Y, Z
            * 3 - 5: normal X, Y, Z
            * 6 - 8: tangent X, Y, Z
            * 9 - 10: U V
            * 11 - 12: Secondary U V
            */
            CompactSubGeometry.prototype.updateData = function (data) {
                if (this._autoDeriveVertexNormals) {
                    this._vertexNormalsDirty = true;
                }

                if (this._autoDeriveVertexTangents) {
                    this._vertexTangentsDirty = true;
                }

                this._faceNormalsDirty = true;
                this._faceTangentsDirty = true;
                this._isolatedVertexPositionDataDirty = true;
                this._vertexData = data;

                var numVertices = this._vertexData.length / 13;

                if (numVertices != this._pNumVertices) {
                    this.pDisposeVertexBuffers(this._vertexBuffer);
                }

                this._pNumVertices = numVertices;

                if (this._pNumVertices == 0) {
                    throw new Error("Bad data: geometry can't have zero triangles");
                }

                this.pInvalidateBuffers(this._pVertexDataInvalid);
                this.pInvalidateBounds();
            };

            CompactSubGeometry.prototype.activateVertexBuffer = function (index, stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                if (contextIndex != this._contextIndex) {
                    this.pUpdateActiveBuffer(contextIndex);
                }

                if (!this._pActiveBuffer || this._activeContext != context) {
                    this.pCreateBuffer(contextIndex, context);
                }

                if (this._pActiveDataInvalid) {
                    this.pUploadData(contextIndex);
                }

                context.setVertexBufferAt(index, this._pActiveBuffer, 0, away.gl.ContextGLVertexBufferFormat.FLOAT_3);
            };

            CompactSubGeometry.prototype.activateUVBuffer = function (index, stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                if (this._uvsDirty && this._autoGenerateUVs) {
                    this._vertexData = this.pUpdateDummyUVs(this._vertexData);
                    this.pInvalidateBuffers(this._pVertexDataInvalid);
                }

                if (contextIndex != this._contextIndex) {
                    this.pUpdateActiveBuffer(contextIndex);
                }

                if (!this._pActiveBuffer || this._activeContext != context) {
                    this.pCreateBuffer(contextIndex, context);
                }

                if (this._pActiveDataInvalid) {
                    this.pUploadData(contextIndex);
                }

                context.setVertexBufferAt(index, this._pActiveBuffer, 9, away.gl.ContextGLVertexBufferFormat.FLOAT_2);
            };

            CompactSubGeometry.prototype.activateSecondaryUVBuffer = function (index, stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                if (contextIndex != this._contextIndex) {
                    this.pUpdateActiveBuffer(contextIndex);
                }

                if (!this._pActiveBuffer || this._activeContext != context) {
                    this.pCreateBuffer(contextIndex, context);
                }

                if (this._pActiveDataInvalid) {
                    this.pUploadData(contextIndex);
                }

                context.setVertexBufferAt(index, this._pActiveBuffer, 11, away.gl.ContextGLVertexBufferFormat.FLOAT_2);
            };

            CompactSubGeometry.prototype.pUploadData = function (contextIndex) {
                this._pActiveBuffer.uploadFromArray(this._vertexData, 0, this._pNumVertices);
                this._pVertexDataInvalid[contextIndex] = this._pActiveDataInvalid = false;
            };

            CompactSubGeometry.prototype.activateVertexNormalBuffer = function (index, stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                if (contextIndex != this._contextIndex) {
                    this.pUpdateActiveBuffer(contextIndex);
                }

                if (!this._pActiveBuffer || this._activeContext != context) {
                    this.pCreateBuffer(contextIndex, context);
                }

                if (this._pActiveDataInvalid) {
                    this.pUploadData(contextIndex);
                }

                context.setVertexBufferAt(index, this._pActiveBuffer, 3, away.gl.ContextGLVertexBufferFormat.FLOAT_3);
            };

            CompactSubGeometry.prototype.activateVertexTangentBuffer = function (index, stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                if (contextIndex != this._contextIndex) {
                    this.pUpdateActiveBuffer(contextIndex);
                }

                if (!this._pActiveBuffer || this._activeContext != context) {
                    this.pCreateBuffer(contextIndex, context);
                }

                if (this._pActiveDataInvalid) {
                    this.pUploadData(contextIndex);
                }

                context.setVertexBufferAt(index, this._pActiveBuffer, 6, away.gl.ContextGLVertexBufferFormat.FLOAT_3);
            };

            CompactSubGeometry.prototype.pCreateBuffer = function (contextIndex, context) {
                this._vertexBuffer[contextIndex] = this._pActiveBuffer = context.createVertexBuffer(this._pNumVertices, 13);
                this._bufferContext[contextIndex] = this._activeContext = context;
                this._pVertexDataInvalid[contextIndex] = this._pActiveDataInvalid = true;
            };

            CompactSubGeometry.prototype.pUpdateActiveBuffer = function (contextIndex) {
                this._contextIndex = contextIndex;
                this._pActiveDataInvalid = this._pVertexDataInvalid[contextIndex];
                this._pActiveBuffer = this._vertexBuffer[contextIndex];
                this._activeContext = this._bufferContext[contextIndex];
            };

            Object.defineProperty(CompactSubGeometry.prototype, "vertexData", {
                get: function () {
                    if (this._autoDeriveVertexNormals && this._vertexNormalsDirty) {
                        this._vertexData = this.pUpdateVertexNormals(this._vertexData);
                    }

                    if (this._autoDeriveVertexTangents && this._vertexTangentsDirty) {
                        this._vertexData = this.pUpdateVertexTangents(this._vertexData);
                    }

                    if (this._uvsDirty && this._autoGenerateUVs) {
                        this._vertexData = this.pUpdateDummyUVs(this._vertexData);
                    }

                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            CompactSubGeometry.prototype.pUpdateVertexNormals = function (target) {
                this.pInvalidateBuffers(this._pVertexDataInvalid);
                return _super.prototype.pUpdateVertexNormals.call(this, target);
            };

            CompactSubGeometry.prototype.pUpdateVertexTangents = function (target) {
                if (this._vertexNormalsDirty) {
                    this._vertexData = this.pUpdateVertexNormals(this._vertexData);
                }

                this.pInvalidateBuffers(this._pVertexDataInvalid);

                return _super.prototype.pUpdateVertexTangents.call(this, target);
            };

            Object.defineProperty(CompactSubGeometry.prototype, "vertexNormalData", {
                get: function () {
                    if (this._autoDeriveVertexNormals && this._vertexNormalsDirty) {
                        this._vertexData = this.pUpdateVertexNormals(this._vertexData);
                    }

                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "vertexTangentData", {
                get: function () {
                    if (this._autoDeriveVertexTangents && this._vertexTangentsDirty) {
                        this._vertexData = this.pUpdateVertexTangents(this._vertexData);
                    }

                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "UVData", {
                get: function () {
                    if (this._uvsDirty && this._autoGenerateUVs) {
                        this._vertexData = this.pUpdateDummyUVs(this._vertexData);
                        this.pInvalidateBuffers(this._pVertexDataInvalid);
                    }

                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            CompactSubGeometry.prototype.applyTransformation = function (transform) {
                _super.prototype.applyTransformation.call(this, transform);
                this.pInvalidateBuffers(this._pVertexDataInvalid);
            };

            CompactSubGeometry.prototype.scale = function (scale) {
                _super.prototype.scale.call(this, scale);
                this.pInvalidateBuffers(this._pVertexDataInvalid);
            };

            CompactSubGeometry.prototype.clone = function () {
                var clone = new CompactSubGeometry();

                clone._autoDeriveVertexNormals = this._autoDeriveVertexNormals;
                clone._autoDeriveVertexTangents = this._autoDeriveVertexTangents;

                clone.updateData(this._vertexData.concat());
                clone.updateIndexData(this._indices.concat());

                return clone;
            };

            CompactSubGeometry.prototype.scaleUV = function (scaleU, scaleV) {
                if (typeof scaleU === "undefined") { scaleU = 1; }
                if (typeof scaleV === "undefined") { scaleV = 1; }
                _super.prototype.scaleUV.call(this, scaleU, scaleV);

                this.pInvalidateBuffers(this._pVertexDataInvalid);
            };

            Object.defineProperty(CompactSubGeometry.prototype, "vertexStride", {
                get: function () {
                    return 13;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "vertexNormalStride", {
                get: function () {
                    return 13;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "vertexTangentStride", {
                get: function () {
                    return 13;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "UVStride", {
                get: function () {
                    return 13;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "secondaryUVStride", {
                get: function () {
                    return 13;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "vertexOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "vertexNormalOffset", {
                get: function () {
                    return 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "vertexTangentOffset", {
                get: function () {
                    return 6;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "UVOffset", {
                get: function () {
                    return 9;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "secondaryUVOffset", {
                get: function () {
                    return 11;
                },
                enumerable: true,
                configurable: true
            });

            CompactSubGeometry.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this.pDisposeVertexBuffers(this._vertexBuffer);
                this._vertexBuffer = null;
            };

            CompactSubGeometry.prototype.pDisposeVertexBuffers = function (buffers) {
                _super.prototype.pDisposeVertexBuffers.call(this, buffers);
                this._pActiveBuffer = null;
            };

            CompactSubGeometry.prototype.pInvalidateBuffers = function (invalid) {
                _super.prototype.pInvalidateBuffers.call(this, invalid);
                this._pActiveDataInvalid = true;
            };

            CompactSubGeometry.prototype.cloneWithSeperateBuffers = function () {
                var clone = new base.SubGeometry();

                clone.updateVertexData(this._isolatedVertexPositionData ? this._isolatedVertexPositionData : this._isolatedVertexPositionData = this.stripBuffer(0, 3));
                clone.autoDeriveVertexNormals = this._autoDeriveVertexNormals;
                clone.autoDeriveVertexTangents = this._autoDeriveVertexTangents;

                if (!this._autoDeriveVertexNormals) {
                    clone.updateVertexNormalData(this.stripBuffer(3, 3));
                }

                if (!this._autoDeriveVertexTangents) {
                    clone.updateVertexTangentData(this.stripBuffer(6, 3));
                }

                clone.updateUVData(this.stripBuffer(9, 2));
                clone.updateSecondaryUVData(this.stripBuffer(11, 2));
                clone.updateIndexData(this.indexData.concat());

                return clone;
            };

            Object.defineProperty(CompactSubGeometry.prototype, "vertexPositionData", {
                get: function () {
                    if (this._isolatedVertexPositionDataDirty || !this._isolatedVertexPositionData) {
                        this._isolatedVertexPositionData = this.stripBuffer(0, 3);
                        this._isolatedVertexPositionDataDirty = false;
                    }

                    return this._isolatedVertexPositionData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "strippedUVData", {
                get: function () {
                    return this.stripBuffer(9, 2);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Isolate and returns a Vector.Number of a specific buffer type
            *
            * - stripBuffer(0, 3), return only the vertices
            * - stripBuffer(3, 3): return only the normals
            * - stripBuffer(6, 3): return only the tangents
            * - stripBuffer(9, 2): return only the uv's
            * - stripBuffer(11, 2): return only the secondary uv's
            */
            CompactSubGeometry.prototype.stripBuffer = function (offset, numEntries) {
                var data = new Array(this._pNumVertices * numEntries);
                var i = 0;
                var j = offset;
                var skip = 13 - numEntries;

                for (var v = 0; v < this._pNumVertices; ++v) {
                    for (var k = 0; k < numEntries; ++k) {
                        data[i++] = this._vertexData[j++];
                    }

                    j += skip;
                }

                return data;
            };

            CompactSubGeometry.prototype.fromVectors = function (verts, uvs, normals, tangents) {
                var vertLen = verts.length / 3 * 13;

                var index = 0;
                var v = 0;
                var n = 0;
                var t = 0;
                var u = 0;

                var data = new Array(vertLen);

                while (index < vertLen) {
                    data[index++] = verts[v++];
                    data[index++] = verts[v++];
                    data[index++] = verts[v++];

                    if (normals && normals.length) {
                        data[index++] = normals[n++];
                        data[index++] = normals[n++];
                        data[index++] = normals[n++];
                    } else {
                        data[index++] = 0;
                        data[index++] = 0;
                        data[index++] = 0;
                    }

                    if (tangents && tangents.length) {
                        data[index++] = tangents[t++];
                        data[index++] = tangents[t++];
                        data[index++] = tangents[t++];
                    } else {
                        data[index++] = 0;
                        data[index++] = 0;
                        data[index++] = 0;
                    }

                    if (uvs && uvs.length) {
                        data[index++] = uvs[u];
                        data[index++] = uvs[u + 1];

                        // use same secondary uvs as primary
                        data[index++] = uvs[u++];
                        data[index++] = uvs[u++];
                    } else {
                        data[index++] = 0;
                        data[index++] = 0;
                        data[index++] = 0;
                        data[index++] = 0;
                    }
                }

                this.autoDeriveVertexNormals = !(normals && normals.length);
                this.autoDeriveVertexTangents = !(tangents && tangents.length);
                this.autoGenerateDummyUVs = !(uvs && uvs.length);
                this.updateData(data);
            };
            return CompactSubGeometry;
        })(base.SubGeometryBase);
        base.CompactSubGeometry = CompactSubGeometry;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        /**
        * SkinnedSubGeometry provides a SubGeometry extension that contains data needed to skin vertices. In particular,
        * it provides joint indices and weights.
        * Important! Joint indices need to be pre-multiplied by 3, since they index the matrix array (and each matrix has 3 float4 elements)
        *
        * @class away.base.SkinnedSubGeometry
        *
        */
        var SkinnedSubGeometry = (function (_super) {
            __extends(SkinnedSubGeometry, _super);
            /**
            * Creates a new SkinnedSubGeometry object.
            * @param jointsPerVertex The amount of joints that can be assigned per vertex.
            */
            function SkinnedSubGeometry(jointsPerVertex) {
                _super.call(this);
                this._jointWeightsBuffer = new Array(8);
                this._jointIndexBuffer = new Array(8);
                this._jointWeightsInvalid = new Array(8);
                this._jointIndicesInvalid = new Array(8);
                this._jointWeightContext = new Array(8);
                this._jointIndexContext = new Array(8);

                this._jointsPerVertex = jointsPerVertex;
                this._bufferFormat = "float" + this._jointsPerVertex;
            }
            Object.defineProperty(SkinnedSubGeometry.prototype, "condensedIndexLookUp", {
                get: /**
                * If indices have been condensed, this will contain the original index for each condensed index.
                */
                function () {
                    return this._condensedIndexLookUp;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkinnedSubGeometry.prototype, "numCondensedJoints", {
                get: /**
                * The amount of joints used when joint indices have been condensed.
                */
                function () {
                    return this._numCondensedJoints;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkinnedSubGeometry.prototype, "animatedData", {
                get: /**
                * The animated vertex positions when set explicitly if the skinning transformations couldn't be performed on GPU.
                */
                function () {
                    return this._animatedData || this._vertexData.concat();
                },
                enumerable: true,
                configurable: true
            });

            SkinnedSubGeometry.prototype.updateAnimatedData = function (value) {
                this._animatedData = value;
                this.pInvalidateBuffers(this._pVertexDataInvalid);
            };

            /**
            * Assigns the attribute stream for joint weights
            * @param index The attribute stream index for the vertex shader
            * @param stageGL The StageGL to assign the stream to
            */
            SkinnedSubGeometry.prototype.activateJointWeightsBuffer = function (index, stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;
                if (this._jointWeightContext[contextIndex] != context || !this._jointWeightsBuffer[contextIndex]) {
                    this._jointWeightsBuffer[contextIndex] = context.createVertexBuffer(this._pNumVertices, this._jointsPerVertex);
                    this._jointWeightContext[contextIndex] = context;
                    this._jointWeightsInvalid[contextIndex] = true;
                }
                if (this._jointWeightsInvalid[contextIndex]) {
                    this._jointWeightsBuffer[contextIndex].uploadFromArray(this._jointWeightsData, 0, this._jointWeightsData.length / this._jointsPerVertex);
                    this._jointWeightsInvalid[contextIndex] = false;
                }
                context.setVertexBufferAt(index, this._jointWeightsBuffer[contextIndex], 0, this._bufferFormat);
            };

            /**
            * Assigns the attribute stream for joint indices
            * @param index The attribute stream index for the vertex shader
            * @param stageGL The StageGL to assign the stream to
            */
            SkinnedSubGeometry.prototype.activateJointIndexBuffer = function (index, stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                if (this._jointIndexContext[contextIndex] != context || !this._jointIndexBuffer[contextIndex]) {
                    this._jointIndexBuffer[contextIndex] = context.createVertexBuffer(this._pNumVertices, this._jointsPerVertex);
                    this._jointIndexContext[contextIndex] = context;
                    this._jointIndicesInvalid[contextIndex] = true;
                }
                if (this._jointIndicesInvalid[contextIndex]) {
                    this._jointIndexBuffer[contextIndex].uploadFromArray(this._numCondensedJoints > 0 ? this._condensedJointIndexData : this._jointIndexData, 0, this._jointIndexData.length / this._jointsPerVertex);
                    this._jointIndicesInvalid[contextIndex] = false;
                }
                context.setVertexBufferAt(index, this._jointIndexBuffer[contextIndex], 0, this._bufferFormat);
            };

            SkinnedSubGeometry.prototype.pUploadData = function (contextIndex) {
                if (this._animatedData) {
                    this._pActiveBuffer.uploadFromArray(this._animatedData, 0, this._pNumVertices);
                    this._pVertexDataInvalid[contextIndex] = this._pActiveDataInvalid = false;
                } else {
                    _super.prototype.pUploadData.call(this, contextIndex);
                }
            };

            /**
            * Clones the current object.
            * @return An exact duplicate of the current object.
            */
            SkinnedSubGeometry.prototype.clone = function () {
                var clone = new SkinnedSubGeometry(this._jointsPerVertex);

                clone.updateData(this._vertexData.concat());
                clone.updateIndexData(this._indices.concat());
                clone.iUpdateJointIndexData(this._jointIndexData.concat());
                clone.iUpdateJointWeightsData(this._jointWeightsData.concat());
                clone._autoDeriveVertexNormals = this._autoDeriveVertexNormals;
                clone._autoDeriveVertexTangents = this._autoDeriveVertexTangents;
                clone._numCondensedJoints = this._numCondensedJoints;
                clone._condensedIndexLookUp = this._condensedIndexLookUp;
                clone._condensedJointIndexData = this._condensedJointIndexData;

                return clone;
            };

            /**
            * Cleans up any resources used by this object.
            */
            SkinnedSubGeometry.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this.pDisposeVertexBuffers(this._jointWeightsBuffer);
                this.pDisposeVertexBuffers(this._jointIndexBuffer);
            };

            /**
            */
            SkinnedSubGeometry.prototype.iCondenseIndexData = function () {
                var len = this._jointIndexData.length;
                var oldIndex;
                var newIndex = 0;
                var dic = new Object();

                this._condensedJointIndexData = new Array(len);
                this._condensedIndexLookUp = new Array();

                for (var i = 0; i < len; ++i) {
                    oldIndex = this._jointIndexData[i];

                    if (dic[oldIndex] == undefined) {
                        dic[oldIndex] = newIndex;
                        this._condensedIndexLookUp[newIndex++] = oldIndex;
                        this._condensedIndexLookUp[newIndex++] = oldIndex + 1;
                        this._condensedIndexLookUp[newIndex++] = oldIndex + 2;
                    }
                    this._condensedJointIndexData[i] = dic[oldIndex];
                }
                this._numCondensedJoints = newIndex / 3;

                this.pInvalidateBuffers(this._jointIndicesInvalid);
            };

            Object.defineProperty(SkinnedSubGeometry.prototype, "iJointWeightsData", {
                get: /**
                * The raw joint weights data.
                */
                function () {
                    return this._jointWeightsData;
                },
                enumerable: true,
                configurable: true
            });

            SkinnedSubGeometry.prototype.iUpdateJointWeightsData = function (value) {
                // invalidate condensed stuff
                this._numCondensedJoints = 0;
                this._condensedIndexLookUp = null;
                this._condensedJointIndexData = null;

                this._jointWeightsData = value;
                this.pInvalidateBuffers(this._jointWeightsInvalid);
            };

            Object.defineProperty(SkinnedSubGeometry.prototype, "iJointIndexData", {
                get: /**
                * The raw joint index data.
                */
                function () {
                    return this._jointIndexData;
                },
                enumerable: true,
                configurable: true
            });

            SkinnedSubGeometry.prototype.iUpdateJointIndexData = function (value) {
                this._jointIndexData = value;
                this.pInvalidateBuffers(this._jointIndicesInvalid);
            };
            return SkinnedSubGeometry;
        })(base.CompactSubGeometry);
        base.SkinnedSubGeometry = SkinnedSubGeometry;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        /**
        *
        * Geometry is a collection of SubGeometries, each of which contain the actual geometrical data such as vertices,
        * normals, uvs, etc. It also contains a reference to an animation class, which defines how the geometry moves.
        * A Geometry object is assigned to a Mesh, a scene graph occurence of the geometry, which in turn assigns
        * the SubGeometries to its respective SubMesh objects.
        *
        *
        *
        * @see away.core.base.SubGeometry
        * @see away.entities.Mesh
        *
        * @class away.base.Geometry
        */
        var Geometry = (function (_super) {
            __extends(Geometry, _super);
            /**
            * Creates a new Geometry object.
            */
            function Geometry() {
                _super.call(this);

                this._subGeometries = new Array();
            }
            Object.defineProperty(Geometry.prototype, "assetType", {
                get: function () {
                    return away.library.AssetType.GEOMETRY;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Geometry.prototype, "subGeometries", {
                get: /**
                * A collection of SubGeometry objects, each of which contain geometrical data such as vertices, normals, etc.
                */
                function () {
                    return this._subGeometries;
                },
                enumerable: true,
                configurable: true
            });

            Geometry.prototype.getSubGeometries = function () {
                return this._subGeometries;
            };

            Geometry.prototype.applyTransformation = function (transform) {
                var len = this._subGeometries.length;
                for (var i = 0; i < len; ++i) {
                    this._subGeometries[i].applyTransformation(transform);
                }
            };

            /**
            * Adds a new SubGeometry object to the list.
            * @param subGeometry The SubGeometry object to be added.
            */
            Geometry.prototype.addSubGeometry = function (subGeometry) {
                this._subGeometries.push(subGeometry);

                subGeometry.parentGeometry = this;

                // TODO: add hasEventListener optimisation;
                //if (hasEventListener(GeometryEvent.SUB_GEOMETRY_ADDED))
                this.dispatchEvent(new away.events.GeometryEvent(away.events.GeometryEvent.SUB_GEOMETRY_ADDED, subGeometry));

                this.iInvalidateBounds(subGeometry);
            };

            /**
            * Removes a new SubGeometry object from the list.
            * @param subGeometry The SubGeometry object to be removed.
            */
            Geometry.prototype.removeSubGeometry = function (subGeometry) {
                this._subGeometries.splice(this._subGeometries.indexOf(subGeometry), 1);

                subGeometry.parentGeometry = null;

                // TODO: add hasEventListener optimisation;
                //if (hasEventListener(GeometryEvent.SUB_GEOMETRY_REMOVED))
                this.dispatchEvent(new away.events.GeometryEvent(away.events.GeometryEvent.SUB_GEOMETRY_REMOVED, subGeometry));

                this.iInvalidateBounds(subGeometry);
            };

            /**
            * Clones the geometry.
            * @return An exact duplicate of the current Geometry object.
            */
            Geometry.prototype.clone = function () {
                var clone = new Geometry();
                var len = this._subGeometries.length;

                for (var i = 0; i < len; ++i) {
                    clone.addSubGeometry(this._subGeometries[i].clone());
                }

                return clone;
            };

            /**
            * Scales the geometry.
            * @param scale The amount by which to scale.
            */
            Geometry.prototype.scale = function (scale) {
                var numSubGeoms = this._subGeometries.length;
                for (var i = 0; i < numSubGeoms; ++i) {
                    this._subGeometries[i].scale(scale);
                }
            };

            /**
            * Clears all resources used by the Geometry object, including SubGeometries.
            */
            Geometry.prototype.dispose = function () {
                var numSubGeoms = this._subGeometries.length;

                for (var i = 0; i < numSubGeoms; ++i) {
                    var subGeom = this._subGeometries[0];
                    this.removeSubGeometry(subGeom);
                    subGeom.dispose();
                }
            };

            /**
            * Scales the uv coordinates (tiling)
            * @param scaleU The amount by which to scale on the u axis. Default is 1;
            * @param scaleV The amount by which to scale on the v axis. Default is 1;
            */
            Geometry.prototype.scaleUV = function (scaleU, scaleV) {
                if (typeof scaleU === "undefined") { scaleU = 1; }
                if (typeof scaleV === "undefined") { scaleV = 1; }
                var numSubGeoms = this._subGeometries.length;

                for (var i = 0; i < numSubGeoms; ++i) {
                    this._subGeometries[i].scaleUV(scaleU, scaleV);
                }
            };

            /**
            * Updates the SubGeometries so all vertex data is represented in different buffers.
            * Use this for compatibility with Pixel Bender and PBPickingCollider
            */
            Geometry.prototype.convertToSeparateBuffers = function () {
                var subGeom;
                var numSubGeoms = this._subGeometries.length;
                var _removableCompactSubGeometries = new Array();

                for (var i = 0; i < numSubGeoms; ++i) {
                    subGeom = this._subGeometries[i];

                    if (subGeom instanceof away.base.SubGeometry) {
                        continue;
                    }

                    _removableCompactSubGeometries.push(subGeom);

                    this.addSubGeometry(subGeom.cloneWithSeperateBuffers());
                }

                var l = _removableCompactSubGeometries.length;
                var s;

                for (var c = 0; c < l; c++) {
                    s = _removableCompactSubGeometries[c];
                    this.removeSubGeometry(s);
                    s.dispose();
                }
            };

            Geometry.prototype.iValidate = function () {
                // To be overridden when necessary
            };

            Geometry.prototype.iInvalidateBounds = function (subGeom) {
                //if (hasEventListener(GeometryEvent.BOUNDS_INVALID))
                this.dispatchEvent(new away.events.GeometryEvent(away.events.GeometryEvent.BOUNDS_INVALID, subGeom));
            };
            return Geometry;
        })(away.library.NamedAssetBase);
        base.Geometry = Geometry;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        /**
        * @class away.base.ParticleGeometry
        */
        var ParticleGeometry = (function (_super) {
            __extends(ParticleGeometry, _super);
            function ParticleGeometry() {
                _super.apply(this, arguments);
            }
            return ParticleGeometry;
        })(base.Geometry);
        base.ParticleGeometry = ParticleGeometry;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        /**
        * The SubGeometry class is a collections of geometric data that describes a triangle mesh. It is owned by a
        * Geometry instance, and wrapped by a SubMesh in the scene graph.
        * Several SubGeometries are grouped so they can be rendered with different materials, but still represent a single
        * object.
        *
        * @see away.base.Geometry
        * @see away.base.SubMesh
        *
        * @class away.base.SubGeometry
        */
        var SubGeometry = (function (_super) {
            __extends(SubGeometry, _super);
            /**
            * Creates a new SubGeometry object.
            */
            function SubGeometry() {
                _super.call(this);
                this._verticesInvalid = new Array(8);
                this._uvsInvalid = new Array(8);
                this._secondaryUvsInvalid = new Array(8);
                this._normalsInvalid = new Array(8);
                this._tangentsInvalid = new Array(8);
                // buffers:
                this._vertexBuffer = new Array(8);
                this._uvBuffer = new Array(8);
                this._secondaryUvBuffer = new Array(8);
                this._vertexNormalBuffer = new Array(8);
                this._vertexTangentBuffer = new Array(8);
                // buffer dirty flags, per context:
                this._vertexBufferContext = new Array(8);
                this._uvBufferContext = new Array(8);
                this._secondaryUvBufferContext = new Array(8);
                this._vertexNormalBufferContext = new Array(8);
                this._vertexTangentBufferContext = new Array(8);
            }
            Object.defineProperty(SubGeometry.prototype, "numVertices", {
                get: /**
                * The total amount of vertices in the SubGeometry.
                */
                function () {
                    return this._numVertices;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SubGeometry.prototype.activateVertexBuffer = function (index, stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                if (!this._vertexBuffer[contextIndex] || this._vertexBufferContext[contextIndex] != context) {
                    this._vertexBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 3);
                    this._vertexBufferContext[contextIndex] = context;
                    this._verticesInvalid[contextIndex] = true;
                }

                if (this._verticesInvalid[contextIndex]) {
                    this._vertexBuffer[contextIndex].uploadFromArray(this._vertexData, 0, this._numVertices);
                    this._verticesInvalid[contextIndex] = false;
                }

                context.setVertexBufferAt(index, this._vertexBuffer[contextIndex], 0, away.gl.ContextGLVertexBufferFormat.FLOAT_3);
            };

            /**
            * @inheritDoc
            */
            SubGeometry.prototype.activateUVBuffer = function (index, stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                if (this._autoGenerateUVs && this._uvsDirty) {
                    this._uvs = this.pUpdateDummyUVs(this._uvs);
                }

                if (!this._uvBuffer[contextIndex] || this._uvBufferContext[contextIndex] != context) {
                    this._uvBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 2);
                    this._uvBufferContext[contextIndex] = context;
                    this._uvsInvalid[contextIndex] = true;
                }

                if (this._uvsInvalid[contextIndex]) {
                    this._uvBuffer[contextIndex].uploadFromArray(this._uvs, 0, this._numVertices);
                    this._uvsInvalid[contextIndex] = false;
                }

                context.setVertexBufferAt(index, this._uvBuffer[contextIndex], 0, away.gl.ContextGLVertexBufferFormat.FLOAT_2);
            };

            /**
            * @inheritDoc
            */
            SubGeometry.prototype.activateSecondaryUVBuffer = function (index, stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                if (!this._secondaryUvBuffer[contextIndex] || this._secondaryUvBufferContext[contextIndex] != context) {
                    this._secondaryUvBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 2);
                    this._secondaryUvBufferContext[contextIndex] = context;
                    this._secondaryUvsInvalid[contextIndex] = true;
                }

                if (this._secondaryUvsInvalid[contextIndex]) {
                    this._secondaryUvBuffer[contextIndex].uploadFromArray(this._secondaryUvs, 0, this._numVertices);
                    this._secondaryUvsInvalid[contextIndex] = false;
                }

                context.setVertexBufferAt(index, this._secondaryUvBuffer[contextIndex], 0, away.gl.ContextGLVertexBufferFormat.FLOAT_2);
            };

            /**
            * Retrieves the VertexBuffer object that contains vertex normals.
            * @param context The ContextGL for which we request the buffer
            * @return The VertexBuffer object that contains vertex normals.
            */
            SubGeometry.prototype.activateVertexNormalBuffer = function (index, stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                if (this._autoDeriveVertexNormals && this._vertexNormalsDirty)
                    this._vertexNormals = this.pUpdateVertexNormals(this._vertexNormals);

                if (!this._vertexNormalBuffer[contextIndex] || this._vertexNormalBufferContext[contextIndex] != context) {
                    this._vertexNormalBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 3);
                    this._vertexNormalBufferContext[contextIndex] = context;
                    this._normalsInvalid[contextIndex] = true;
                }

                if (this._normalsInvalid[contextIndex]) {
                    this._vertexNormalBuffer[contextIndex].uploadFromArray(this._vertexNormals, 0, this._numVertices);
                    this._normalsInvalid[contextIndex] = false;
                }

                context.setVertexBufferAt(index, this._vertexNormalBuffer[contextIndex], 0, away.gl.ContextGLVertexBufferFormat.FLOAT_3);
            };

            /**
            * Retrieves the VertexBuffer object that contains vertex tangents.
            * @param context The ContextGL for which we request the buffer
            * @return The VertexBuffer object that contains vertex tangents.
            */
            SubGeometry.prototype.activateVertexTangentBuffer = function (index, stageGL) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                if (this._vertexTangentsDirty) {
                    this._vertexTangents = this.pUpdateVertexTangents(this._vertexTangents);
                }

                if (!this._vertexTangentBuffer[contextIndex] || this._vertexTangentBufferContext[contextIndex] != context) {
                    this._vertexTangentBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 3);
                    this._vertexTangentBufferContext[contextIndex] = context;
                    this._tangentsInvalid[contextIndex] = true;
                }

                if (this._tangentsInvalid[contextIndex]) {
                    this._vertexTangentBuffer[contextIndex].uploadFromArray(this._vertexTangents, 0, this._numVertices);
                    this._tangentsInvalid[contextIndex] = false;
                }

                context.setVertexBufferAt(index, this._vertexTangentBuffer[contextIndex], 0, away.gl.ContextGLVertexBufferFormat.FLOAT_3);
            };

            SubGeometry.prototype.applyTransformation = function (transform) {
                _super.prototype.applyTransformation.call(this, transform);
                this.pInvalidateBuffers(this._verticesInvalid);
                this.pInvalidateBuffers(this._normalsInvalid);
                this.pInvalidateBuffers(this._tangentsInvalid);
            };

            /**
            * Clones the current object
            * @return An exact duplicate of the current object.
            */
            SubGeometry.prototype.clone = function () {
                var clone = new SubGeometry();
                clone.updateVertexData(this._vertexData.concat());
                clone.updateUVData(this._uvs.concat());
                clone.updateIndexData(this._indices.concat());

                if (this._secondaryUvs) {
                    clone.updateSecondaryUVData(this._secondaryUvs.concat());
                }

                if (!this._autoDeriveVertexNormals) {
                    clone.updateVertexNormalData(this._vertexNormals.concat());
                }

                if (!this._autoDeriveVertexTangents) {
                    clone.updateVertexTangentData(this._vertexTangents.concat());
                }

                return clone;
            };

            /**
            * @inheritDoc
            */
            SubGeometry.prototype.scale = function (scale) {
                _super.prototype.scale.call(this, scale);
                this.pInvalidateBuffers(this._verticesInvalid);
            };

            /**
            * @inheritDoc
            */
            SubGeometry.prototype.scaleUV = function (scaleU, scaleV) {
                if (typeof scaleU === "undefined") { scaleU = 1; }
                if (typeof scaleV === "undefined") { scaleV = 1; }
                _super.prototype.scaleUV.call(this, scaleU, scaleV);
                this.pInvalidateBuffers(this._uvsInvalid);
            };

            /**
            * Clears all resources used by the SubGeometry object.
            */
            SubGeometry.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this.pDisposeAllVertexBuffers();
                this._vertexBuffer = null;
                this._vertexNormalBuffer = null;
                this._uvBuffer = null;
                this._secondaryUvBuffer = null;
                this._vertexTangentBuffer = null;
                this._indexBuffer = null;
                this._uvs = null;
                this._secondaryUvs = null;
                this._vertexNormals = null;
                this._vertexTangents = null;
                this._vertexBufferContext = null;
                this._uvBufferContext = null;
                this._secondaryUvBufferContext = null;
                this._vertexNormalBufferContext = null;
                this._vertexTangentBufferContext = null;
            };

            SubGeometry.prototype.pDisposeAllVertexBuffers = function () {
                this.pDisposeVertexBuffers(this._vertexBuffer);
                this.pDisposeVertexBuffers(this._vertexNormalBuffer);
                this.pDisposeVertexBuffers(this._uvBuffer);
                this.pDisposeVertexBuffers(this._secondaryUvBuffer);
                this.pDisposeVertexBuffers(this._vertexTangentBuffer);
            };

            Object.defineProperty(SubGeometry.prototype, "vertexData", {
                get: /**
                * The raw vertex position data.
                */
                function () {
                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "vertexPositionData", {
                get: function () {
                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the vertex data of the SubGeometry.
            * @param vertices The new vertex data to upload.
            */
            SubGeometry.prototype.updateVertexData = function (vertices) {
                if (this._autoDeriveVertexNormals) {
                    this._vertexNormalsDirty = true;
                }

                if (this._autoDeriveVertexTangents) {
                    this._vertexTangentsDirty = true;
                }

                this._faceNormalsDirty = true;
                this._vertexData = vertices;
                var numVertices = vertices.length / 3;

                if (numVertices != this._numVertices) {
                    this.pDisposeAllVertexBuffers();
                }

                this._numVertices = numVertices;
                this.pInvalidateBuffers(this._verticesInvalid);
                this.pInvalidateBounds();
            };

            Object.defineProperty(SubGeometry.prototype, "UVData", {
                get: /**
                * The raw texture coordinate data.
                */
                function () {
                    if (this._uvsDirty && this._autoGenerateUVs) {
                        this._uvs = this.pUpdateDummyUVs(this._uvs);
                    }

                    return this._uvs;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "secondaryUVData", {
                get: function () {
                    return this._secondaryUvs;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the uv coordinates of the SubGeometry.
            * @param uvs The uv coordinates to upload.
            */
            SubGeometry.prototype.updateUVData = function (uvs) {
                if (this._autoDeriveVertexTangents) {
                    this._vertexTangentsDirty = true;
                }

                this._faceTangentsDirty = true;
                this._uvs = uvs;
                this.pInvalidateBuffers(this._uvsInvalid);
            };

            SubGeometry.prototype.updateSecondaryUVData = function (uvs) {
                this._secondaryUvs = uvs;
                this.pInvalidateBuffers(this._secondaryUvsInvalid);
            };

            Object.defineProperty(SubGeometry.prototype, "vertexNormalData", {
                get: /**
                * The raw vertex normal data.
                */
                function () {
                    if (this._autoDeriveVertexNormals && this._vertexNormalsDirty) {
                        this._vertexNormals = this.pUpdateVertexNormals(this._vertexNormals);
                    }

                    return this._vertexNormals;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the vertex normals of the SubGeometry. When updating the vertex normals like this,
            * autoDeriveVertexNormals will be set to false and vertex normals will no longer be calculated automatically.
            * @param vertexNormals The vertex normals to upload.
            */
            SubGeometry.prototype.updateVertexNormalData = function (vertexNormals) {
                this._vertexNormalsDirty = false;
                this._autoDeriveVertexNormals = (vertexNormals == null);
                this._vertexNormals = vertexNormals;
                this.pInvalidateBuffers(this._normalsInvalid);
            };

            Object.defineProperty(SubGeometry.prototype, "vertexTangentData", {
                get: /**
                * The raw vertex tangent data.
                *
                * @private
                */
                function () {
                    if (this._autoDeriveVertexTangents && this._vertexTangentsDirty) {
                        this._vertexTangents = this.pUpdateVertexTangents(this._vertexTangents);
                    }

                    return this._vertexTangents;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the vertex tangents of the SubGeometry. When updating the vertex tangents like this,
            * autoDeriveVertexTangents will be set to false and vertex tangents will no longer be calculated automatically.
            * @param vertexTangents The vertex tangents to upload.
            */
            SubGeometry.prototype.updateVertexTangentData = function (vertexTangents) {
                this._vertexTangentsDirty = false;
                this._autoDeriveVertexTangents = (vertexTangents == null);
                this._vertexTangents = vertexTangents;
                this.pInvalidateBuffers(this._tangentsInvalid);
            };

            SubGeometry.prototype.fromVectors = function (vertices, uvs, normals, tangents) {
                this.updateVertexData(vertices);
                this.updateUVData(uvs);
                this.updateVertexNormalData(normals);
                this.updateVertexTangentData(tangents);
            };

            SubGeometry.prototype.pUpdateVertexNormals = function (target) {
                this.pInvalidateBuffers(this._normalsInvalid);
                return _super.prototype.pUpdateVertexNormals.call(this, target);
            };

            SubGeometry.prototype.pUpdateVertexTangents = function (target) {
                if (this._vertexNormalsDirty) {
                    this._vertexNormals = this.pUpdateVertexNormals(this._vertexNormals);
                }

                this.pInvalidateBuffers(this._tangentsInvalid);
                return _super.prototype.pUpdateVertexTangents.call(this, target);
            };

            SubGeometry.prototype.pUpdateDummyUVs = function (target) {
                this.pInvalidateBuffers(this._uvsInvalid);
                return _super.prototype.pUpdateDummyUVs.call(this, target);
            };

            SubGeometry.prototype.pDisposeForStageGL = function (stageGL) {
                var index = stageGL._iStageGLIndex;
                if (this._vertexBuffer[index]) {
                    this._vertexBuffer[index].dispose();
                    this._vertexBuffer[index] = null;
                }
                if (this._uvBuffer[index]) {
                    this._uvBuffer[index].dispose();
                    this._uvBuffer[index] = null;
                }
                if (this._secondaryUvBuffer[index]) {
                    this._secondaryUvBuffer[index].dispose();
                    this._secondaryUvBuffer[index] = null;
                }
                if (this._vertexNormalBuffer[index]) {
                    this._vertexNormalBuffer[index].dispose();
                    this._vertexNormalBuffer[index] = null;
                }
                if (this._vertexTangentBuffer[index]) {
                    this._vertexTangentBuffer[index].dispose();
                    this._vertexTangentBuffer[index] = null;
                }
                if (this._indexBuffer[index]) {
                    this._indexBuffer[index].dispose();
                    this._indexBuffer[index] = null;
                }
            };

            Object.defineProperty(SubGeometry.prototype, "vertexStride", {
                get: function () {
                    return 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "vertexTangentStride", {
                get: function () {
                    return 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "vertexNormalStride", {
                get: function () {
                    return 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "UVStride", {
                get: function () {
                    return 2;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "secondaryUVStride", {
                get: function () {
                    return 2;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "vertexOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "vertexNormalOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "vertexTangentOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "UVOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "secondaryUVOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            SubGeometry.prototype.cloneWithSeperateBuffers = function () {
                var obj = this.clone();
                return obj;
            };
            return SubGeometry;
        })(base.SubGeometryBase);
        base.SubGeometry = SubGeometry;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        /**
        * The SubGeometry class is a collections of geometric data that describes a triangle mesh. It is owned by a
        * Geometry instance, and wrapped by a SubMesh in the scene graph.
        * Several SubGeometries are grouped so they can be rendered with different materials, but still represent a single
        * object.
        *
        * @see away.base.Geometry
        * @see away.base.SubMesh
        *
        * @class away.base.SubGeometry
        */
        var SegmentSubGeometry = (function (_super) {
            __extends(SegmentSubGeometry, _super);
            /**
            * Creates a new SubGeometry object.
            */
            function SegmentSubGeometry() {
                _super.call(this);
                // raw data:
                this._verticesInvalid = new Array(8);
                // buffers:
                this._vertexBuffer = new Array(8);
                // buffer dirty flags, per context:
                this._vertexBufferContext = new Array(8);
                this.LIMIT = 3 * 0xFFFF;
                this._indexSegments = 0;

                this._subSetCount = 0;
                this._subSets = [];
                this.addSubSet();

                this._pSegments = new Object();
            }
            Object.defineProperty(SegmentSubGeometry.prototype, "hasData", {
                get: function () {
                    return this._hasData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "numTriangles", {
                get: function () {
                    return this._numIndices / 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "segmentCount", {
                get: /**
                *
                */
                function () {
                    return this._indexSegments;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "iSubSetCount", {
                get: /**
                *
                */
                function () {
                    return this._subSetCount;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "numVertices", {
                get: /**
                * The total amount of vertices in the SubGeometry.
                */
                function () {
                    return this._numVertices;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SegmentSubGeometry.prototype.activateVertexBuffer = function (index, stageGL) {
                var subSet = this._subSets[index];

                this._activeSubSet = subSet;
                this._numIndices = subSet.numIndices;

                var vertexBuffer = subSet.vertexBuffer;

                if (subSet.vertexContextGL != stageGL.contextGL || subSet.vertexBufferDirty) {
                    subSet.vertexBuffer = stageGL.contextGL.createVertexBuffer(subSet.numVertices, 11);
                    subSet.vertexBuffer.uploadFromArray(subSet.vertices, 0, subSet.numVertices);
                    subSet.vertexBufferDirty = false;
                    subSet.vertexContextGL = stageGL.contextGL;
                }

                var context3d = stageGL.contextGL;
                context3d.setVertexBufferAt(0, vertexBuffer, 0, away.gl.ContextGLVertexBufferFormat.FLOAT_3);
                context3d.setVertexBufferAt(1, vertexBuffer, 3, away.gl.ContextGLVertexBufferFormat.FLOAT_3);
                context3d.setVertexBufferAt(2, vertexBuffer, 6, away.gl.ContextGLVertexBufferFormat.FLOAT_1);
                context3d.setVertexBufferAt(3, vertexBuffer, 7, away.gl.ContextGLVertexBufferFormat.FLOAT_4);
            };

            /**
            * @inheritDoc
            */
            SegmentSubGeometry.prototype.activateUVBuffer = function (index, stageGL) {
            };

            /**
            * @inheritDoc
            */
            SegmentSubGeometry.prototype.activateSecondaryUVBuffer = function (index, stageGL) {
            };

            /**
            * Retrieves the VertexBuffer object that contains vertex normals.
            * @param context The ContextGL for which we request the buffer
            * @return The VertexBuffer object that contains vertex normals.
            */
            SegmentSubGeometry.prototype.activateVertexNormalBuffer = function (index, stageGL) {
            };

            /**
            * Retrieves the VertexBuffer object that contains vertex tangents.
            * @param context The ContextGL for which we request the buffer
            * @return The VertexBuffer object that contains vertex tangents.
            */
            SegmentSubGeometry.prototype.activateVertexTangentBuffer = function (index, stageGL) {
            };

            SegmentSubGeometry.prototype.getIndexBuffer = function (stageGL) {
                if (this._activeSubSet.indexContextGL != stageGL.contextGL || this._activeSubSet.indexBufferDirty) {
                    this._activeSubSet.indexBuffer = stageGL.contextGL.createIndexBuffer(this._activeSubSet.numIndices);
                    this._activeSubSet.indexBuffer.uploadFromArray(this._activeSubSet.indices, 0, this._activeSubSet.numIndices);
                    this._activeSubSet.indexBufferDirty = false;
                    this._activeSubSet.indexContextGL = stageGL.contextGL;
                }

                return this._activeSubSet.indexBuffer;
            };

            SegmentSubGeometry.prototype.applyTransformation = function (transform) {
                _super.prototype.applyTransformation.call(this, transform);
                this.pInvalidateBuffers(this._verticesInvalid);
            };

            /**
            * Clones the current object
            * @return An exact duplicate of the current object.
            */
            SegmentSubGeometry.prototype.clone = function () {
                var clone = new SegmentSubGeometry();
                clone.updateVertexData(this._vertexData.concat());
                clone.updateIndexData(this._indices.concat());

                return clone;
            };

            /**
            * @inheritDoc
            */
            SegmentSubGeometry.prototype.scale = function (scale) {
                _super.prototype.scale.call(this, scale);
                this.pInvalidateBuffers(this._verticesInvalid);
            };

            /**
            * Clears all resources used by the SubGeometry object.
            */
            SegmentSubGeometry.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this.pDisposeAllVertexBuffers();
                this._vertexBuffer = null;
                this._indexBuffer = null;
                this._vertexBufferContext = null;

                this.removeAllSegments();

                this._pSegments = null;

                var subSet = this._subSets[0];
                subSet.vertices = null;
                subSet.indices = null;
                this._subSets = null;
            };

            SegmentSubGeometry.prototype.pDisposeAllVertexBuffers = function () {
                this.pDisposeVertexBuffers(this._vertexBuffer);
            };

            Object.defineProperty(SegmentSubGeometry.prototype, "vertexData", {
                get: /**
                * The raw vertex position data.
                */
                function () {
                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "vertexPositionData", {
                get: function () {
                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the vertex data of the SubGeometry.
            * @param vertices The new vertex data to upload.
            */
            SegmentSubGeometry.prototype.updateVertexData = function (vertices) {
                if (this._autoDeriveVertexNormals) {
                    this._vertexNormalsDirty = true;
                }

                if (this._autoDeriveVertexTangents) {
                    this._vertexTangentsDirty = true;
                }

                this._faceNormalsDirty = true;
                this._vertexData = vertices;
                var numVertices = vertices.length / 3;

                if (numVertices != this._numVertices) {
                    this.pDisposeAllVertexBuffers();
                }

                this._numVertices = numVertices;
                this.pInvalidateBuffers(this._verticesInvalid);
                this.pInvalidateBounds();
            };

            SegmentSubGeometry.prototype.fromVectors = function (vertices, uvs, normals, tangents) {
                this.updateVertexData(vertices);
            };

            SegmentSubGeometry.prototype.pDisposeForStageGL = function (stageGL) {
                var index = stageGL._iStageGLIndex;
                if (this._vertexBuffer[index]) {
                    this._vertexBuffer[index].dispose();
                    this._vertexBuffer[index] = null;
                }
                if (this._indexBuffer[index]) {
                    this._indexBuffer[index].dispose();
                    this._indexBuffer[index] = null;
                }
            };

            Object.defineProperty(SegmentSubGeometry.prototype, "vertexStride", {
                get: function () {
                    return 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "vertexTangentStride", {
                get: function () {
                    return 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "vertexNormalStride", {
                get: function () {
                    return 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "UVStride", {
                get: function () {
                    return 2;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "secondaryUVStride", {
                get: function () {
                    return 2;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "vertexOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "vertexNormalOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "vertexTangentOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "UVOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSubGeometry.prototype, "secondaryUVOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            SegmentSubGeometry.prototype.cloneWithSeperateBuffers = function () {
                var obj = this.clone();
                return obj;
            };

            /**
            * //TODO
            *
            * @param segment
            */
            SegmentSubGeometry.prototype.addSegment = function (segment) {
                segment.iSegmentsBase = this;

                this._hasData = true;

                var subSetIndex = this._subSets.length - 1;
                var subSet = this._subSets[subSetIndex];

                if (subSet.vertices.length + 44 > this.LIMIT) {
                    subSet = this.addSubSet();
                    subSetIndex++;
                }

                segment.iIndex = subSet.vertices.length;
                segment.iSubSetIndex = subSetIndex;

                this.iUpdateSegment(segment);

                var index = subSet.lineCount << 2;

                subSet.indices.push(index, index + 1, index + 2, index + 3, index + 2, index + 1);
                subSet.numVertices = subSet.vertices.length / 11;
                subSet.numIndices = subSet.indices.length;
                subSet.lineCount++;

                var segRef = new SegRef();
                segRef.index = index;
                segRef.subSetIndex = subSetIndex;
                segRef.segment = segment;

                this._pSegments[this._indexSegments] = segRef;

                this._indexSegments++;
            };

            /**
            * //TODO
            *
            * @param index
            * @returns {*}
            */
            SegmentSubGeometry.prototype.getSegment = function (index) {
                if (index > this._indexSegments - 1)
                    return null;

                return this._pSegments[index].segment;
            };

            /**
            * //TODO
            *
            * @param index
            * @param dispose
            */
            SegmentSubGeometry.prototype.removeSegmentByIndex = function (index, dispose) {
                if (typeof dispose === "undefined") { dispose = false; }
                var segRef;
                if (index >= this._indexSegments)
                    return;

                if (this._pSegments[index])
                    segRef = this._pSegments[index];
else
                    return;

                var subSet;
                if (!this._subSets[segRef.subSetIndex])
                    return;

                var subSetIndex = segRef.subSetIndex;
                subSet = this._subSets[segRef.subSetIndex];

                var segment = segRef.segment;
                var indices = subSet.indices;

                var ind = index * 6;
                for (var i = ind; i < indices.length; ++i) {
                    indices[i] -= 4;
                }
                subSet.indices.splice(index * 6, 6);
                subSet.vertices.splice(index * 44, 44);
                subSet.numVertices = subSet.vertices.length / 11;
                subSet.numIndices = indices.length;
                subSet.vertexBufferDirty = true;
                subSet.indexBufferDirty = true;
                subSet.lineCount--;

                if (dispose) {
                    segment.dispose();
                    segment = null;
                } else {
                    segment.iIndex = -1;
                    segment.iSegmentsBase = null;
                }

                if (subSet.lineCount == 0) {
                    if (subSetIndex == 0) {
                        this._hasData = false;
                    } else {
                        subSet.dispose();
                        this._subSets[subSetIndex] = null;
                        this._subSets.splice(subSetIndex, 1);
                    }
                }

                this.reOrderIndices(subSetIndex, index);

                segRef = null;
                this._pSegments[this._indexSegments] = null;
                this._indexSegments--;
            };

            /**
            * //TODO
            */
            SegmentSubGeometry.prototype.removeAllSegments = function () {
                var subSet;
                for (var i = 0; i < this._subSetCount; ++i) {
                    subSet = this._subSets[i];
                    subSet.vertices = null;
                    subSet.indices = null;
                    if (subSet.vertexBuffer)
                        subSet.vertexBuffer.dispose();

                    if (subSet.indexBuffer)
                        subSet.indexBuffer.dispose();

                    subSet = null;
                }

                for (var segRef in this._pSegments)
                    segRef = null;

                this._pSegments = null;
                this._subSetCount = 0;
                this._activeSubSet = null;
                this._indexSegments = 0;
                this._subSets = [];
                this._pSegments = new Object();

                this.addSubSet();

                this._hasData = false;
            };

            /**
            * //TODO
            *
            * @param segment
            * @param dispose
            */
            SegmentSubGeometry.prototype.removeSegment = function (segment, dispose) {
                if (typeof dispose === "undefined") { dispose = false; }
                if (segment.iIndex == -1)
                    return;

                this.removeSegmentByIndex(segment.iIndex / 44);
            };

            /**
            * //TODO
            *
            * @protected
            */
            SegmentSubGeometry.prototype.updateBounds = function (bounds) {
                var subSet;
                var len;
                var v;
                var index;

                var minX = Infinity;
                var minY = Infinity;
                var minZ = Infinity;
                var maxX = -Infinity;
                var maxY = -Infinity;
                var maxZ = -Infinity;
                var vertices;

                for (var i = 0; i < this._subSetCount; ++i) {
                    subSet = this._subSets[i];
                    index = 0;
                    vertices = subSet.vertices;
                    len = vertices.length;

                    if (len == 0)
                        continue;

                    while (index < len) {
                        v = vertices[index++];
                        if (v < minX)
                            minX = v;
else if (v > maxX)
                            maxX = v;

                        v = vertices[index++];
                        if (v < minY)
                            minY = v;
else if (v > maxY)
                            maxY = v;

                        v = vertices[index++];
                        if (v < minZ)
                            minZ = v;
else if (v > maxZ)
                            maxZ = v;

                        index += 8;
                    }
                }

                if (minX != Infinity) {
                    bounds.fromExtremes(minX, minY, minZ, maxX, maxY, maxZ);
                } else {
                    var min = .5;
                    bounds.fromExtremes(-min, -min, -min, min, min, min);
                }
            };

            SegmentSubGeometry.prototype._iSetColor = function (color) {
                for (var segRef in this._pSegments)
                    segRef.segment.startColor = segRef.segment.endColor = color;
            };

            SegmentSubGeometry.prototype._iSetThickness = function (thickness) {
                for (var segRef in this._pSegments)
                    segRef.segment.thickness = segRef.segment.thickness = thickness;
            };

            /**
            * //TODO
            *
            * @param segment
            *
            * @internal
            */
            SegmentSubGeometry.prototype.iUpdateSegment = function (segment) {
                var start = segment._pStart;
                var end = segment._pEnd;
                var startX = start.x, startY = start.y, startZ = start.z;
                var endX = end.x, endY = end.y, endZ = end.z;
                var startR = segment._pStartR, startG = segment._pStartG, startB = segment._pStartB;
                var endR = segment._pEndR, endG = segment._pEndG, endB = segment._pEndB;
                var index = segment.iIndex;
                var t = segment.thickness;

                var subSet = this._subSets[segment.iSubSetIndex];
                var vertices = subSet.vertices;

                vertices[index++] = startX;
                vertices[index++] = startY;
                vertices[index++] = startZ;
                vertices[index++] = endX;
                vertices[index++] = endY;
                vertices[index++] = endZ;
                vertices[index++] = t;
                vertices[index++] = startR;
                vertices[index++] = startG;
                vertices[index++] = startB;
                vertices[index++] = 1;

                vertices[index++] = endX;
                vertices[index++] = endY;
                vertices[index++] = endZ;
                vertices[index++] = startX;
                vertices[index++] = startY;
                vertices[index++] = startZ;
                vertices[index++] = -t;
                vertices[index++] = endR;
                vertices[index++] = endG;
                vertices[index++] = endB;
                vertices[index++] = 1;

                vertices[index++] = startX;
                vertices[index++] = startY;
                vertices[index++] = startZ;
                vertices[index++] = endX;
                vertices[index++] = endY;
                vertices[index++] = endZ;
                vertices[index++] = -t;
                vertices[index++] = startR;
                vertices[index++] = startG;
                vertices[index++] = startB;
                vertices[index++] = 1;

                vertices[index++] = endX;
                vertices[index++] = endY;
                vertices[index++] = endZ;
                vertices[index++] = startX;
                vertices[index++] = startY;
                vertices[index++] = startZ;
                vertices[index++] = t;
                vertices[index++] = endR;
                vertices[index++] = endG;
                vertices[index++] = endB;
                vertices[index++] = 1;

                subSet.vertexBufferDirty = true;
            };

            /**
            * //TODO
            * @returns {SubSet}
            *
            * @private
            */
            SegmentSubGeometry.prototype.addSubSet = function () {
                var subSet = new SubSet();
                this._subSets.push(subSet);

                subSet.vertices = [];
                subSet.numVertices = 0;
                subSet.indices = [];
                subSet.numIndices = 0;
                subSet.vertexBufferDirty = true;
                subSet.indexBufferDirty = true;
                subSet.lineCount = 0;

                this._subSetCount++;

                return subSet;
            };

            /**
            * //TODO
            * @param subSetIndex
            * @param index
            *
            * @private
            */
            SegmentSubGeometry.prototype.reOrderIndices = function (subSetIndex, index) {
                var segRef;

                for (var i = index; i < this._indexSegments - 1; ++i) {
                    segRef = this._pSegments[i + 1];
                    segRef.index = i;
                    if (segRef.subSetIndex == subSetIndex)
                        segRef.segment.iIndex -= 44;

                    this._pSegments[i] = segRef;
                }
            };
            return SegmentSubGeometry;
        })(base.SubGeometryBase);
        base.SegmentSubGeometry = SegmentSubGeometry;

        var SegRef = (function () {
            function SegRef() {
            }
            return SegRef;
        })();

        var SubSet = (function () {
            function SubSet() {
            }
            SubSet.prototype.dispose = function () {
                this.vertices = null;
                if (this.vertexBuffer)
                    this.vertexBuffer.dispose();

                if (this.indexBuffer)
                    this.indexBuffer.dispose();
            };
            return SubSet;
        })();
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pool
    */
    (function (pool) {
        /**
        * @class away.pool.RenderableListItem
        */
        var RenderableBase = (function () {
            /**
            *
            * @param sourceEntity
            * @param materialOwner
            * @param subGeometry
            * @param animationSubGeometry
            */
            function RenderableBase(sourceEntity, materialOwner, subGeometry, animationSubGeometry) {
                this.sourceEntity = sourceEntity;
                this.materialOwner = materialOwner;
                this.subGeometry = subGeometry;
                this.animationSubGeometry = animationSubGeometry;
            }
            return RenderableBase;
        })();
        pool.RenderableBase = RenderableBase;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pool
    */
    (function (pool) {
        /**
        * @class away.pool.RenderableListItem
        */
        var BillboardRenderable = (function (_super) {
            __extends(BillboardRenderable, _super);
            function BillboardRenderable(billboard) {
                _super.call(this, billboard, billboard, null, null);

                if (!BillboardRenderable._geometry) {
                    BillboardRenderable._geometry = new away.base.SubGeometry();
                    BillboardRenderable._geometry.updateVertexData(Array(0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0));
                    BillboardRenderable._geometry.updateUVData(Array(0, 0, 1, 0, 1, 1, 0, 1));
                    BillboardRenderable._geometry.updateIndexData(Array(0, 1, 2, 0, 2, 3));
                    BillboardRenderable._geometry.updateVertexTangentData(Array(1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0));
                    BillboardRenderable._geometry.updateVertexNormalData(Array(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1));
                }

                this.subGeometry = BillboardRenderable._geometry;
            }
            return BillboardRenderable;
        })(pool.RenderableBase);
        pool.BillboardRenderable = BillboardRenderable;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pool
    */
    (function (pool) {
        /**
        * @class away.pool.BillboardRenderablePool
        */
        var BillboardRenderablePool = (function () {
            function BillboardRenderablePool() {
                this._pool = new Object();
            }
            BillboardRenderablePool.prototype.getItem = function (billboard) {
                return (this._pool[billboard.id] || (this._pool[billboard.id] = new pool.BillboardRenderable(billboard)));
            };

            BillboardRenderablePool.prototype.dispose = function (billboard) {
                this._pool[billboard.id] = null;
            };

            BillboardRenderablePool.prototype.disposeAll = function () {
                this._pool = new Object();
            };
            return BillboardRenderablePool;
        })();
        pool.BillboardRenderablePool = BillboardRenderablePool;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pool
    */
    (function (pool) {
        /**
        * @class away.pool.RenderableListItem
        */
        var SegmentSetRenderable = (function (_super) {
            __extends(SegmentSetRenderable, _super);
            function SegmentSetRenderable(segmentSet) {
                _super.call(this, segmentSet, segmentSet, segmentSet.subGeometry, null);
            }
            return SegmentSetRenderable;
        })(pool.RenderableBase);
        pool.SegmentSetRenderable = SegmentSetRenderable;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pool
    */
    (function (pool) {
        /**
        * @class away.pool.SegmentSetRenderablePool
        */
        var SegmentSetRenderablePool = (function () {
            function SegmentSetRenderablePool() {
                this._pool = new Object();
            }
            SegmentSetRenderablePool.prototype.getItem = function (segmentSet) {
                return (this._pool[segmentSet.id] || (this._pool[segmentSet.id] = new pool.SegmentSetRenderable(segmentSet)));
            };

            SegmentSetRenderablePool.prototype.dispose = function (segmentSet) {
                this._pool[segmentSet.id] = null;
            };

            SegmentSetRenderablePool.prototype.disposeAll = function () {
                this._pool = new Object();
            };
            return SegmentSetRenderablePool;
        })();
        pool.SegmentSetRenderablePool = SegmentSetRenderablePool;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pool
    */
    (function (pool) {
        /**
        * @class away.pool.SubMeshRenderable
        */
        var SubMeshRenderable = (function (_super) {
            __extends(SubMeshRenderable, _super);
            function SubMeshRenderable(subMesh) {
                _super.call(this, subMesh.sourceEntity, subMesh, subMesh.subGeometry, subMesh.animationSubGeometry);

                //super(subMesh.sourceEntity, subMesh, subMesh.subGeometry, subMesh.animationSubGeometry);
                this.subMesh = subMesh;
            }
            return SubMeshRenderable;
        })(pool.RenderableBase);
        pool.SubMeshRenderable = SubMeshRenderable;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pool
    */
    (function (pool) {
        /**
        * @class away.pool.SubMeshRenderablePool
        */
        var SubMeshRenderablePool = (function () {
            function SubMeshRenderablePool() {
                this._pool = new Object();
            }
            SubMeshRenderablePool.prototype.getItem = function (subMesh) {
                return (this._pool[subMesh.id] || (this._pool[subMesh.id] = new pool.SubMeshRenderable(subMesh)));
            };

            SubMeshRenderablePool.prototype.dispose = function (subMesh) {
                this._pool[subMesh.id] = null;
            };

            SubMeshRenderablePool.prototype.disposeAll = function () {
                this._pool = new Object();
            };
            return SubMeshRenderablePool;
        })();
        pool.SubMeshRenderablePool = SubMeshRenderablePool;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pool
    */
    (function (pool) {
        /**
        * @class away.pool.SkyboxRenderable
        */
        var SkyboxRenderable = (function (_super) {
            __extends(SkyboxRenderable, _super);
            function SkyboxRenderable(skybox) {
                _super.call(this, skybox, skybox, null, null);

                if (!SkyboxRenderable._geometry) {
                    SkyboxRenderable._geometry = new away.base.SubGeometry();
                    SkyboxRenderable._geometry.updateVertexData(Array(-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1));
                    SkyboxRenderable._geometry.updateIndexData(Array(0, 1, 2, 2, 3, 0, 6, 5, 4, 4, 7, 6, 2, 6, 7, 7, 3, 2, 4, 5, 1, 1, 0, 4, 4, 0, 3, 3, 7, 4, 2, 1, 5, 5, 6, 2));
                }

                this.subGeometry = SkyboxRenderable._geometry;
            }
            return SkyboxRenderable;
        })(pool.RenderableBase);
        pool.SkyboxRenderable = SkyboxRenderable;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pool
    */
    (function (pool) {
        /**
        * @class away.pool.SkyboxRenderablePool
        */
        var SkyboxRenderablePool = (function () {
            function SkyboxRenderablePool() {
                this._pool = new Object();
            }
            SkyboxRenderablePool.prototype.getItem = function (skybox) {
                return (this._pool[skybox.id] || (this._pool[skybox.id] = new pool.SkyboxRenderable(skybox)));
            };

            SkyboxRenderablePool.prototype.dispose = function (skybox) {
                this._pool[skybox.id] = null;
            };

            SkyboxRenderablePool.prototype.disposeAll = function () {
                this._pool = new Object();
            };
            return SkyboxRenderablePool;
        })();
        pool.SkyboxRenderablePool = SkyboxRenderablePool;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.traverse
    */
    (function (traverse) {
        /**
        * @class away.traverse.EntityCollector
        */
        var RenderableCollectorBase = (function () {
            function RenderableCollectorBase() {
                this._numCullPlanes = 0;
                this._pEntityListItemPool = new away.pool.EntityListItemPool();
                this._pBillboardRenderablePool = new away.pool.BillboardRenderablePool();
                this._pSegmentSetRenderablePool = new away.pool.SegmentSetRenderablePool();
                this._pSkyboxRenderablePool = new away.pool.SkyboxRenderablePool();
                this._pSubMeshRenderablePool = new away.pool.SubMeshRenderablePool();

                //default sorting algorithm
                this.renderableSorter = new away.sort.RenderableMergeSort();
            }
            Object.defineProperty(RenderableCollectorBase.prototype, "camera", {
                get: /**
                *
                */
                function () {
                    return this._pCamera;
                },
                set: function (value) {
                    this._pCamera = value;
                    this._iEntryPoint = this._pCamera.scenePosition;
                    this._pCameraForward = this._pCamera.transform.forwardVector;
                    this._cullPlanes = this._pCamera.frustumPlanes;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RenderableCollectorBase.prototype, "cullPlanes", {
                get: /**
                *
                */
                function () {
                    return this._customCullPlanes;
                },
                set: function (value) {
                    this._customCullPlanes = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RenderableCollectorBase.prototype, "entityHead", {
                get: /**
                *
                */
                function () {
                    return this._pEntityHead;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RenderableCollectorBase.prototype, "entryPoint", {
                get: function () {
                    return this._iEntryPoint;
                },
                enumerable: true,
                configurable: true
            });

            /**
            *
            */
            RenderableCollectorBase.prototype.clear = function () {
                this._iEntryPoint = this._pCamera.scenePosition;
                this._pCameraForward = this._pCamera.transform.forwardVector;
                this._cullPlanes = this._customCullPlanes ? this._customCullPlanes : (this._pCamera ? this._pCamera.frustumPlanes : null);
                this._numCullPlanes = this._cullPlanes ? this._cullPlanes.length : 0;
                this._pEntityHead = null;
                this._pEntityListItemPool.freeAll();
            };

            /**
            *
            * @param node
            * @returns {boolean}
            */
            RenderableCollectorBase.prototype.enterNode = function (node) {
                var enter = this.scene._iCollectionMark != node._iCollectionMark && node.isInFrustum(this._cullPlanes, this._numCullPlanes);

                node._iCollectionMark = this.scene._iCollectionMark;

                return enter;
            };

            /**
            *
            * @param entity
            */
            RenderableCollectorBase.prototype.applyEntity = function (entity) {
                var item = this._pEntityListItemPool.getItem();
                item.entity = entity;

                item.next = this._pEntityHead;
                this._pEntityHead = item;

                this.pFindRenderable(entity);
            };

            RenderableCollectorBase.prototype.sortRenderables = function () {
                throw new away.errors.AbstractMethodError();
            };

            /**
            *
            * @param billboard
            * @protected
            */
            RenderableCollectorBase.prototype.pApplyBillboard = function (billboard) {
                this.pApplyRenderable(this._pBillboardRenderablePool.getItem(billboard));
            };

            /**
            *
            * @param mesh
            * @protected
            */
            RenderableCollectorBase.prototype.pApplyMesh = function (mesh) {
                var subMesh;
                var renderable;

                var len = mesh.subMeshes.length;
                for (var i = 0; i < len; i++)
                    this.pApplyRenderable(this._pSubMeshRenderablePool.getItem(mesh.subMeshes[i]));
            };

            /**
            *
            * @param renderable
            * @protected
            */
            RenderableCollectorBase.prototype.pApplyRenderable = function (renderable) {
                throw new away.errors.AbstractMethodError();
            };

            RenderableCollectorBase.prototype.pApplySkybox = function (skybox) {
                this.pApplyRenderable(this._pSkyboxRenderablePool.getItem(skybox));
            };

            RenderableCollectorBase.prototype.pApplySegmentSet = function (segmentSet) {
                this.pApplyRenderable(this._pSegmentSetRenderablePool.getItem(segmentSet));
            };

            /**
            *
            * @param entity
            */
            RenderableCollectorBase.prototype.pFindRenderable = function (entity) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * //TODO
            *
            * @param entity
            * @param shortestCollisionDistance
            * @param findClosest
            * @returns {boolean}
            *
            * @internal
            */
            RenderableCollectorBase.prototype._iCollidesBefore = function (entity, shortestCollisionDistance, findClosest) {
                var pickingCollider = entity.pickingCollider;
                var pickingCollisionVO = entity._iPickingCollisionVO;

                pickingCollider.setLocalRay(entity._iPickingCollisionVO.localRayPosition, entity._iPickingCollisionVO.localRayDirection);
                pickingCollisionVO.materialOwner = null;

                if (entity.assetType === away.library.AssetType.BILLBOARD) {
                    return this.testBillBoard(entity, pickingCollider, pickingCollisionVO, shortestCollisionDistance, findClosest);
                } else if (entity.assetType === away.library.AssetType.MESH) {
                    return this.testMesh(entity, pickingCollider, pickingCollisionVO, shortestCollisionDistance, findClosest);
                }

                return false;
            };

            RenderableCollectorBase.prototype.testBillBoard = function (billboard, pickingCollider, pickingCollisionVO, shortestCollisionDistance, findClosest) {
                if (pickingCollider.testRenderableCollision(this._pBillboardRenderablePool.getItem(billboard), pickingCollisionVO, shortestCollisionDistance)) {
                    shortestCollisionDistance = pickingCollisionVO.rayEntryDistance;

                    pickingCollisionVO.materialOwner = billboard;

                    return true;
                }

                return false;
            };

            RenderableCollectorBase.prototype.testMesh = function (mesh, pickingCollider, pickingCollisionVO, shortestCollisionDistance, findClosest) {
                var subMesh;
                var renderable;

                var len = mesh.subMeshes.length;
                for (var i = 0; i < len; ++i) {
                    subMesh = mesh.subMeshes[i];
                    renderable = this._pSubMeshRenderablePool.getItem(subMesh);

                    if (pickingCollider.testRenderableCollision(renderable, pickingCollisionVO, shortestCollisionDistance)) {
                        shortestCollisionDistance = pickingCollisionVO.rayEntryDistance;

                        pickingCollisionVO.materialOwner = subMesh;

                        if (!findClosest)
                            return true;
                    }
                }

                return pickingCollisionVO.materialOwner != null;
            };
            return RenderableCollectorBase;
        })();
        traverse.RenderableCollectorBase = RenderableCollectorBase;
    })(away.traverse || (away.traverse = {}));
    var traverse = away.traverse;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.traverse
    */
    (function (traverse) {
        /**
        * @class away.traverse.EntityCollector
        */
        var EntityCollector = (function (_super) {
            __extends(EntityCollector, _super);
            function EntityCollector() {
                _super.call(this);
                this._pNumLights = 0;
                this._pNumTriangles = 0;
                this._pNumEntities = 0;
                this._pNumInteractiveEntities = 0;
                this._numDirectionalLights = 0;
                this._numPointLights = 0;
                this._numLightProbes = 0;

                this._pLights = new Array();
                this._directionalLights = new Array();
                this._pointLights = new Array();
                this._lightProbes = new Array();
            }
            Object.defineProperty(EntityCollector.prototype, "directionalLights", {
                get: /**
                *
                */
                function () {
                    return this._directionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "blendedRenderableHead", {
                get: /**
                *
                */
                function () {
                    return this._pBlendedRenderableHead;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "lightProbes", {
                get: /**
                *
                */
                function () {
                    return this._lightProbes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "lights", {
                get: /**
                *
                */
                function () {
                    return this._pLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "numEntities", {
                get: /**
                *
                */
                function () {
                    return this._pNumEntities;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "numInteractiveEntities", {
                get: /**
                *
                */
                function () {
                    return this._pNumInteractiveEntities;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "numTriangles", {
                get: /**
                *
                */
                function () {
                    return this._pNumTriangles;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "opaqueRenderableHead", {
                get: /**
                *
                */
                function () {
                    return this._pOpaqueRenderableHead;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "pointLights", {
                get: /**
                *
                */
                function () {
                    return this._pointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "skyBox", {
                get: /**
                *
                */
                function () {
                    return this._pSkybox;
                },
                enumerable: true,
                configurable: true
            });

            /**
            *
            */
            EntityCollector.prototype.applyEntity = function (entity) {
                _super.prototype.applyEntity.call(this, entity);

                this._pNumEntities++;

                if (entity._iIsMouseEnabled())
                    this._pNumInteractiveEntities++;
            };

            EntityCollector.prototype.sortRenderables = function () {
                this._pOpaqueRenderableHead = this.renderableSorter.sortOpaqueRenderables(this._pOpaqueRenderableHead);
                this._pBlendedRenderableHead = this.renderableSorter.sortBlendedRenderables(this._pBlendedRenderableHead);
            };

            /**
            *
            */
            EntityCollector.prototype.clear = function () {
                _super.prototype.clear.call(this);

                this._pBlendedRenderableHead = null;
                this._pOpaqueRenderableHead = null;
                this._pNumTriangles = this._pNumEntities = this._pNumInteractiveEntities = 0;
                this._pSkybox = null;

                if (this._pNumLights > 0)
                    this._pLights.length = this._pNumLights = 0;

                if (this._numDirectionalLights > 0)
                    this._directionalLights.length = this._numDirectionalLights = 0;

                if (this._numPointLights > 0)
                    this._pointLights.length = this._numPointLights = 0;

                if (this._numLightProbes > 0)
                    this._lightProbes.length = this._numLightProbes = 0;
            };

            /**
            *
            * @param renderable
            * @protected
            */
            EntityCollector.prototype.pApplyRenderable = function (renderable) {
                var material = renderable.materialOwner.material;
                var entity = renderable.sourceEntity;
                var position = entity.scenePosition;

                if (material) {
                    //set ids for faster referencing
                    renderable.materialId = material._iMaterialId;
                    renderable.renderOrderId = material._iRenderOrderId;
                    renderable.cascaded = false;

                    // project onto camera's z-axis
                    position = this._iEntryPoint.subtract(position);
                    renderable.zIndex = entity.zOffset + position.dotProduct(this._pCameraForward);

                    //store reference to scene transform
                    renderable.renderSceneTransform = renderable.sourceEntity.getRenderSceneTransform(this._pCamera);

                    if (material.requiresBlending) {
                        renderable.next = this._pBlendedRenderableHead;
                        this._pBlendedRenderableHead = renderable;
                    } else {
                        renderable.next = this._pOpaqueRenderableHead;
                        this._pOpaqueRenderableHead = renderable;
                    }
                }

                this._pNumTriangles += renderable.subGeometry.numTriangles;
            };

            /**
            *
            * @param entity
            */
            EntityCollector.prototype.pFindRenderable = function (entity) {
                if (entity.assetType === away.library.AssetType.BILLBOARD) {
                    this.pApplyBillboard(entity);
                } else if (entity.assetType === away.library.AssetType.MESH) {
                    this.pApplyMesh(entity);
                } else if (entity.assetType === away.library.AssetType.LIGHT) {
                    this._pLights[this._pNumLights++] = entity;

                    if (entity instanceof away.lights.DirectionalLight)
                        this._directionalLights[this._numDirectionalLights++] = entity;
else if (entity instanceof away.lights.PointLight)
                        this._pointLights[this._numPointLights++] = entity;
else if (entity instanceof away.lights.LightProbe)
                        this._lightProbes[this._numLightProbes++] = entity;
                } else if (entity.assetType === away.library.AssetType.SKYBOX) {
                    this.pApplySkybox(entity);
                } else if (entity.assetType === away.library.AssetType.SEGMENT_SET) {
                    this.pApplySegmentSet(entity);
                }
            };
            return EntityCollector;
        })(traverse.RenderableCollectorBase);
        traverse.EntityCollector = EntityCollector;
    })(away.traverse || (away.traverse = {}));
    var traverse = away.traverse;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.traverse
    */
    (function (traverse) {
        /**
        * @class away.traverse.ShadowCasterCollector
        */
        var ShadowCasterCollector = (function (_super) {
            __extends(ShadowCasterCollector, _super);
            function ShadowCasterCollector() {
                _super.call(this);
            }
            /**
            *
            */
            ShadowCasterCollector.prototype.enterNode = function (node) {
                var enter = this.scene._iCollectionMark != node._iCollectionMark && node.isCastingShadow();

                if (!enter) {
                    node._iCollectionMark = this.scene._iCollectionMark;

                    return false;
                }

                return _super.prototype.enterNode.call(this, node);
            };
            ShadowCasterCollector.prototype.pApplyRenderable = function (renderable) {
                var material = renderable.materialOwner.material;
                var entity = renderable.sourceEntity;
                var position = entity.scenePosition;

                if (material) {
                    //set ids for faster referencing
                    renderable.materialId = material._iMaterialId;
                    renderable.renderOrderId = material._iRenderOrderId;
                    renderable.cascaded = false;

                    // project onto camera's z-axis
                    position = this._iEntryPoint.subtract(position);
                    renderable.zIndex = entity.zOffset + position.dotProduct(this._pCameraForward);

                    //store reference to scene transform
                    renderable.renderSceneTransform = renderable.sourceEntity.getRenderSceneTransform(this._pCamera);

                    if (material.requiresBlending) {
                        renderable.next = this._pBlendedRenderableHead;
                        this._pBlendedRenderableHead = renderable;
                    } else {
                        renderable.next = this._pOpaqueRenderableHead;
                        this._pOpaqueRenderableHead = renderable;
                    }
                }

                this._pNumTriangles += renderable.subGeometry.numTriangles;
            };

            /**
            *
            * @param entity
            */
            ShadowCasterCollector.prototype.pFindRenderable = function (entity) {
                if (entity.assetType == away.library.AssetType.BILLBOARD) {
                    this.pApplyBillboard(entity);
                } else if (entity.assetType == away.library.AssetType.MESH) {
                    this.pApplyMesh(entity);
                }
            };
            return ShadowCasterCollector;
        })(traverse.EntityCollector);
        traverse.ShadowCasterCollector = ShadowCasterCollector;
    })(away.traverse || (away.traverse = {}));
    var traverse = away.traverse;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.traverse
    */
    (function (traverse) {
        /**
        * The RaycastCollector class is a traverser for scene partitions that collects all scene graph entities that are
        * considered intersecting with the defined ray.
        *
        * @see away.partition.Partition
        * @see away.entities.IEntity
        *
        * @class away.traverse.RaycastCollector
        */
        var RaycastCollector = (function (_super) {
            __extends(RaycastCollector, _super);
            /**
            * Creates a new RaycastCollector object.
            */
            function RaycastCollector() {
                _super.call(this);
                this._rayPosition = new away.geom.Vector3D();
                this._rayDirection = new away.geom.Vector3D();
                this._iCollectionMark = 0;
            }
            Object.defineProperty(RaycastCollector.prototype, "camera", {
                get: /**
                *
                */
                function () {
                    return this._pCamera;
                },
                set: function (value) {
                    this._pCamera = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RaycastCollector.prototype, "rayPosition", {
                get: /**
                * Provides the starting position of the ray.
                */
                function () {
                    return this._rayPosition;
                },
                set: function (value) {
                    this._rayPosition = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RaycastCollector.prototype, "rayDirection", {
                get: /**
                * Provides the direction vector of the ray.
                */
                function () {
                    return this._rayDirection;
                },
                set: function (value) {
                    this._rayDirection = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Returns true if the current node is at least partly in the frustum. If so, the partition node knows to pass on the traverser to its children.
            *
            * @param node The Partition3DNode object to frustum-test.
            */
            RaycastCollector.prototype.enterNode = function (node) {
                return node.isIntersectingRay(this._rayPosition, this._rayDirection);
            };

            /**
            *
            * @param entity
            */
            RaycastCollector.prototype.pFindRenderable = function (entity) {
                //no renderables required
            };
            return RaycastCollector;
        })(traverse.RenderableCollectorBase);
        traverse.RaycastCollector = RaycastCollector;
    })(away.traverse || (away.traverse = {}));
    var traverse = away.traverse;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.partition
    */
    (function (partition) {
        /**
        * @class away.partition.DirectionalLightNode
        */
        var DirectionalLightNode = (function (_super) {
            __extends(DirectionalLightNode, _super);
            /**
            *
            * @param directionalLight
            */
            function DirectionalLightNode(directionalLight) {
                _super.call(this, directionalLight);

                this._directionalLight = directionalLight;
            }
            /**
            * @inheritDoc
            */
            DirectionalLightNode.prototype.acceptTraverser = function (traverser) {
                //do not run frustum checks on lights
                traverser.applyEntity(this._directionalLight);
            };

            /**
            *
            * @returns {boolean}
            */
            DirectionalLightNode.prototype.isCastingShadow = function () {
                return false;
            };
            return DirectionalLightNode;
        })(partition.EntityNode);
        partition.DirectionalLightNode = DirectionalLightNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.partition
    */
    (function (partition) {
        /**
        * @class away.partition.LightProbeNode
        */
        var LightProbeNode = (function (_super) {
            __extends(LightProbeNode, _super);
            /**
            *
            * @param lightProbe
            */
            function LightProbeNode(lightProbe) {
                _super.call(this, lightProbe);

                this._lightProbe = lightProbe;
            }
            /**
            * @inheritDoc
            */
            LightProbeNode.prototype.acceptTraverser = function (traverser) {
                //do not run frustum checks on lights
                traverser.applyEntity(this._lightProbe);
            };

            /**
            *
            * @returns {boolean}
            */
            LightProbeNode.prototype.isCastingShadow = function () {
                return false;
            };
            return LightProbeNode;
        })(partition.EntityNode);
        partition.LightProbeNode = LightProbeNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.partition
    */
    (function (partition) {
        /**
        * @class away.partition.PointLightNode
        */
        var PointLightNode = (function (_super) {
            __extends(PointLightNode, _super);
            /**
            *
            * @param pointLight
            */
            function PointLightNode(pointLight) {
                _super.call(this, pointLight);

                this._pointLight = pointLight;
            }
            /**
            * @inheritDoc
            */
            PointLightNode.prototype.acceptTraverser = function (traverser) {
                //do not run frustum checks on lights
                traverser.applyEntity(this._pointLight);
            };

            /**
            *
            * @returns {boolean}
            */
            PointLightNode.prototype.isCastingShadow = function () {
                return false;
            };
            return PointLightNode;
        })(partition.EntityNode);
        partition.PointLightNode = PointLightNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.partition
    */
    (function (partition) {
        /**
        * SkyboxNode is a space partitioning leaf node that contains a Skybox object.
        *
        * @class away.partition.SkyboxNode
        */
        var SkyboxNode = (function (_super) {
            __extends(SkyboxNode, _super);
            /**
            * Creates a new SkyboxNode object.
            * @param skyBox The Skybox to be contained in the node.
            */
            function SkyboxNode(skyBox) {
                _super.call(this, skyBox);

                this._skyBox = skyBox;
            }
            /**
            *
            * @param planes
            * @param numPlanes
            * @returns {boolean}
            */
            SkyboxNode.prototype.isInFrustum = function (planes, numPlanes) {
                if (!this._skyBox._iIsVisible)
                    return false;

                //a skybox is always in view unless its visibility is set to false
                return true;
            };
            return SkyboxNode;
        })(partition.EntityNode);
        partition.SkyboxNode = SkyboxNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pick
    */
    (function (pick) {
        /**
        * An abstract base class for all picking collider classes. It should not be instantiated directly.
        *
        * @class away.pick.PickingColliderBase
        */
        var PickingColliderBase = (function () {
            function PickingColliderBase() {
            }
            PickingColliderBase.prototype._pPetCollisionNormal = function (indexData/*uint*/ , vertexData, triangleIndex) {
                var normal = new away.geom.Vector3D();
                var i0 = indexData[triangleIndex] * 3;
                var i1 = indexData[triangleIndex + 1] * 3;
                var i2 = indexData[triangleIndex + 2] * 3;
                var p0 = new away.geom.Vector3D(vertexData[i0], vertexData[i0 + 1], vertexData[i0 + 2]);
                var p1 = new away.geom.Vector3D(vertexData[i1], vertexData[i1 + 1], vertexData[i1 + 2]);
                var p2 = new away.geom.Vector3D(vertexData[i2], vertexData[i2 + 1], vertexData[i2 + 2]);
                var side0 = p1.subtract(p0);
                var side1 = p2.subtract(p0);
                normal = side0.crossProduct(side1);
                normal.normalize();
                return normal;
            };

            PickingColliderBase.prototype._pGetCollisionUV = function (indexData/*uint*/ , uvData, triangleIndex, v, w, u, uvOffset, uvStride) {
                var uv = new away.geom.Point();
                var uIndex = indexData[triangleIndex] * uvStride + uvOffset;
                var uv0 = new away.geom.Vector3D(uvData[uIndex], uvData[uIndex + 1]);
                uIndex = indexData[triangleIndex + 1] * uvStride + uvOffset;
                var uv1 = new away.geom.Vector3D(uvData[uIndex], uvData[uIndex + 1]);
                uIndex = indexData[triangleIndex + 2] * uvStride + uvOffset;
                var uv2 = new away.geom.Vector3D(uvData[uIndex], uvData[uIndex + 1]);
                uv.x = u * uv0.x + v * uv1.x + w * uv2.x;
                uv.y = u * uv0.y + v * uv1.y + w * uv2.y;
                return uv;
            };

            PickingColliderBase.prototype.testRenderableCollision = function (renderable, pickingCollisionVO, shortestCollisionDistance) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * @inheritDoc
            */
            PickingColliderBase.prototype.setLocalRay = function (localPosition, localDirection) {
                this.rayPosition = localPosition;
                this.rayDirection = localDirection;
            };
            return PickingColliderBase;
        })();
        pick.PickingColliderBase = PickingColliderBase;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pick
    */
    (function (pick) {
        /**
        * Pure JS picking collider for display objects. Used with the <code>RaycastPicker</code> picking object.
        *
        * @see away.base.DisplayObject#pickingCollider
        * @see away.pick.RaycastPicker
        *
        * @class away.pick.JSPickingCollider
        */
        var JSPickingCollider = (function (_super) {
            __extends(JSPickingCollider, _super);
            /**
            * Creates a new <code>JSPickingCollider</code> object.
            *
            * @param findClosestCollision Determines whether the picking collider searches for the closest collision along the ray. Defaults to false.
            */
            function JSPickingCollider(findClosestCollision) {
                if (typeof findClosestCollision === "undefined") { findClosestCollision = false; }
                _super.call(this);

                this._findClosestCollision = findClosestCollision;
            }
            /**
            * @inheritDoc
            */
            JSPickingCollider.prototype.testRenderableCollision = function (renderable, pickingCollisionVO, shortestCollisionDistance) {
                var subGeometry = renderable.subGeometry;

                var t;
                var i0, i1, i2;
                var rx, ry, rz;
                var nx, ny, nz;
                var cx, cy, cz;
                var coeff, u, v, w;
                var p0x, p0y, p0z;
                var p1x, p1y, p1z;
                var p2x, p2y, p2z;
                var s0x, s0y, s0z;
                var s1x, s1y, s1z;
                var nl, nDotV, D, disToPlane;
                var Q1Q2, Q1Q1, Q2Q2, RQ1, RQ2;
                var indexData = subGeometry.indexData;
                var vertexData = subGeometry.vertexData;
                var uvData = subGeometry.UVData;
                var collisionTriangleIndex = -1;
                var bothSides = (renderable.materialOwner.material).bothSides;

                var vertexStride = subGeometry.vertexStride;
                var vertexOffset = subGeometry.vertexOffset;
                var uvStride = subGeometry.UVStride;
                var uvOffset = subGeometry.UVOffset;
                var numIndices = indexData.length;

                for (var index = 0; index < numIndices; index += 3) {
                    // evaluate triangle indices
                    i0 = vertexOffset + indexData[index] * vertexStride;
                    i1 = vertexOffset + indexData[(index + 1)] * vertexStride;
                    i2 = vertexOffset + indexData[(index + 2)] * vertexStride;

                    // evaluate triangle vertices
                    p0x = vertexData[i0];
                    p0y = vertexData[(i0 + 1)];
                    p0z = vertexData[(i0 + 2)];
                    p1x = vertexData[i1];
                    p1y = vertexData[(i1 + 1)];
                    p1z = vertexData[(i1 + 2)];
                    p2x = vertexData[i2];
                    p2y = vertexData[(i2 + 1)];
                    p2z = vertexData[(i2 + 2)];

                    // evaluate sides and triangle normal
                    s0x = p1x - p0x;
                    s0y = p1y - p0y;
                    s0z = p1z - p0z;
                    s1x = p2x - p0x;
                    s1y = p2y - p0y;
                    s1z = p2z - p0z;
                    nx = s0y * s1z - s0z * s1y;
                    ny = s0z * s1x - s0x * s1z;
                    nz = s0x * s1y - s0y * s1x;
                    nl = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
                    nx *= nl;
                    ny *= nl;
                    nz *= nl;

                    // -- plane intersection test --
                    nDotV = nx * this.rayDirection.x + ny * +this.rayDirection.y + nz * this.rayDirection.z;
                    if ((!bothSides && nDotV < 0.0) || (bothSides && nDotV != 0.0)) {
                        // find collision t
                        D = -(nx * p0x + ny * p0y + nz * p0z);
                        disToPlane = -(nx * this.rayPosition.x + ny * this.rayPosition.y + nz * this.rayPosition.z + D);
                        t = disToPlane / nDotV;

                        // find collision point
                        cx = this.rayPosition.x + t * this.rayDirection.x;
                        cy = this.rayPosition.y + t * this.rayDirection.y;
                        cz = this.rayPosition.z + t * this.rayDirection.z;

                        // collision point inside triangle? ( using barycentric coordinates )
                        Q1Q2 = s0x * s1x + s0y * s1y + s0z * s1z;
                        Q1Q1 = s0x * s0x + s0y * s0y + s0z * s0z;
                        Q2Q2 = s1x * s1x + s1y * s1y + s1z * s1z;
                        rx = cx - p0x;
                        ry = cy - p0y;
                        rz = cz - p0z;
                        RQ1 = rx * s0x + ry * s0y + rz * s0z;
                        RQ2 = rx * s1x + ry * s1y + rz * s1z;
                        coeff = 1 / (Q1Q1 * Q2Q2 - Q1Q2 * Q1Q2);
                        v = coeff * (Q2Q2 * RQ1 - Q1Q2 * RQ2);
                        w = coeff * (-Q1Q2 * RQ1 + Q1Q1 * RQ2);
                        if (v < 0)
                            continue;
                        if (w < 0)
                            continue;
                        u = 1 - v - w;
                        if (!(u < 0) && t > 0 && t < shortestCollisionDistance) {
                            shortestCollisionDistance = t;
                            collisionTriangleIndex = index / 3;
                            pickingCollisionVO.rayEntryDistance = t;
                            pickingCollisionVO.localPosition = new away.geom.Vector3D(cx, cy, cz);
                            pickingCollisionVO.localNormal = new away.geom.Vector3D(nx, ny, nz);
                            pickingCollisionVO.uv = this._pGetCollisionUV(indexData, uvData, index, v, w, u, uvOffset, uvStride);
                            pickingCollisionVO.index = index;

                            if (!this._findClosestCollision)
                                return true;
                        }
                    }
                }

                if (collisionTriangleIndex >= 0)
                    return true;

                return false;
            };
            return JSPickingCollider;
        })(pick.PickingColliderBase);
        pick.JSPickingCollider = JSPickingCollider;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pick
    */
    (function (pick) {
        /**
        * Picks a 3d object from a view or scene by performing a separate render pass on the scene around the area being picked using key color values,
        * then reading back the color value of the pixel in the render representing the picking ray. Requires multiple passes and readbacks for retriving details
        * on an entity that has its shaderPickingDetails property set to true.
        *
        * A read-back operation from any GPU is not a very efficient process, and the amount of processing used can vary significantly between different hardware.
        *
        * @see away.entities.Entity#shaderPickingDetails
        *
        * @class away.pick.ShaderPicker
        */
        var ShaderPicker = (function () {
            /**
            * Creates a new <code>ShaderPicker</code> object.
            *
            * @param shaderPickingDetails Determines whether the picker includes a second pass to calculate extra
            * properties such as uv and normal coordinates.
            */
            function ShaderPicker(shaderPickingDetails) {
                if (typeof shaderPickingDetails === "undefined") { shaderPickingDetails = false; }
                this._onlyMouseEnabled = true;
                this._interactives = new Array();
                this._localHitPosition = new away.geom.Vector3D();
                this._hitUV = new away.geom.Point();
                this._localHitNormal = new away.geom.Vector3D();
                this._rayPos = new away.geom.Vector3D();
                this._rayDir = new away.geom.Vector3D();
                this._shaderPickingDetails = shaderPickingDetails;

                this._id = new Array(4);
                this._viewportData = new Array(4);
                this._boundOffsetScale = new Array(8);
                this._boundOffsetScale[3] = 0;
                this._boundOffsetScale[7] = 1;
            }
            Object.defineProperty(ShaderPicker.prototype, "onlyMouseEnabled", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._onlyMouseEnabled;
                },
                set: function (value) {
                    this._onlyMouseEnabled = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            // TODO implement dependency : EntityCollector
            // TODO: GLSL implementation / conversion
            ShaderPicker.prototype.getViewCollision = function (x, y, view) {
                away.Debug.throwPIR('ShaderPicker', 'getViewCollision', 'implement');

                return null;

                var collector = view.iEntityCollector;

                this._stageGL = (view.renderer).stageGL;

                if (!this._stageGL)
                    return null;

                this._context = this._stageGL.contextGL;

                this._viewportData[0] = view.width;
                this._viewportData[1] = view.height;
                this._viewportData[2] = -(this._projX = 2 * x / view.width - 1);
                this._viewportData[3] = this._projY = 2 * y / view.height - 1;

                // _potentialFound will be set to true if any object is actually rendered
                this._potentialFound = false;

                this.pDraw(collector, null);

                // clear buffers
                this._context.setVertexBufferAt(0, null);

                if (!this._context || !this._potentialFound) {
                    return null;
                }

                if (!this._bitmapData)
                    this._bitmapData = new away.base.BitmapData(1, 1, false, 0);

                this._context.drawToBitmapData(this._bitmapData);
                this._hitColor = this._bitmapData.getPixel(0, 0);

                if (!this._hitColor) {
                    this._context.present();
                    return null;
                }

                this._hitRenderable = this._interactives[this._hitColor - 1];
                this._hitEntity = this._hitRenderable.sourceEntity;

                if (this._onlyMouseEnabled && !this._hitEntity._iIsMouseEnabled())
                    return null;

                var _collisionVO = this._hitEntity._iPickingCollisionVO;
                if (this._shaderPickingDetails) {
                    this.getHitDetails(view.camera);
                    _collisionVO.localPosition = this._localHitPosition;
                    _collisionVO.localNormal = this._localHitNormal;
                    _collisionVO.uv = this._hitUV;
                    _collisionVO.index = this._faceIndex;
                    //_collisionVO.subGeometryIndex = this._subGeometryIndex;
                } else {
                    _collisionVO.localPosition = null;
                    _collisionVO.localNormal = null;
                    _collisionVO.uv = null;
                    _collisionVO.index = 0;
                    //_collisionVO.subGeometryIndex = 0;
                }

                return _collisionVO;
            };

            //*/
            /**
            * @inheritDoc
            */
            ShaderPicker.prototype.getSceneCollision = function (position, direction, scene) {
                return null;
            };

            /**
            * @inheritDoc
            */
            // TODO: GLSL implementation / conversion
            ShaderPicker.prototype.pDraw = function (entityCollector, target) {
                var camera = entityCollector.camera;

                this._context.clear(0, 0, 0, 1);
                this._stageGL.scissorRect = ShaderPicker.MOUSE_SCISSOR_RECT;

                this._interactives.length = this._interactiveId = 0;

                if (!this._objectProgram) {
                    this.initObjectProgram();
                }

                this._context.setBlendFactors(away.gl.ContextGLBlendFactor.ONE, away.gl.ContextGLBlendFactor.ZERO);
                this._context.setDepthTest(true, away.gl.ContextGLCompareMode.LESS);
                this._context.setProgram(this._objectProgram);
                this._context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.VERTEX, 4, this._viewportData, 1);
                this.drawRenderables(entityCollector.opaqueRenderableHead, camera);
                this.drawRenderables(entityCollector.blendedRenderableHead, camera);
            };

            /**
            * Draw a list of renderables.
            * @param renderables The renderables to draw.
            * @param camera The camera for which to render.
            */
            ShaderPicker.prototype.drawRenderables = function (renderable, camera) {
                away.Debug.throwPIR('ShaderPicker', 'drawRenderables', 'implement');

                var matrix = away.geom.Matrix3DUtils.CALCULATION_MATRIX;
                var viewProjection = camera.viewProjection;

                while (renderable) {
                    if (!renderable.sourceEntity.scene || !renderable.sourceEntity._iIsMouseEnabled()) {
                        renderable = renderable.next;
                        continue;
                    }

                    this._potentialFound = true;

                    this._context.setCulling((renderable.materialOwner.material).bothSides ? away.gl.ContextGLTriangleFace.NONE : away.gl.ContextGLTriangleFace.BACK);

                    this._interactives[this._interactiveId++] = renderable;

                    // color code so that reading from bitmapdata will contain the correct value
                    this._id[1] = (this._interactiveId >> 8) / 255;
                    this._id[2] = (this._interactiveId & 0xff) / 255;

                    matrix.copyFrom(renderable.sourceEntity.getRenderSceneTransform(camera));
                    matrix.append(viewProjection);
                    this._context.setProgramConstantsFromMatrix(away.gl.ContextGLProgramType.VERTEX, 0, matrix, true);
                    this._context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.FRAGMENT, 0, this._id, 1);
                    renderable.subGeometry.activateVertexBuffer(0, this._stageGL);
                    this._context.drawTriangles(renderable.subGeometry.getIndexBuffer(this._stageGL), 0, renderable.subGeometry.numTriangles);

                    renderable = renderable.next;
                }
            };

            ShaderPicker.prototype.updateRay = function (camera) {
                this._rayPos = camera.scenePosition;

                this._rayDir = camera.getRay(this._projX, this._projY, 1);
                this._rayDir.normalize();
            };

            /**
            * Creates the Program that color-codes objects.
            */
            ShaderPicker.prototype.initObjectProgram = function () {
                var vertexCode;
                var fragmentCode;

                this._objectProgram = this._context.createProgram();

                vertexCode = "m44 vt0, va0, vc0			\n" + "mul vt1.xy, vt0.w, vc4.zw	\n" + "add vt0.xy, vt0.xy, vt1.xy	\n" + "mul vt0.xy, vt0.xy, vc4.xy	\n" + "mov op, vt0	\n";
                fragmentCode = "mov oc, fc0";

                away.Debug.throwPIR('ShaderPicker', 'initTriangleProgram', 'Dependency: initObjectProgram');
                //_objectProgram.upload(new AGALMiniAssembler().assemble(ContextGLProgramType.VERTEX, vertexCode),new AGALMiniAssembler().assemble(ContextGLProgramType.FRAGMENT, fragmentCode));
            };

            /**
            * Creates the Program that renders positions.
            */
            ShaderPicker.prototype.initTriangleProgram = function () {
                var vertexCode;
                var fragmentCode;

                this._triangleProgram = this._context.createProgram();

                // todo: add animation code
                vertexCode = "add vt0, va0, vc5 			\n" + "mul vt0, vt0, vc6 			\n" + "mov v0, vt0				\n" + "m44 vt0, va0, vc0			\n" + "mul vt1.xy, vt0.w, vc4.zw	\n" + "add vt0.xy, vt0.xy, vt1.xy	\n" + "mul vt0.xy, vt0.xy, vc4.xy	\n" + "mov op, vt0	\n";
                fragmentCode = "mov oc, v0";

                //away.Debug.throwPIR( 'ShaderPicker' , 'initTriangleProgram' , 'Dependency: AGALMiniAssembler')
                var vertCompiler = new aglsl.AGLSLCompiler();
                var fragCompiler = new aglsl.AGLSLCompiler();

                var vertString = vertCompiler.compile(away.gl.ContextGLProgramType.VERTEX, vertexCode);
                var fragString = fragCompiler.compile(away.gl.ContextGLProgramType.FRAGMENT, fragmentCode);

                this._triangleProgram.upload(vertString, fragString);
                //this._triangleProgram.upload(new AGALMiniAssembler().assemble(ContextGLProgramType.VERTEX, vertexCode), new AGALMiniAssembler().assemble(ContextGLProgramType.FRAGMENT, fragmentCode));
            };

            /**
            * Gets more detailed information about the hir position, if required.
            * @param camera The camera used to view the hit object.
            */
            ShaderPicker.prototype.getHitDetails = function (camera) {
                this.getApproximatePosition(camera);
                this.getPreciseDetails(camera);
            };

            /**
            * Finds a first-guess approximate position about the hit position.
            *
            * @param camera The camera used to view the hit object.
            */
            ShaderPicker.prototype.getApproximatePosition = function (camera) {
                var bounds = this._hitRenderable.sourceEntity.bounds.aabb;
                var col;
                var scX, scY, scZ;
                var offsX, offsY, offsZ;
                var localViewProjection = away.geom.Matrix3DUtils.CALCULATION_MATRIX;

                localViewProjection.copyFrom(this._hitRenderable.sourceEntity.getRenderSceneTransform(camera));
                localViewProjection.append(camera.viewProjection);
                if (!this._triangleProgram) {
                    this.initTriangleProgram();
                }

                this._boundOffsetScale[4] = 1 / (scX = bounds.width);
                this._boundOffsetScale[5] = 1 / (scY = bounds.height);
                this._boundOffsetScale[6] = 1 / (scZ = bounds.depth);
                this._boundOffsetScale[0] = offsX = -bounds.x;
                this._boundOffsetScale[1] = offsY = -bounds.y;
                this._boundOffsetScale[2] = offsZ = -bounds.z;

                this._context.setProgram(this._triangleProgram);
                this._context.clear(0, 0, 0, 0, 1, 0, away.gl.ContextGLClearMask.DEPTH);
                this._context.setScissorRectangle(ShaderPicker.MOUSE_SCISSOR_RECT);
                this._context.setProgramConstantsFromMatrix(away.gl.ContextGLProgramType.VERTEX, 0, localViewProjection, true);
                this._context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.VERTEX, 5, this._boundOffsetScale, 2);
                this._hitRenderable.subGeometry.activateVertexBuffer(0, this._stageGL);
                this._context.drawTriangles(this._hitRenderable.subGeometry.getIndexBuffer(this._stageGL), 0, this._hitRenderable.subGeometry.numTriangles);
                this._context.drawToBitmapData(this._bitmapData);

                col = this._bitmapData.getPixel(0, 0);

                this._localHitPosition.x = ((col >> 16) & 0xff) * scX / 255 - offsX;
                this._localHitPosition.y = ((col >> 8) & 0xff) * scY / 255 - offsY;
                this._localHitPosition.z = (col & 0xff) * scZ / 255 - offsZ;
            };

            /**
            * Use the approximate position info to find the face under the mouse position from which we can derive the precise
            * ray-face intersection point, then use barycentric coordinates to figure out the uv coordinates, etc.
            * @param camera The camera used to view the hit object.
            */
            ShaderPicker.prototype.getPreciseDetails = function (camera) {
                var subGeom = this._hitRenderable.subGeometry;
                var indices = subGeom.indexData;
                var vertices = subGeom.vertexData;
                var len = indices.length;
                var x1, y1, z1;
                var x2, y2, z2;
                var x3, y3, z3;
                var i = 0, j = 1, k = 2;
                var t1, t2, t3;
                var v0x, v0y, v0z;
                var v1x, v1y, v1z;
                var v2x, v2y, v2z;
                var dot00, dot01, dot02, dot11, dot12;
                var s, t, invDenom;
                var uvs = subGeom.UVData;
                var normals = subGeom.faceNormals;
                var x = this._localHitPosition.x, y = this._localHitPosition.y, z = this._localHitPosition.z;
                var u, v;
                var ui1, ui2, ui3;
                var s0x, s0y, s0z;
                var s1x, s1y, s1z;
                var nl;
                var stride = subGeom.vertexStride;
                var vertexOffset = subGeom.vertexOffset;

                this.updateRay(camera);

                while (i < len) {
                    t1 = vertexOffset + indices[i] * stride;
                    t2 = vertexOffset + indices[j] * stride;
                    t3 = vertexOffset + indices[k] * stride;
                    x1 = vertices[t1];
                    y1 = vertices[t1 + 1];
                    z1 = vertices[t1 + 2];
                    x2 = vertices[t2];
                    y2 = vertices[t2 + 1];
                    z2 = vertices[t2 + 2];
                    x3 = vertices[t3];
                    y3 = vertices[t3 + 1];
                    z3 = vertices[t3 + 2];

                    if (!((x < x1 && x < x2 && x < x3) || (y < y1 && y < y2 && y < y3) || (z < z1 && z < z2 && z < z3) || (x > x1 && x > x2 && x > x3) || (y > y1 && y > y2 && y > y3) || (z > z1 && z > z2 && z > z3))) {
                        // calculate barycentric coords for approximated position
                        v0x = x3 - x1;
                        v0y = y3 - y1;
                        v0z = z3 - z1;
                        v1x = x2 - x1;
                        v1y = y2 - y1;
                        v1z = z2 - z1;
                        v2x = x - x1;
                        v2y = y - y1;
                        v2z = z - z1;
                        dot00 = v0x * v0x + v0y * v0y + v0z * v0z;
                        dot01 = v0x * v1x + v0y * v1y + v0z * v1z;
                        dot02 = v0x * v2x + v0y * v2y + v0z * v2z;
                        dot11 = v1x * v1x + v1y * v1y + v1z * v1z;
                        dot12 = v1x * v2x + v1y * v2y + v1z * v2z;
                        invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
                        s = (dot11 * dot02 - dot01 * dot12) * invDenom;
                        t = (dot00 * dot12 - dot01 * dot02) * invDenom;

                        if (s >= 0 && t >= 0 && (s + t) <= 1) {
                            // this is def the triangle, now calculate precise coords
                            this.getPrecisePosition(this._hitRenderable.sourceEntity.inverseSceneTransform, normals[i], normals[i + 1], normals[i + 2], x1, y1, z1);

                            v2x = this._localHitPosition.x - x1;
                            v2y = this._localHitPosition.y - y1;
                            v2z = this._localHitPosition.z - z1;

                            s0x = x2 - x1;
                            s0y = y2 - y1;
                            s0z = z2 - z1;
                            s1x = x3 - x1;
                            s1y = y3 - y1;
                            s1z = z3 - z1;
                            this._localHitNormal.x = s0y * s1z - s0z * s1y;
                            this._localHitNormal.y = s0z * s1x - s0x * s1z;
                            this._localHitNormal.z = s0x * s1y - s0y * s1x;
                            nl = 1 / Math.sqrt(this._localHitNormal.x * this._localHitNormal.x + this._localHitNormal.y * this._localHitNormal.y + this._localHitNormal.z * this._localHitNormal.z);
                            this._localHitNormal.x *= nl;
                            this._localHitNormal.y *= nl;
                            this._localHitNormal.z *= nl;

                            dot02 = v0x * v2x + v0y * v2y + v0z * v2z;
                            dot12 = v1x * v2x + v1y * v2y + v1z * v2z;
                            s = (dot11 * dot02 - dot01 * dot12) * invDenom;
                            t = (dot00 * dot12 - dot01 * dot02) * invDenom;

                            ui1 = indices[i] << 1;
                            ui2 = indices[j] << 1;
                            ui3 = indices[k] << 1;

                            u = uvs[ui1];
                            v = uvs[ui1 + 1];
                            this._hitUV.x = u + t * (uvs[ui2] - u) + s * (uvs[ui3] - u);
                            this._hitUV.y = v + t * (uvs[ui2 + 1] - v) + s * (uvs[ui3 + 1] - v);

                            this._faceIndex = i;
                            this._subGeometryIndex = away.utils.GeometryUtils.getMeshSubGeometryIndex(subGeom);

                            return;
                        }
                    }

                    i += 3;
                    j += 3;
                    k += 3;
                }
            };

            /**
            * Finds the precise hit position by unprojecting the screen coordinate back unto the hit face's plane and
            * calculating the intersection point.
            * @param camera The camera used to render the object.
            * @param invSceneTransform The inverse scene transformation of the hit object.
            * @param nx The x-coordinate of the face's plane normal.
            * @param ny The y-coordinate of the face plane normal.
            * @param nz The z-coordinate of the face plane normal.
            * @param px The x-coordinate of a point on the face's plane (ie a face vertex)
            * @param py The y-coordinate of a point on the face's plane (ie a face vertex)
            * @param pz The z-coordinate of a point on the face's plane (ie a face vertex)
            */
            ShaderPicker.prototype.getPrecisePosition = function (invSceneTransform, nx, ny, nz, px, py, pz) {
                // calculate screen ray and find exact intersection position with triangle
                var rx, ry, rz;
                var ox, oy, oz;
                var t;
                var raw = away.geom.Matrix3DUtils.RAW_DATA_CONTAINER;
                var cx = this._rayPos.x, cy = this._rayPos.y, cz = this._rayPos.z;

                // unprojected projection point, gives ray dir in cam space
                ox = this._rayDir.x;
                oy = this._rayDir.y;
                oz = this._rayDir.z;

                // transform ray dir and origin (cam pos) to object space
                //invSceneTransform.copyRawDataTo( raw  );
                invSceneTransform.copyRawDataTo(raw);
                rx = raw[0] * ox + raw[4] * oy + raw[8] * oz;
                ry = raw[1] * ox + raw[5] * oy + raw[9] * oz;
                rz = raw[2] * ox + raw[6] * oy + raw[10] * oz;

                ox = raw[0] * cx + raw[4] * cy + raw[8] * cz + raw[12];
                oy = raw[1] * cx + raw[5] * cy + raw[9] * cz + raw[13];
                oz = raw[2] * cx + raw[6] * cy + raw[10] * cz + raw[14];

                t = ((px - ox) * nx + (py - oy) * ny + (pz - oz) * nz) / (rx * nx + ry * ny + rz * nz);

                this._localHitPosition.x = ox + rx * t;
                this._localHitPosition.y = oy + ry * t;
                this._localHitPosition.z = oz + rz * t;
            };

            ShaderPicker.prototype.dispose = function () {
                this._bitmapData.dispose();
                if (this._triangleProgram)
                    this._triangleProgram.dispose();

                if (this._objectProgram)
                    this._objectProgram.dispose();

                this._triangleProgram = null;
                this._objectProgram = null;
                this._bitmapData = null;
                this._hitRenderable = null;
                this._hitEntity = null;
            };
            ShaderPicker.MOUSE_SCISSOR_RECT = new away.geom.Rectangle(0, 0, 1, 1);
            return ShaderPicker;
        })();
        pick.ShaderPicker = ShaderPicker;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pick
    */
    (function (pick) {
        /**
        * Picks a 3d object from a view or scene by 3D raycast calculations.
        * Performs an initial coarse boundary calculation to return a subset of entities whose bounding volumes intersect with the specified ray,
        * then triggers an optional picking collider on individual entity objects to further determine the precise values of the picking ray collision.
        *
        * @class away.pick.RaycastPicker
        */
        var RaycastPicker = (function () {
            /**
            * Creates a new <code>RaycastPicker</code> object.
            *
            * @param findClosestCollision Determines whether the picker searches for the closest bounds collision along the ray,
            * or simply returns the first collision encountered Defaults to false.
            */
            function RaycastPicker(findClosestCollision) {
                this._ignoredEntities = [];
                this._onlyMouseEnabled = true;
                this._numEntities = 0;
                this._raycastCollector = new away.traverse.RaycastCollector();

                this._findClosestCollision = findClosestCollision;
                this._entities = new Array();
            }
            Object.defineProperty(RaycastPicker.prototype, "onlyMouseEnabled", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._onlyMouseEnabled;
                },
                set: function (value) {
                    this._onlyMouseEnabled = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            RaycastPicker.prototype.getViewCollision = function (x, y, view) {
                //cast ray through the collection of entities on the view
                var collector = view.iEntityCollector;

                if (collector.numInteractiveEntities == 0)
                    return null;

                //update ray
                var rayPosition = view.unproject(x, y, 0);
                var rayDirection = view.unproject(x, y, 1);
                rayDirection = rayDirection.subtract(rayPosition);

                // Perform ray-bounds collision checks.
                this._numEntities = 0;
                var node = collector.entityHead;
                var entity;
                while (node) {
                    entity = node.entity;

                    if (this.isIgnored(entity)) {
                        node = node.next;
                        continue;
                    }

                    if (entity._iIsVisible() && entity.isIntersectingRay(rayPosition, rayDirection))
                        this._entities[this._numEntities++] = entity;

                    node = node.next;
                }

                if (!this._numEntities)
                    return null;

                return this.getPickingCollisionVO(collector);
            };

            //*/
            /**
            * @inheritDoc
            */
            //* TODO Implement Dependency: EntityListItem, EntityCollector, RaycastCollector
            RaycastPicker.prototype.getSceneCollision = function (position, direction, scene) {
                //clear collector
                this._raycastCollector.clear();

                //setup ray vectors
                this._raycastCollector.rayPosition = position;
                this._raycastCollector.rayDirection = direction;

                // collect entities to test
                scene.traversePartitions(this._raycastCollector);

                this._numEntities = 0;
                var node = this._raycastCollector.entityHead;
                var entity;

                while (node) {
                    entity = node.entity;

                    if (this.isIgnored(entity)) {
                        node = node.next;
                        continue;
                    }

                    this._entities[this._numEntities++] = entity;

                    node = node.next;
                }

                if (!this._numEntities)
                    return null;

                return this.getPickingCollisionVO(this._raycastCollector);
            };

            //		public getEntityCollision(position:away.geom.Vector3D, direction:away.geom.Vector3D, entities:Array<away.entities.IEntity>):PickingCollisionVO
            //		{
            //			this._numEntities = 0;
            //
            //			var entity:away.entities.IEntity;
            //			var l:number = entities.length;
            //
            //			for (var c:number = 0; c < l; c++) {
            //				entity = entities[c];
            //
            //				if (entity.isIntersectingRay(position, direction))
            //					this._entities[this._numEntities++] = entity;
            //			}
            //
            //			return this.getPickingCollisionVO(this._raycastCollector);
            //		}
            RaycastPicker.prototype.setIgnoreList = function (entities) {
                this._ignoredEntities = entities;
            };

            RaycastPicker.prototype.isIgnored = function (entity) {
                if (this._onlyMouseEnabled && entity._iIsMouseEnabled)
                    return true;

                var ignoredEntity;

                var l = this._ignoredEntities.length;

                for (var c = 0; c < l; c++) {
                    ignoredEntity = this._ignoredEntities[c];

                    if (ignoredEntity == entity)
                        return true;
                }

                return false;
            };

            RaycastPicker.prototype.sortOnNearT = function (entity1, entity2) {
                return entity1._iPickingCollisionVO.rayEntryDistance > entity2._iPickingCollisionVO.rayEntryDistance ? 1 : -1;
            };

            RaycastPicker.prototype.getPickingCollisionVO = function (collector) {
                // trim before sorting
                this._entities.length = this._numEntities;

                // Sort entities from closest to furthest.
                this._entities = this._entities.sort(this.sortOnNearT);

                // ---------------------------------------------------------------------
                // Evaluate triangle collisions when needed.
                // Replaces collision data provided by bounds collider with more precise data.
                // ---------------------------------------------------------------------
                var shortestCollisionDistance = Number.MAX_VALUE;
                var bestCollisionVO;
                var pickingCollisionVO;
                var entity;
                var i;

                for (i = 0; i < this._numEntities; ++i) {
                    entity = this._entities[i];
                    pickingCollisionVO = entity._iPickingCollisionVO;
                    if (entity.pickingCollider) {
                        if ((bestCollisionVO == null || pickingCollisionVO.rayEntryDistance < bestCollisionVO.rayEntryDistance) && collector._iCollidesBefore(entity, shortestCollisionDistance, this._findClosestCollision)) {
                            shortestCollisionDistance = pickingCollisionVO.rayEntryDistance;
                            bestCollisionVO = pickingCollisionVO;
                            if (!this._findClosestCollision) {
                                this.updateLocalPosition(pickingCollisionVO);
                                return pickingCollisionVO;
                            }
                        }
                    } else if (bestCollisionVO == null || pickingCollisionVO.rayEntryDistance < bestCollisionVO.rayEntryDistance) {
                        if (!pickingCollisionVO.rayOriginIsInsideBounds) {
                            this.updateLocalPosition(pickingCollisionVO);
                            return pickingCollisionVO;
                        }
                    }
                }

                return bestCollisionVO;
            };

            RaycastPicker.prototype.updateLocalPosition = function (pickingCollisionVO) {
                var collisionPos = (pickingCollisionVO.localPosition == null) ? new away.geom.Vector3D() : pickingCollisionVO.localPosition;

                //var collisionPos:away.geom.Vector3D = pickingCollisionVO.localPosition ||= new away.geom.Vector3D();
                var rayDir = pickingCollisionVO.localRayDirection;
                var rayPos = pickingCollisionVO.localRayPosition;
                var t = pickingCollisionVO.rayEntryDistance;
                collisionPos.x = rayPos.x + t * rayDir.x;
                collisionPos.y = rayPos.y + t * rayDir.y;
                collisionPos.z = rayPos.z + t * rayDir.z;
            };

            RaycastPicker.prototype.dispose = function () {
            };
            return RaycastPicker;
        })();
        pick.RaycastPicker = RaycastPicker;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pick
    */
    (function (pick) {
        /**
        * Options for the different 3D object picking approaches available in Away3D. Can be used for automatic mouse picking on the view.
        *
        * @see away3d.containers.View#mousePicker
        *
        * @class away.pick.PickingType
        */
        var PickingType = (function () {
            function PickingType() {
            }
            PickingType.SHADER = new pick.ShaderPicker();

            PickingType.RAYCAST_FIRST_ENCOUNTERED = new pick.RaycastPicker(false);

            PickingType.RAYCAST_BEST_HIT = new pick.RaycastPicker(true);
            return PickingType;
        })();
        pick.PickingType = PickingType;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.pick
    */
    (function (pick) {
        /**
        * Options for setting a picking collider for entity objects. Used with the <code>RaycastPicker</code> picking object.
        *
        * @see away.entities.Entity#pickingCollider
        * @see away.pick.RaycastPicker
        *
        * @class away.pick.PickingColliderType
        */
        var PickingColliderType = (function () {
            function PickingColliderType() {
            }
            PickingColliderType.BOUNDS_ONLY = null;

            PickingColliderType.AS3_FIRST_ENCOUNTERED = new pick.JSPickingCollider(false);

            PickingColliderType.AS3_BEST_HIT = new pick.JSPickingCollider(true);
            return PickingColliderType;
        })();
        pick.PickingColliderType = PickingColliderType;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.render
    */
    (function (render) {
        /**
        * RendererBase forms an abstract base class for classes that are used in the rendering pipeline to render the
        * contents of a partition
        *
        * @class away.render.RendererBase
        */
        var RendererBase = (function (_super) {
            __extends(RendererBase, _super);
            /**
            * Creates a new RendererBase object.
            */
            function RendererBase(renderToTexture) {
                if (typeof renderToTexture === "undefined") { renderToTexture = false; }
                _super.call(this);
                this._pBackBufferInvalid = true;
                this._depthPrepass = false;
                this._backgroundR = 0;
                this._backgroundG = 0;
                this._backgroundB = 0;
                this._backgroundAlpha = 1;
                this._shareContext = false;
                this.textureRatioX = 1;
                this.textureRatioY = 1;
                this._pRttViewProjectionMatrix = new away.geom.Matrix3D();

                this._renderToTexture = renderToTexture;

                this._onContextUpdateDelegate = away.utils.Delegate.create(this, this.onContextUpdate);
            }
            RendererBase.prototype._iCreateEntityCollector = function () {
                return new away.traverse.EntityCollector();
            };

            Object.defineProperty(RendererBase.prototype, "iRenderToTexture", {
                get: function () {
                    return this._renderToTexture;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RendererBase.prototype, "_iBackgroundR", {
                get: /**
                * The background color's red component, used when clearing.
                *
                * @private
                */
                function () {
                    return this._backgroundR;
                },
                set: function (value) {
                    if (this._backgroundR == value)
                        return;

                    this._backgroundR = value;

                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "_iBackgroundG", {
                get: /**
                * The background color's green component, used when clearing.
                *
                * @private
                */
                function () {
                    return this._backgroundG;
                },
                set: function (value) {
                    if (this._backgroundG == value)
                        return;

                    this._backgroundG = value;

                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "_iBackgroundB", {
                get: /**
                * The background color's blue component, used when clearing.
                *
                * @private
                */
                function () {
                    return this._backgroundB;
                },
                set: function (value) {
                    if (this._backgroundB == value)
                        return;

                    this._backgroundB = value;

                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "stageGL", {
                get: /**
                * The StageGL that will provide the ContextGL used for rendering.
                */
                function () {
                    return this._pStageGL;
                },
                set: function (value) {
                    if (value == this._pStageGL)
                        return;

                    this.iSetStageGL(value);
                },
                enumerable: true,
                configurable: true
            });


            RendererBase.prototype.iSetStageGL = function (value) {
                if (this._pStageGL) {
                    this._pStageGL.removeEventListener(away.events.StageGLEvent.CONTEXTGL_CREATED, this._onContextUpdateDelegate);
                    this._pStageGL.removeEventListener(away.events.StageGLEvent.CONTEXTGL_RECREATED, this._onContextUpdateDelegate);
                }

                if (!value) {
                    this._pStageGL = null;
                    this._pContext = null;
                } else {
                    this._pStageGL = value;
                    this._pStageGL.addEventListener(away.events.StageGLEvent.CONTEXTGL_CREATED, this._onContextUpdateDelegate);
                    this._pStageGL.addEventListener(away.events.StageGLEvent.CONTEXTGL_RECREATED, this._onContextUpdateDelegate);

                    if (this._pStageGL.contextGL)
                        this._pContext = this._pStageGL.contextGL;
                }

                this._pBackBufferInvalid = true;

                this.updateGlobalPos();
            };

            Object.defineProperty(RendererBase.prototype, "shareContext", {
                get: /**
                * Defers control of ContextGL clear() and present() calls to StageGL, enabling multiple StageGL frameworks
                * to share the same ContextGL object.
                */
                function () {
                    return this._shareContext;
                },
                set: function (value) {
                    if (this._shareContext == value)
                        return;

                    this._shareContext = value;

                    this.updateGlobalPos();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Disposes the resources used by the RendererBase.
            */
            RendererBase.prototype.dispose = function () {
                this._pStageGL.removeEventListener(away.events.StageGLEvent.CONTEXTGL_CREATED, this._onContextUpdateDelegate);
                this._pStageGL.removeEventListener(away.events.StageGLEvent.CONTEXTGL_RECREATED, this._onContextUpdateDelegate);

                this._pStageGL = null;
                /*
                if (_backgroundImageRenderer) {
                _backgroundImageRenderer.dispose();
                _backgroundImageRenderer = null;
                }
                */
            };

            RendererBase.prototype.render = function (entityCollector) {
            };

            /**
            * Renders the potentially visible geometry to the back buffer or texture.
            * @param entityCollector The EntityCollector object containing the potentially visible geometry.
            * @param target An option target texture to render to.
            * @param surfaceSelector The index of a CubeTexture's face to render to.
            * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
            */
            RendererBase.prototype._iRender = function (entityCollector, target, scissorRect, surfaceSelector) {
                if (typeof target === "undefined") { target = null; }
                if (typeof scissorRect === "undefined") { scissorRect = null; }
                if (typeof surfaceSelector === "undefined") { surfaceSelector = 0; }
                if (!this._pStageGL || !this._pContext || !entityCollector.entityHead)
                    return;

                this._pRttViewProjectionMatrix.copyFrom(entityCollector.camera.viewProjection);
                this._pRttViewProjectionMatrix.appendScale(this.textureRatioX, this.textureRatioY, 1);

                this.pExecuteRender(entityCollector, target, scissorRect, surfaceSelector);

                if (target)
                    (target).generateMipmaps();

                for (var i = 0; i < 8; ++i) {
                    this._pContext.setVertexBufferAt(i, null);
                    this._pContext.setTextureAt(i, null);
                }
            };

            /**
            * Renders the potentially visible geometry to the back buffer or texture. Only executed if everything is set up.
            * @param entityCollector The EntityCollector object containing the potentially visible geometry.
            * @param target An option target texture to render to.
            * @param surfaceSelector The index of a CubeTexture's face to render to.
            * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
            */
            RendererBase.prototype.pExecuteRender = function (entityCollector, target, scissorRect, surfaceSelector) {
                if (typeof target === "undefined") { target = null; }
                if (typeof scissorRect === "undefined") { scissorRect = null; }
                if (typeof surfaceSelector === "undefined") { surfaceSelector = 0; }
                this._pRenderTarget = target;
                this._pRenderTargetSurface = surfaceSelector;

                entityCollector.sortRenderables();

                if (this._renderToTexture)
                    this.pExecuteRenderToTexturePass(entityCollector);

                this._pStageGL.setRenderTarget(target, true, surfaceSelector);

                if ((target || !this._shareContext) && !this._depthPrepass)
                    this._pContext.clear(this._backgroundR, this._backgroundG, this._backgroundB, this._backgroundAlpha, 1, 0);

                this._pContext.setDepthTest(false, away.gl.ContextGLCompareMode.ALWAYS);

                this._pStageGL.scissorRect = scissorRect;

                /*
                if (_backgroundImageRenderer)
                _backgroundImageRenderer.render();
                */
                this.pDraw(entityCollector, target);

                if (!this._shareContext) {
                    if (this._snapshotRequired && this._snapshotBitmapData) {
                        this._pContext.drawToBitmapData(this._snapshotBitmapData);
                        this._snapshotRequired = false;
                    }
                }

                this._pStageGL.scissorRect = null;
            };

            /*
            * Will draw the renderer's output on next render to the provided bitmap data.
            * */
            RendererBase.prototype.queueSnapshot = function (bmd) {
                this._snapshotRequired = true;
                this._snapshotBitmapData = bmd;
            };

            RendererBase.prototype.pExecuteRenderToTexturePass = function (entityCollector) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Performs the actual drawing of geometry to the target.
            * @param entityCollector The EntityCollector object containing the potentially visible geometry.
            */
            RendererBase.prototype.pDraw = function (entityCollector, target) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Assign the context once retrieved
            */
            RendererBase.prototype.onContextUpdate = function (event) {
                this._pContext = this._pStageGL.contextGL;
            };

            Object.defineProperty(RendererBase.prototype, "_iBackgroundAlpha", {
                get: function () {
                    return this._backgroundAlpha;
                },
                set: function (value) {
                    if (this._backgroundAlpha == value)
                        return;

                    this._backgroundAlpha = value;

                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            /*
            public get iBackground():away.textures.Texture2DBase
            {
            return this._background;
            }
            */
            /*
            public set iBackground(value:away.textures.Texture2DBase)
            {
            if (this._backgroundImageRenderer && !value) {
            this._backgroundImageRenderer.dispose();
            this._backgroundImageRenderer = null;
            }
            
            if (!this._backgroundImageRenderer && value)
            {
            
            this._backgroundImageRenderer = new BackgroundImageRenderer(this._pStageGL);
            
            }
            
            
            this._background = value;
            
            if (this._backgroundImageRenderer)
            this._backgroundImageRenderer.texture = value;
            }
            */
            /*
            public get backgroundImageRenderer():BackgroundImageRenderer
            {
            return _backgroundImageRenderer;
            }
            */
            /**
            *
            */
            RendererBase.prototype.updateGlobalPos = function () {
            };
            return RendererBase;
        })(away.events.EventDispatcher);
        render.RendererBase = RendererBase;
    })(away.render || (away.render = {}));
    var render = away.render;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.render
    */
    (function (render) {
        /**
        * The DepthRenderer class renders 32-bit depth information encoded as RGBA
        *
        * @class away.render.DepthRenderer
        */
        var DepthRenderer = (function (_super) {
            __extends(DepthRenderer, _super);
            /**
            * Creates a new DepthRenderer object.
            * @param renderBlended Indicates whether semi-transparent objects should be rendered.
            * @param distanceBased Indicates whether the written depth value is distance-based or projected depth-based
            */
            function DepthRenderer(renderBlended, distanceBased) {
                if (typeof renderBlended === "undefined") { renderBlended = false; }
                if (typeof distanceBased === "undefined") { distanceBased = false; }
                _super.call(this);

                this._renderBlended = renderBlended;
                this._distanceBased = distanceBased;
                this._iBackgroundR = 1;
                this._iBackgroundG = 1;
                this._iBackgroundB = 1;
            }
            Object.defineProperty(DepthRenderer.prototype, "disableColor", {
                get: function () {
                    return this._disableColor;
                },
                set: function (value) {
                    this._disableColor = value;
                },
                enumerable: true,
                configurable: true
            });


            DepthRenderer.prototype.iRenderCascades = function (entityCollector, target, numCascades, scissorRects, cameras) {
                this._pRenderTarget = target;
                this._pRenderTargetSurface = 0;

                entityCollector.sortRenderables();

                this._pStageGL.setRenderTarget(target, true, 0);
                this._pContext.clear(1, 1, 1, 1, 1, 0);

                this._pContext.setBlendFactors(away.gl.ContextGLBlendFactor.ONE, away.gl.ContextGLBlendFactor.ZERO);
                this._pContext.setDepthTest(true, away.gl.ContextGLCompareMode.LESS);

                var head = entityCollector.opaqueRenderableHead;

                var first = true;

                for (var i = numCascades - 1; i >= 0; --i) {
                    this._pStageGL.scissorRect = scissorRects[i];
                    this.drawCascadeRenderables(head, cameras[i], first ? null : cameras[i].frustumPlanes);
                    first = false;
                }

                if (this._activeMaterial)
                    this._activeMaterial.iDeactivateForDepth(this._pStageGL);

                this._activeMaterial = null;

                //line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
                this._pContext.setDepthTest(false, away.gl.ContextGLCompareMode.LESS_EQUAL);

                this._pStageGL.scissorRect = null;
            };

            DepthRenderer.prototype.drawCascadeRenderables = function (renderable, camera, cullPlanes) {
                var material;

                while (renderable) {
                    if (renderable.cascaded) {
                        renderable = renderable.next;
                        continue;
                    }

                    var entity = renderable.sourceEntity;

                    if (!cullPlanes || entity.worldBounds.isInFrustum(cullPlanes, 4)) {
                        material = renderable.materialOwner.material;

                        if (this._activeMaterial != material) {
                            if (this._activeMaterial)
                                this._activeMaterial.iDeactivateForDepth(this._pStageGL);

                            this._activeMaterial = material;
                            this._activeMaterial.iActivateForDepth(this._pStageGL, camera, false);
                        }

                        this._activeMaterial.iRenderDepth(renderable, this._pStageGL, camera, camera.viewProjection);
                    } else {
                        renderable.cascaded = true;
                    }

                    renderable = renderable.next;
                }
            };

            /**
            * @inheritDoc
            */
            DepthRenderer.prototype.pDraw = function (entityCollector, target) {
                this._pContext.setBlendFactors(away.gl.ContextGLBlendFactor.ONE, away.gl.ContextGLBlendFactor.ZERO);

                this._pContext.setDepthTest(true, away.gl.ContextGLCompareMode.LESS);

                this.drawRenderables(entityCollector.opaqueRenderableHead, entityCollector);

                if (this._disableColor)
                    this._pContext.setColorMask(false, false, false, false);

                if (this._renderBlended)
                    this.drawRenderables(entityCollector.blendedRenderableHead, entityCollector);

                if (this._activeMaterial)
                    this._activeMaterial.iDeactivateForDepth(this._pStageGL);

                if (this._disableColor)
                    this._pContext.setColorMask(true, true, true, true);

                this._activeMaterial = null;
            };

            /**
            * Draw a list of renderables.
            * @param renderables The renderables to draw.
            * @param entityCollector The EntityCollector containing all potentially visible information.
            */
            DepthRenderer.prototype.drawRenderables = function (renderable, entityCollector) {
                var camera = entityCollector.camera;
                var renderable2;

                while (renderable) {
                    this._activeMaterial = renderable.materialOwner.material;

                    if (this._disableColor && this._activeMaterial.iHasDepthAlphaThreshold()) {
                        renderable2 = renderable;

                        do {
                            renderable2 = renderable2.next;
                        } while(renderable2 && renderable2.materialOwner.material == this._activeMaterial);
                    } else {
                        this._activeMaterial.iActivateForDepth(this._pStageGL, camera, this._distanceBased);
                        renderable2 = renderable;
                        do {
                            this._activeMaterial.iRenderDepth(renderable2, this._pStageGL, camera, this._pRttViewProjectionMatrix);
                            renderable2 = renderable2.next;
                        } while(renderable2 && renderable2.materialOwner.material == this._activeMaterial);

                        this._activeMaterial.iDeactivateForDepth(this._pStageGL);
                    }

                    renderable = renderable2;
                }
            };
            return DepthRenderer;
        })(render.RendererBase);
        render.DepthRenderer = DepthRenderer;
    })(away.render || (away.render = {}));
    var render = away.render;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.render
    */
    (function (render) {
        /**
        * The DefaultRenderer class provides the default rendering method. It renders the scene graph objects using the
        * materials assigned to them.
        *
        * @class away.render.DefaultRenderer
        */
        var DefaultRenderer = (function (_super) {
            __extends(DefaultRenderer, _super);
            /**
            * Creates a new DefaultRenderer object.
            *
            * @param antiAlias The amount of anti-aliasing to use.
            * @param renderMode The render mode to use.
            */
            function DefaultRenderer(forceSoftware, profile) {
                if (typeof forceSoftware === "undefined") { forceSoftware = false; }
                if (typeof profile === "undefined") { profile = "baseline"; }
                _super.call(this);
                this._skyboxProjection = new away.geom.Matrix3D();
                this._depthTextureInvalid = true;
                this._viewPort = new away.geom.Rectangle();
                this._localPos = new away.geom.Point();
                this._globalPos = new away.geom.Point();
                this._pScissorRect = new away.geom.Rectangle();

                this._onViewportUpdatedDelegate = away.utils.Delegate.create(this, this.onViewportUpdated);

                this._pDepthRenderer = new render.DepthRenderer();
                this._pDistanceRenderer = new render.DepthRenderer(false, true);

                if (this._pStageGL == null)
                    this.stageGL = away.managers.StageGLManager.getInstance().getFreeStageGL(this._forceSoftware, this._profile);

                this._forceSoftware = forceSoftware;
                this._profile = profile;

                this._pRttBufferManager = away.managers.RTTBufferManager.getInstance(this._pStageGL);

                if (this._width == 0)
                    this.width = window.innerWidth;
else
                    this._pRttBufferManager.viewWidth = this._width;

                if (this._height == 0)
                    this.height = window.innerHeight;
else
                    this._pRttBufferManager.viewHeight = this._height;
            }
            Object.defineProperty(DefaultRenderer.prototype, "antiAlias", {
                get: function () {
                    return this._antiAlias;
                },
                set: function (value) {
                    if (this._antiAlias == value)
                        return;

                    this._antiAlias = value;

                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DefaultRenderer.prototype, "depthPrepass", {
                get: /**
                *
                */
                function () {
                    return this._depthPrepass;
                },
                set: function (value) {
                    this._depthPrepass = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DefaultRenderer.prototype, "filters3d", {
                get: /**
                *
                * @returns {*}
                */
                function () {
                    return this._pFilter3DRenderer ? this._pFilter3DRenderer.filters : null;
                },
                set: function (value) {
                    if (value && value.length == 0)
                        value = null;

                    if (this._pFilter3DRenderer && !value) {
                        this._pFilter3DRenderer.dispose();
                        this._pFilter3DRenderer = null;
                    } else if (!this._pFilter3DRenderer && value) {
                        this._pFilter3DRenderer = new render.Filter3DRenderer(this._pStageGL);
                        this._pFilter3DRenderer.filters = value;
                    }

                    if (this._pFilter3DRenderer) {
                        this._pFilter3DRenderer.filters = value;
                        this._pRequireDepthRender = this._pFilter3DRenderer.requireDepthRender;
                    } else {
                        this._pRequireDepthRender = false;

                        if (this._pDepthRender) {
                            this._pDepthRender.dispose();
                            this._pDepthRender = null;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DefaultRenderer.prototype, "viewPort", {
                get: /**
                * A viewPort rectangle equivalent of the StageGL size and position.
                */
                function () {
                    return this._viewPort;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DefaultRenderer.prototype, "scissorRect", {
                get: /**
                * A scissor rectangle equivalent of the view size and position.
                */
                function () {
                    return this._pScissorRect;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DefaultRenderer.prototype, "x", {
                get: /**
                *
                */
                function () {
                    return this._localPos.x;
                },
                set: function (value) {
                    if (this.x == value)
                        return;

                    this._globalPos.x = this._localPos.x = value;

                    this.updateGlobalPos();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DefaultRenderer.prototype, "y", {
                get: /**
                *
                */
                function () {
                    return this._localPos.y;
                },
                set: function (value) {
                    if (this.y == value)
                        return;

                    this._globalPos.y = this._localPos.y = value;

                    this.updateGlobalPos();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DefaultRenderer.prototype, "width", {
                get: /**
                *
                */
                function () {
                    return this._width;
                },
                set: function (value) {
                    if (this._width == value)
                        return;

                    this._width = value;
                    this._pScissorRect.width = value;

                    if (this._pRttBufferManager)
                        this._pRttBufferManager.viewWidth = value;

                    this._pBackBufferInvalid = true;
                    this._depthTextureInvalid = true;

                    this.notifyScissorUpdate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DefaultRenderer.prototype, "height", {
                get: /**
                *
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    if (this._height == value)
                        return;

                    this._height = value;
                    this._pScissorRect.height = value;

                    if (this._pRttBufferManager)
                        this._pRttBufferManager.viewHeight = value;

                    this._pBackBufferInvalid = true;
                    this._depthTextureInvalid = true;

                    this.notifyScissorUpdate();
                },
                enumerable: true,
                configurable: true
            });


            DefaultRenderer.prototype.render = function (entityCollector) {
                this._viewportDirty = false;
                this._scissorDirty = false;

                if (!this._pStageGL.recoverFromDisposal()) {
                    this._pBackBufferInvalid = true;
                    return;
                }

                if (this._pBackBufferInvalid)
                    this.pUpdateBackBuffer();

                if (this._shareContext)
                    this._pStageGL.clearDepthBuffer();

                if (this._pFilter3DRenderer || this.iRenderToTexture) {
                    this.textureRatioX = this._pRttBufferManager.textureRatioX;
                    this.textureRatioY = this._pRttBufferManager.textureRatioY;
                } else {
                    this.textureRatioX = 1;
                    this.textureRatioY = 1;
                }

                if (this._pRequireDepthRender)
                    this.pRenderSceneDepthToTexture(entityCollector);

                if (this._depthPrepass)
                    this.pRenderDepthPrepass(entityCollector);

                if (this._pFilter3DRenderer && this._pStageGL.contextGL) {
                    this._iRender(entityCollector, this._pFilter3DRenderer.getMainInputTexture(this._pStageGL), this._pRttBufferManager.renderToTextureRect);
                    this._pFilter3DRenderer.render(this._pStageGL, entityCollector.camera, this._pDepthRender);
                } else {
                    if (this._shareContext)
                        this._iRender(entityCollector, null, this._pScissorRect);
else
                        this._iRender(entityCollector);
                }

                _super.prototype.render.call(this, entityCollector);

                if (!this._shareContext)
                    this._pStageGL.present();

                // register that a view has been rendered
                this._pStageGL.bufferClear = false;
            };

            DefaultRenderer.prototype.pExecuteRender = function (entityCollector, target, scissorRect, surfaceSelector) {
                if (typeof target === "undefined") { target = null; }
                if (typeof scissorRect === "undefined") { scissorRect = null; }
                if (typeof surfaceSelector === "undefined") { surfaceSelector = 0; }
                this.updateLights(entityCollector);

                if (target) {
                    this.drawRenderables(entityCollector.opaqueRenderableHead, entityCollector, DefaultRenderer.RTT_PASSES);
                    this.drawRenderables(entityCollector.blendedRenderableHead, entityCollector, DefaultRenderer.RTT_PASSES);
                }

                _super.prototype.pExecuteRender.call(this, entityCollector, target, scissorRect, surfaceSelector);
            };

            DefaultRenderer.prototype.updateLights = function (entityCollector) {
                var dirLights = entityCollector.directionalLights;
                var pointLights = entityCollector.pointLights;
                var len, i;
                var light;
                var shadowMapper;

                len = dirLights.length;
                for (i = 0; i < len; ++i) {
                    light = dirLights[i];

                    shadowMapper = light.shadowMapper;

                    if (light.castsShadows && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid))
                        shadowMapper.iRenderDepthMap(this._pStageGL, entityCollector, this._pDepthRenderer);
                }

                len = pointLights.length;
                for (i = 0; i < len; ++i) {
                    light = pointLights[i];

                    shadowMapper = light.shadowMapper;

                    if (light.castsShadows && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid))
                        shadowMapper.iRenderDepthMap(this._pStageGL, entityCollector, this._pDistanceRenderer);
                }
            };

            /**
            * @inheritDoc
            */
            DefaultRenderer.prototype.pDraw = function (entityCollector, target) {
                this._pContext.setBlendFactors(away.gl.ContextGLBlendFactor.ONE, away.gl.ContextGLBlendFactor.ZERO);

                if (entityCollector.skyBox) {
                    if (this._activeMaterial)
                        this._activeMaterial.iDeactivate(this._pStageGL);

                    this._activeMaterial = null;

                    this._pContext.setDepthTest(false, away.gl.ContextGLCompareMode.ALWAYS);
                    this.drawSkybox(entityCollector);
                }

                this._pContext.setDepthTest(true, away.gl.ContextGLCompareMode.LESS_EQUAL);

                var which = target ? DefaultRenderer.SCREEN_PASSES : DefaultRenderer.ALL_PASSES;

                this.drawRenderables(entityCollector.opaqueRenderableHead, entityCollector, which);
                this.drawRenderables(entityCollector.blendedRenderableHead, entityCollector, which);

                this._pContext.setDepthTest(false, away.gl.ContextGLCompareMode.LESS_EQUAL);

                if (this._activeMaterial)
                    this._activeMaterial.iDeactivate(this._pStageGL);

                this._activeMaterial = null;
            };

            /**
            * Draw the skybox if present.
            * @param entityCollector The EntityCollector containing all potentially visible information.
            */
            DefaultRenderer.prototype.drawSkybox = function (entityCollector) {
                var skyBox = entityCollector.skyBox;

                var material = skyBox.materialOwner.material;

                var camera = entityCollector.camera;

                this.updateSkyboxProjection(camera);

                material.iActivatePass(0, this._pStageGL, camera);
                material.iRenderPass(0, skyBox, this._pStageGL, entityCollector, this._skyboxProjection);
                material.iDeactivatePass(0, this._pStageGL);
            };

            DefaultRenderer.prototype.updateSkyboxProjection = function (camera) {
                var near = new away.geom.Vector3D();

                this._skyboxProjection.copyFrom(this._pRttViewProjectionMatrix);
                this._skyboxProjection.copyRowTo(2, near);

                var camPos = camera.scenePosition;

                var cx = near.x;
                var cy = near.y;
                var cz = near.z;
                var cw = -(near.x * camPos.x + near.y * camPos.y + near.z * camPos.z + Math.sqrt(cx * cx + cy * cy + cz * cz));

                var signX = cx >= 0 ? 1 : -1;
                var signY = cy >= 0 ? 1 : -1;

                var p = new away.geom.Vector3D(signX, signY, 1, 1);

                var inverse = this._skyboxProjection.clone();
                inverse.invert();

                var q = inverse.transformVector(p);

                this._skyboxProjection.copyRowTo(3, p);

                var a = (q.x * p.x + q.y * p.y + q.z * p.z + q.w * p.w) / (cx * q.x + cy * q.y + cz * q.z + cw * q.w);

                this._skyboxProjection.copyRowFrom(2, new away.geom.Vector3D(cx * a, cy * a, cz * a, cw * a));
            };

            /**
            * Draw a list of renderables.
            * @param renderables The renderables to draw.
            * @param entityCollector The EntityCollector containing all potentially visible information.
            */
            DefaultRenderer.prototype.drawRenderables = function (renderable, entityCollector, which) {
                var numPasses;
                var j;
                var camera = entityCollector.camera;
                var renderable2;

                while (renderable) {
                    this._activeMaterial = renderable.materialOwner.material;

                    this._activeMaterial.iUpdateMaterial(this._pContext);

                    numPasses = this._activeMaterial._iNumPasses;

                    j = 0;

                    do {
                        renderable2 = renderable;

                        var rttMask = this._activeMaterial.iPassRendersToTexture(j) ? 1 : 2;

                        if ((rttMask & which) != 0) {
                            this._activeMaterial.iActivatePass(j, this._pStageGL, camera);

                            do {
                                this._activeMaterial.iRenderPass(j, renderable2, this._pStageGL, entityCollector, this._pRttViewProjectionMatrix);

                                renderable2 = renderable2.next;
                            } while(renderable2 && renderable2.materialOwner.material == this._activeMaterial);

                            this._activeMaterial.iDeactivatePass(j, this._pStageGL);
                        } else {
                            do {
                                renderable2 = renderable2.next;
                            } while(renderable2 && renderable2.materialOwner.material == this._activeMaterial);
                        }
                    } while(++j < numPasses);

                    renderable = renderable2;
                }
            };

            DefaultRenderer.prototype.dispose = function () {
                if (!this._shareContext)
                    this._pStageGL.dispose();

                this._pDepthRenderer.dispose();
                this._pDistanceRenderer.dispose();
                this._pDepthRenderer = null;
                this._pDistanceRenderer = null;

                if (this._pRttBufferManager)
                    this._pRttBufferManager.dispose();

                this._pRttBufferManager = null;
                this._pDepthRender = null;

                this._pStageGL.removeEventListener(away.events.StageGLEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);

                _super.prototype.dispose.call(this);
            };

            /**
            *
            */
            DefaultRenderer.prototype.pRenderDepthPrepass = function (entityCollector) {
                this._pDepthRenderer.disableColor = true;

                if (this._pFilter3DRenderer || this.iRenderToTexture) {
                    this._pDepthRenderer.textureRatioX = this._pRttBufferManager.textureRatioX;
                    this._pDepthRenderer.textureRatioY = this._pRttBufferManager.textureRatioY;
                    this._pDepthRenderer._iRender(entityCollector, this._pFilter3DRenderer.getMainInputTexture(this._pStageGL), this._pRttBufferManager.renderToTextureRect);
                } else {
                    this._pDepthRenderer.textureRatioX = 1;
                    this._pDepthRenderer.textureRatioY = 1;
                    this._pDepthRenderer._iRender(entityCollector);
                }

                this._pDepthRenderer.disableColor = false;
            };

            /**
            *
            */
            DefaultRenderer.prototype.pRenderSceneDepthToTexture = function (entityCollector) {
                if (this._depthTextureInvalid || !this._pDepthRender)
                    this.initDepthTexture(this._pStageGL.contextGL);

                this._pDepthRenderer.textureRatioX = this._pRttBufferManager.textureRatioX;
                this._pDepthRenderer.textureRatioY = this._pRttBufferManager.textureRatioY;
                this._pDepthRenderer._iRender(entityCollector, this._pDepthRender);
            };

            /**
            * Updates the backbuffer dimensions.
            */
            DefaultRenderer.prototype.pUpdateBackBuffer = function () {
                if (this._pStageGL.contextGL && !this._shareContext) {
                    if (this._width && this._height) {
                        this._pStageGL.configureBackBuffer(this._width, this._height, this._antiAlias, true);
                        this._pBackBufferInvalid = false;
                    }
                }
            };

            DefaultRenderer.prototype.iSetStageGL = function (value) {
                if (this._pStageGL)
                    this._pStageGL.removeEventListener(away.events.StageGLEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);

                _super.prototype.iSetStageGL.call(this, value);

                if (this._pStageGL)
                    this._pStageGL.addEventListener(away.events.StageGLEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);

                this._pDistanceRenderer.iSetStageGL(value);
                this._pDepthRenderer.iSetStageGL(value);
            };

            /**
            *
            */
            DefaultRenderer.prototype.initDepthTexture = function (context) {
                this._depthTextureInvalid = false;

                if (this._pDepthRender)
                    this._pDepthRender.dispose();

                this._pDepthRender = context.createTexture(this._pRttBufferManager.textureWidth, this._pRttBufferManager.textureHeight, away.gl.ContextGLTextureFormat.BGRA, true);
            };

            /**
            * @private
            */
            DefaultRenderer.prototype.notifyScissorUpdate = function () {
                if (this._scissorDirty)
                    return;

                this._scissorDirty = true;

                if (!this._scissorUpdated)
                    this._scissorUpdated = new away.events.RendererEvent(away.events.RendererEvent.SCISSOR_UPDATED);

                this.dispatchEvent(this._scissorUpdated);
            };

            /**
            * @private
            */
            DefaultRenderer.prototype.notifyViewportUpdate = function () {
                if (this._viewportDirty)
                    return;

                this._viewportDirty = true;

                if (!this._viewPortUpdated)
                    this._viewPortUpdated = new away.events.RendererEvent(away.events.RendererEvent.VIEWPORT_UPDATED);

                this.dispatchEvent(this._viewPortUpdated);
            };

            /**
            *
            */
            DefaultRenderer.prototype.onViewportUpdated = function (event) {
                this._viewPort = this._pStageGL.viewPort;

                if (this._shareContext) {
                    this._pScissorRect.x = this._globalPos.x - this._pStageGL.x;
                    this._pScissorRect.y = this._globalPos.y - this._pStageGL.y;
                    this.notifyScissorUpdate();
                }

                this.notifyViewportUpdate();
            };

            /**
            *
            */
            DefaultRenderer.prototype.updateGlobalPos = function () {
                if (this._shareContext) {
                    this._pScissorRect.x = this._globalPos.x - this._viewPort.x;
                    this._pScissorRect.y = this._globalPos.y - this._viewPort.y;
                } else {
                    this._pScissorRect.x = 0;
                    this._pScissorRect.y = 0;
                    this._viewPort.x = this._globalPos.x;
                    this._viewPort.y = this._globalPos.y;
                }

                this.notifyScissorUpdate();
            };
            DefaultRenderer.RTT_PASSES = 1;
            DefaultRenderer.SCREEN_PASSES = 2;
            DefaultRenderer.ALL_PASSES = 3;
            return DefaultRenderer;
        })(render.RendererBase);
        render.DefaultRenderer = DefaultRenderer;
    })(away.render || (away.render = {}));
    var render = away.render;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.render
    */
    (function (render) {
        /**
        * @class away.render.Filter3DRenderer
        */
        var Filter3DRenderer = (function () {
            function Filter3DRenderer(stageGL) {
                this._filterSizesInvalid = true;
                this._onRTTResizeDelegate = away.utils.Delegate.create(this, this.onRTTResize);

                this._stageGL = stageGL;
                this._rttManager = away.managers.RTTBufferManager.getInstance(stageGL);
                this._rttManager.addEventListener(away.events.Event.RESIZE, this._onRTTResizeDelegate);
            }
            Filter3DRenderer.prototype.onRTTResize = function (event) {
                this._filterSizesInvalid = true;
            };

            Object.defineProperty(Filter3DRenderer.prototype, "requireDepthRender", {
                get: function () {
                    return this._requireDepthRender;
                },
                enumerable: true,
                configurable: true
            });

            Filter3DRenderer.prototype.getMainInputTexture = function (stageGL) {
                if (this._filterTasksInvalid) {
                    this.updateFilterTasks(stageGL);
                }

                return this._mainInputTexture;
            };

            Object.defineProperty(Filter3DRenderer.prototype, "filters", {
                get: function () {
                    return this._filters;
                },
                set: function (value) {
                    this._filters = value;

                    this._filterTasksInvalid = true;

                    this._requireDepthRender = false;

                    if (!this._filters) {
                        return;
                    }

                    for (var i = 0; i < this._filters.length; ++i) {
                        // TODO: check logic:
                        // this._requireDepthRender ||=  Boolean ( this._filters[i].requireDepthRender )
                        var s = this._filters[i];
                        var b = (s.requireDepthRender == null) ? false : s.requireDepthRender;

                        this._requireDepthRender = this._requireDepthRender || b;
                    }

                    this._filterSizesInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Filter3DRenderer.prototype.updateFilterTasks = function (stageGL) {
                var len;

                if (this._filterSizesInvalid) {
                    this.updateFilterSizes();
                }

                if (!this._filters) {
                    this._tasks = null;
                    return;
                }

                this._tasks = new Array();

                len = this._filters.length - 1;

                var filter;

                for (var i = 0; i <= len; ++i) {
                    // make sure all internal tasks are linked together
                    filter = this._filters[i];

                    // TODO: check logic
                    // filter.setRenderTargets(i == len? null : Filter3DBase(_filters[i + 1]).getMainInputTexture(stageGL), stageGL);
                    filter.setRenderTargets(i == len ? null : this._filters[i + 1].getMainInputTexture(stageGL), stageGL);

                    this._tasks = this._tasks.concat(filter.tasks);
                }

                this._mainInputTexture = this._filters[0].getMainInputTexture(stageGL);
            };

            Filter3DRenderer.prototype.render = function (stageGL, camera, depthTexture) {
                var len;
                var i;
                var task;
                var context = stageGL.contextGL;

                var indexBuffer = this._rttManager.indexBuffer;

                var vertexBuffer = this._rttManager.renderToTextureVertexBuffer;

                if (!this._filters) {
                    return;
                }

                if (this._filterSizesInvalid) {
                    this.updateFilterSizes();
                }

                if (this._filterTasksInvalid) {
                    this.updateFilterTasks(stageGL);
                }

                len = this._filters.length;

                for (i = 0; i < len; ++i) {
                    this._filters[i].update(stageGL, camera);
                }

                len = this._tasks.length;

                if (len > 1) {
                    context.setVertexBufferAt(0, vertexBuffer, 0, away.gl.ContextGLVertexBufferFormat.FLOAT_2);
                    context.setVertexBufferAt(1, vertexBuffer, 2, away.gl.ContextGLVertexBufferFormat.FLOAT_2);
                }

                for (i = 0; i < len; ++i) {
                    task = this._tasks[i];

                    stageGL.setRenderTarget(task.target);

                    if (!task.target) {
                        stageGL.scissorRect = null;
                        vertexBuffer = this._rttManager.renderToScreenVertexBuffer;
                        context.setVertexBufferAt(0, vertexBuffer, 0, away.gl.ContextGLVertexBufferFormat.FLOAT_2);
                        context.setVertexBufferAt(1, vertexBuffer, 2, away.gl.ContextGLVertexBufferFormat.FLOAT_2);
                    }

                    context.setTextureAt(0, task.getMainInputTexture(stageGL));
                    context.setProgram(task.getProgram(stageGL));
                    context.clear(0.0, 0.0, 0.0, 0.0);

                    task.activate(stageGL, camera, depthTexture);

                    context.setBlendFactors(away.gl.ContextGLBlendFactor.ONE, away.gl.ContextGLBlendFactor.ZERO);
                    context.drawTriangles(indexBuffer, 0, 2);

                    task.deactivate(stageGL);
                }

                context.setTextureAt(0, null);
                context.setVertexBufferAt(0, null);
                context.setVertexBufferAt(1, null);
            };

            Filter3DRenderer.prototype.updateFilterSizes = function () {
                for (var i = 0; i < this._filters.length; ++i) {
                    this._filters[i].textureWidth = this._rttManager.textureWidth;
                    this._filters[i].textureHeight = this._rttManager.textureHeight;
                }

                this._filterSizesInvalid = true;
            };

            Filter3DRenderer.prototype.dispose = function () {
                this._rttManager.removeEventListener(away.events.Event.RESIZE, this._onRTTResizeDelegate);
                this._rttManager = null;
                this._stageGL = null;
            };
            return Filter3DRenderer;
        })();
        render.Filter3DRenderer = Filter3DRenderer;
    })(away.render || (away.render = {}));
    var render = away.render;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var DefaultMaterialManager = (function () {
            function DefaultMaterialManager() {
            }
            DefaultMaterialManager.getDefaultMaterial = function (renderable) {
                if (typeof renderable === "undefined") { renderable = null; }
                if (!DefaultMaterialManager._defaultTexture) {
                    DefaultMaterialManager.createDefaultTexture();
                }

                if (!DefaultMaterialManager._defaultMaterial) {
                    DefaultMaterialManager.createDefaultMaterial();
                }

                return DefaultMaterialManager._defaultMaterial;
            };

            DefaultMaterialManager.getDefaultTexture = function (renderable) {
                if (typeof renderable === "undefined") { renderable = null; }
                if (!DefaultMaterialManager._defaultTexture) {
                    DefaultMaterialManager.createDefaultTexture();
                }

                return DefaultMaterialManager._defaultTexture;
            };

            DefaultMaterialManager.createDefaultTexture = function () {
                DefaultMaterialManager._defaultTextureBitmapData = DefaultMaterialManager.createCheckeredBitmapData();

                //create chekerboard
                /*
                var i:number, j:number;
                for (i = 0; i < 8; i++)
                {
                for (j = 0; j < 8; j++)
                {
                if ((j & 1) ^ (i & 1))
                {
                DefaultMaterialManager._defaultTextureBitmapData.setPixel(i, j, 0XFFFFFF);
                }
                }
                }
                */
                DefaultMaterialManager._defaultTexture = new away.textures.BitmapTexture(DefaultMaterialManager._defaultTextureBitmapData, false);
                DefaultMaterialManager._defaultTexture.name = "defaultTexture";
            };

            DefaultMaterialManager.createCheckeredBitmapData = function () {
                var b = new away.base.BitmapData(8, 8, false, 0x000000);

                //create chekerboard
                var i, j;
                for (i = 0; i < 8; i++) {
                    for (j = 0; j < 8; j++) {
                        if ((j & 1) ^ (i & 1)) {
                            b.setPixel(i, j, 0XFFFFFF);
                        }
                    }
                }

                return b;
            };

            DefaultMaterialManager.createDefaultMaterial = function () {
                DefaultMaterialManager._defaultMaterial = new materials.TextureMaterial(DefaultMaterialManager._defaultTexture);
                DefaultMaterialManager._defaultMaterial.mipmap = false;
                DefaultMaterialManager._defaultMaterial.smooth = false;
                DefaultMaterialManager._defaultMaterial.name = "defaultMaterial";
            };
            return DefaultMaterialManager;
        })();
        materials.DefaultMaterialManager = DefaultMaterialManager;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (entities) {
        var SegmentSubGeometry = away.base.SegmentSubGeometry;

        var SegmentSet = (function (_super) {
            __extends(SegmentSet, _super);
            /**
            *
            */
            function SegmentSet() {
                _super.call(this);

                this._pIsEntity = true;

                this.material = new away.materials.SegmentMaterial();

                this._pSubGeometry = new SegmentSubGeometry();
                this._uvTransform = new away.geom.UVTransform(this);
            }
            Object.defineProperty(SegmentSet.prototype, "animator", {
                get: /**
                *
                */
                function () {
                    return this._animator;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "assetType", {
                get: /**
                *
                */
                function () {
                    return away.library.AssetType.SEGMENT_SET;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "castsShadows", {
                get: /**
                *
                */
                function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "material", {
                get: /**
                *
                */
                function () {
                    return this._material;
                },
                set: function (value) {
                    if (value == this._material)
                        return;

                    if (this._material)
                        this._material.iRemoveOwner(this);

                    this._material = value;

                    if (this._material)
                        this._material.iAddOwner(this);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SegmentSet.prototype, "subGeometry", {
                get: /**
                *
                */
                function () {
                    return this._pSubGeometry;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "uvTransform", {
                get: /**
                *
                */
                function () {
                    return this._uvTransform;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * //TODO
            *
            * @param segment
            */
            SegmentSet.prototype.addSegment = function (segment) {
                this._pSubGeometry.addSegment(segment);

                this._pBoundsInvalid = true;
            };

            /**
            * //TODO
            *
            * @param index
            * @returns {*}
            */
            SegmentSet.prototype.getSegment = function (index) {
                return this._pSubGeometry.getSegment(index);
            };

            /**
            * //TODO
            *
            * @param index
            * @param dispose
            */
            SegmentSet.prototype.removeSegmentByIndex = function (index, dispose) {
                if (typeof dispose === "undefined") { dispose = false; }
                this._pSubGeometry.removeSegmentByIndex(index, dispose);

                this._pBoundsInvalid = true;
            };

            /**
            * //TODO
            */
            SegmentSet.prototype.removeAllSegments = function () {
                this._pSubGeometry.removeAllSegments();

                this._pBoundsInvalid = true;
            };

            /**
            * //TODO
            *
            * @param segment
            * @param dispose
            */
            SegmentSet.prototype.removeSegment = function (segment, dispose) {
                if (typeof dispose === "undefined") { dispose = false; }
                this._pSubGeometry.removeSegment(segment, dispose);

                this._pBoundsInvalid = true;
            };

            /**
            * //TODO
            */
            SegmentSet.prototype.dispose = function () {
                _super.prototype.dispose.call(this);

                this._pSubGeometry.dispose();

                this._material = null;
            };

            /**
            * @protected
            */
            SegmentSet.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.EntityNode(this);
            };

            /**
            * //TOOD
            *
            * @returns {away.bounds.BoundingSphere}
            *
            * @protected
            */
            SegmentSet.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.BoundingSphere();
            };

            /**
            * //TODO
            *
            * @protected
            */
            SegmentSet.prototype.pUpdateBounds = function () {
                this._pSubGeometry.updateBounds(this._pBounds);

                _super.prototype.pUpdateBounds.call(this);
            };

            /**
            * //TODO
            *
            * @internal
            */
            SegmentSet.prototype._iSetUVMatrixComponents = function (offsetU, offsetV, scaleU, scaleV, rotationUV) {
            };

            /**
            * //TODO
            *
            * @internal
            */
            SegmentSet.prototype._iIsMouseEnabled = function () {
                return false;
            };
            return SegmentSet;
        })(away.base.DisplayObject);
        entities.SegmentSet = SegmentSet;
    })(away.entities || (away.entities = {}));
    var entities = away.entities;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (entities) {
        var Delegate = away.utils.Delegate;

        
        
        var SubGeometry = away.base.SubGeometry;
        var SubMesh = away.base.SubMesh;
        var Geometry = away.base.Geometry;
        var GeometryEvent = away.events.GeometryEvent;
        var DefaultMaterialManager = away.materials.DefaultMaterialManager;
        var MaterialBase = away.materials.MaterialBase;
        var EntityNode = away.partition.EntityNode;

        /**
        * Mesh is an instance of a Geometry, augmenting it with a presence in the scene graph, a material, and an animation
        * state. It consists out of SubMeshes, which in turn correspond to SubGeometries. SubMeshes allow different parts
        * of the geometry to be assigned different materials.
        */
        var Mesh = (function (_super) {
            __extends(Mesh, _super);
            /**
            * Create a new Mesh object.
            *
            * @param geometry                    The geometry used by the mesh that provides it with its shape.
            * @param material    [optional]        The material with which to render the Mesh.
            */
            function Mesh(geometry, material) {
                if (typeof material === "undefined") { material = null; }
                _super.call(this);
                this._castsShadows = true;
                this._shareAnimationGeometry = true;

                this._pIsEntity = true;

                this._subMeshes = new Array();

                this._onGeometryBoundsInvalidDelegate = Delegate.create(this, this.onGeometryBoundsInvalid);
                this._onSubGeometryAddedDelegate = Delegate.create(this, this.onSubGeometryAdded);
                this._onSubGeometryRemovedDelegate = Delegate.create(this, this.onSubGeometryRemoved);

                if (geometry == null)
                    this.geometry = new Geometry();
else
                    this.geometry = geometry;

                if (material == null)
                    this.material = DefaultMaterialManager.getDefaultMaterial(this);
else
                    this.material = material;

                this._uvTransform = new away.geom.UVTransform(this);
            }
            Object.defineProperty(Mesh.prototype, "animator", {
                get: /**
                * Defines the animator of the mesh. Act on the mesh's geometry.  Default value is <code>null</code>.
                */
                function () {
                    return this._animator;
                },
                set: function (value) {
                    if (this._animator)
                        this._animator.removeOwner(this);

                    this._animator = value;

                    // cause material to be unregistered and registered again to work with the new animation type (if possible)
                    var oldMaterial = this.material;
                    this.material = null;
                    this.material = oldMaterial;

                    var len = this._subMeshes.length;
                    var subMesh;

                    for (var i = 0; i < len; ++i) {
                        subMesh = this._subMeshes[i];
                        oldMaterial = subMesh._iMaterial;
                        if (oldMaterial) {
                            subMesh.material = null;
                            subMesh.material = oldMaterial;
                        }
                    }

                    if (this._animator)
                        this._animator.addOwner(this);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Mesh.prototype, "assetType", {
                get: /**
                *
                */
                function () {
                    return away.library.AssetType.MESH;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mesh.prototype, "castsShadows", {
                get: /**
                * Indicates whether or not the Mesh can cast shadows. Default value is <code>true</code>.
                */
                function () {
                    return this._castsShadows;
                },
                set: function (value) {
                    this._castsShadows = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Mesh.prototype, "geometry", {
                get: /**
                * The geometry used by the mesh that provides it with its shape.
                */
                function () {
                    return this._geometry;
                },
                set: function (value) {
                    var i;

                    if (this._geometry) {
                        this._geometry.removeEventListener(GeometryEvent.BOUNDS_INVALID, this._onGeometryBoundsInvalidDelegate);
                        this._geometry.removeEventListener(GeometryEvent.SUB_GEOMETRY_ADDED, this._onSubGeometryAddedDelegate);
                        this._geometry.removeEventListener(GeometryEvent.SUB_GEOMETRY_REMOVED, this._onSubGeometryRemovedDelegate);

                        for (i = 0; i < this._subMeshes.length; ++i)
                            this._subMeshes[i].dispose();

                        this._subMeshes.length = 0;
                    }

                    this._geometry = value;

                    if (this._geometry) {
                        this._geometry.addEventListener(GeometryEvent.BOUNDS_INVALID, this._onGeometryBoundsInvalidDelegate);
                        this._geometry.addEventListener(GeometryEvent.SUB_GEOMETRY_ADDED, this._onSubGeometryAddedDelegate);
                        this._geometry.addEventListener(GeometryEvent.SUB_GEOMETRY_REMOVED, this._onSubGeometryRemovedDelegate);

                        var subGeoms = this._geometry.subGeometries;

                        for (i = 0; i < subGeoms.length; ++i)
                            this.addSubMesh(subGeoms[i]);
                    }

                    if (this._material) {
                        this._material.iRemoveOwner(this);
                        this._material.iAddOwner(this);
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Mesh.prototype, "material", {
                get: /**
                * The material with which to render the Mesh.
                */
                function () {
                    return this._material;
                },
                set: function (value) {
                    if (value == this._material)
                        return;

                    if (this._material)
                        this._material.iRemoveOwner(this);

                    this._material = value;

                    if (this._material)
                        this._material.iAddOwner(this);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Mesh.prototype, "shareAnimationGeometry", {
                get: /**
                * Indicates whether or not the mesh share the same animation geometry.
                */
                function () {
                    return this._shareAnimationGeometry;
                },
                set: function (value) {
                    this._shareAnimationGeometry = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Mesh.prototype, "subMeshes", {
                get: /**
                * The SubMeshes out of which the Mesh consists. Every SubMesh can be assigned a material to override the Mesh's
                * material.
                */
                function () {
                    // Since this getter is invoked every iteration of the render loop, and
                    // the geometry construct could affect the sub-meshes, the geometry is
                    // validated here to give it a chance to rebuild.
                    this._geometry.iValidate();

                    return this._subMeshes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mesh.prototype, "uvTransform", {
                get: /**
                *
                */
                function () {
                    return this._uvTransform;
                },
                enumerable: true,
                configurable: true
            });

            /**
            *
            */
            Mesh.prototype.bakeTransformations = function () {
                this.geometry.applyTransformation(this._iMatrix3D);
                this._iMatrix3D.identity();
            };

            /**
            * Clears the animation geometry of this mesh. It will cause animation to generate a new animation geometry. Work only when shareAnimationGeometry is false.
            */
            Mesh.prototype.clearAnimationGeometry = function () {
                var len = this._subMeshes.length;
                for (var i = 0; i < len; ++i)
                    this._subMeshes[i].animationSubGeometry = null;
            };

            /**
            * @inheritDoc
            */
            Mesh.prototype.dispose = function () {
                _super.prototype.dispose.call(this);

                this.material = null;
                this.geometry = null;
            };

            /**
            * Disposes mesh including the animator and children. This is a merely a convenience method.
            * @return
            */
            Mesh.prototype.disposeWithAnimatorAndChildren = function () {
                this.disposeWithChildren();

                if (this._animator)
                    this._animator.dispose();
            };

            /**
            * Clones this Mesh instance along with all it's children, while re-using the same
            * material, geometry and animation set. The returned result will be a copy of this mesh,
            * containing copies of all of it's children.
            *
            * Properties that are re-used (i.e. not cloned) by the new copy include name,
            * geometry, and material. Properties that are cloned or created anew for the copy
            * include subMeshes, children of the mesh, and the animator.
            *
            * If you want to copy just the mesh, reusing it's geometry and material while not
            * cloning it's children, the simplest way is to create a new mesh manually:
            *
            * <code>
            * var clone : Mesh = new Mesh(original.geometry, original.material);
            * </code>
            */
            Mesh.prototype.clone = function () {
                var clone = new Mesh(this._geometry, this._material);

                clone._iMatrix3D = this._iMatrix3D;
                clone.pivotPoint = this.pivotPoint;
                clone.partition = this.partition;
                clone.bounds = this.bounds.clone();

                clone.name = this.name;
                clone.castsShadows = this.castsShadows;
                clone.shareAnimationGeometry = this.shareAnimationGeometry;
                clone.mouseEnabled = this.mouseEnabled;
                clone.mouseChildren = this.mouseChildren;

                //this is of course no proper cloning
                //maybe use this instead?: http://blog.another-d-mention.ro/programming/how-to-clone-duplicate-an-object-in-actionscript-3/
                clone.extra = this.extra;

                var len = this._subMeshes.length;
                for (var i = 0; i < len; ++i)
                    clone._subMeshes[i]._iMaterial = this._subMeshes[i]._iMaterial;

                len = this.numChildren;
                var obj;

                for (i = 0; i < len; ++i) {
                    obj = this.getChildAt(i).clone();
                    clone.addChild(obj);
                }

                if (this._animator)
                    clone.animator = this._animator.clone();

                return clone;
            };

            /**
            * //TODO
            *
            * @param subGeometry
            * @returns {SubMesh}
            */
            Mesh.prototype.getSubMeshFromSubGeometry = function (subGeometry) {
                return this._subMeshes[this._geometry.subGeometries.indexOf(subGeometry)];
            };

            /**
            * @protected
            */
            Mesh.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.EntityNode(this);
            };

            /**
            * //TODO
            *
            * @protected
            */
            Mesh.prototype.pUpdateBounds = function () {
                var subGeoms = this._geometry.subGeometries;
                var numSubGeoms = subGeoms.length;
                var minX, minY, minZ;
                var maxX, maxY, maxZ;

                if (numSubGeoms > 0) {
                    var j = 0;

                    minX = minY = minZ = Number.POSITIVE_INFINITY;
                    maxX = maxY = maxZ = Number.NEGATIVE_INFINITY;

                    while (j < numSubGeoms) {
                        var subGeom = subGeoms[j++];
                        var vertices = subGeom.vertexData;
                        var vertexDataLen = vertices.length;
                        var i = subGeom.vertexOffset;
                        var stride = subGeom.vertexStride;

                        while (i < vertexDataLen) {
                            var v = vertices[i];
                            if (v < minX)
                                minX = v;
else if (v > maxX)
                                maxX = v;

                            v = vertices[i + 1];

                            if (v < minY)
                                minY = v;
else if (v > maxY)
                                maxY = v;

                            v = vertices[i + 2];

                            if (v < minZ)
                                minZ = v;
else if (v > maxZ)
                                maxZ = v;

                            i += stride;
                        }
                    }

                    this._pBounds.fromExtremes(minX, minY, minZ, maxX, maxY, maxZ);
                } else {
                    this._pBounds.fromExtremes(0, 0, 0, 0, 0, 0);
                }

                _super.prototype.pUpdateBounds.call(this);
            };

            /**
            * //TODO
            *
            * @private
            */
            Mesh.prototype.onGeometryBoundsInvalid = function (event) {
                this.pInvalidateBounds();
            };

            /**
            * Called when a SubGeometry was added to the Geometry.
            *
            * @private
            */
            Mesh.prototype.onSubGeometryAdded = function (event) {
                this.addSubMesh(event.subGeometry);
            };

            /**
            * Called when a SubGeometry was removed from the Geometry.
            *
            * @private
            */
            Mesh.prototype.onSubGeometryRemoved = function (event) {
                var subMesh;
                var subGeom = event.subGeometry;
                var len = this._subMeshes.length;
                var i;

                for (i = 0; i < len; ++i) {
                    subMesh = this._subMeshes[i];

                    if (subMesh.subGeometry == subGeom) {
                        subMesh.dispose();

                        this._subMeshes.splice(i, 1);

                        break;
                    }
                }

                --len;
                for (; i < len; ++i)
                    this._subMeshes[i]._iIndex = i;
            };

            /**
            * Adds a SubMesh wrapping a SubGeometry.
            *
            * @param subGeometry
            */
            Mesh.prototype.addSubMesh = function (subGeometry) {
                var subMesh = new SubMesh(subGeometry, this, null);
                var len = this._subMeshes.length;

                subMesh._iIndex = len;

                this._subMeshes[len] = subMesh;

                this.pInvalidateBounds();
            };

            /**
            * @internal
            */
            Mesh.prototype._iSetUVMatrixComponents = function (offsetU, offsetV, scaleU, scaleV, rotationUV) {
                var len = this._subMeshes.length;
                for (var i = 0; i < len; ++i) {
                    this._subMeshes[i].uvTransform.offsetU = offsetU;
                    this._subMeshes[i].uvTransform.offsetV = offsetV;
                    this._subMeshes[i].uvTransform.scaleU = scaleU;
                    this._subMeshes[i].uvTransform.scaleV = scaleV;
                    this._subMeshes[i].uvTransform.rotationUV = rotationUV;
                }
            };
            return Mesh;
        })(away.containers.DisplayObjectContainer);
        entities.Mesh = Mesh;
    })(away.entities || (away.entities = {}));
    var entities = away.entities;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (entities) {
        /**
        * A Skybox class is used to render a sky in the scene. It's always considered static and 'at infinity', and as
        * such it's always centered at the camera's position and sized to exactly fit within the camera's frustum, ensuring
        * the sky box is always as large as possible without being clipped.
        */
        var Skybox = (function (_super) {
            __extends(Skybox, _super);
            /**
            * Create a new Skybox object.
            * @param cubeMap The CubeMap to use for the sky box's texture.
            */
            function Skybox(cubeMap) {
                _super.call(this);

                this._pIsEntity = true;

                //create material
                this._material = new away.materials.SkyboxMaterial(cubeMap);
                this._material.iAddOwner(this);

                this._uvTransform = new away.geom.UVTransform(this);
            }
            Object.defineProperty(Skybox.prototype, "animator", {
                get: function () {
                    return this._animator;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Skybox.prototype, "uvTransform", {
                get: /**
                *
                */
                function () {
                    return this._uvTransform;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Skybox.prototype, "material", {
                get: /**
                * The material with which to render the object.
                */
                function () {
                    return this._material;
                },
                set: function (value) {
                    throw new away.errors.AbstractMethodError("Unsupported method!");
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Skybox.prototype, "assetType", {
                get: function () {
                    return away.library.AssetType.SKYBOX;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @protected
            */
            Skybox.prototype.pInvalidateBounds = function () {
                // dead end
            };

            /**
            * @protected
            */
            Skybox.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.SkyboxNode(this);
            };

            /**
            * @protected
            */
            Skybox.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.NullBounds();
            };

            /**
            * @protected
            */
            Skybox.prototype.pUpdateBounds = function () {
                this._pBoundsInvalid = false;
            };

            Object.defineProperty(Skybox.prototype, "castsShadows", {
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @internal
            */
            Skybox.prototype._iSetUVMatrixComponents = function (offsetU, offsetV, scaleU, scaleV, rotationUV) {
            };
            return Skybox;
        })(away.base.DisplayObject);
        entities.Skybox = Skybox;
    })(away.entities || (away.entities = {}));
    var entities = away.entities;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (containers) {
        /**
        * Dispatched when any asset finishes parsing. Also see specific events for each
        * individual asset type (meshes, materials et c.)
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="assetComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a full resource (including dependencies) finishes loading.
        *
        * @eventType away3d.events.LoaderEvent
        */
        //[Event(name="resourceComplete", type="away3d.events.LoaderEvent")]
        /**
        * Dispatched when a single dependency (which may be the main file of a resource)
        * finishes loading.
        *
        * @eventType away3d.events.LoaderEvent
        */
        //[Event(name="dependencyComplete", type="away3d.events.LoaderEvent")]
        /**
        * Dispatched when an error occurs during loading. I
        *
        * @eventType away3d.events.LoaderEvent
        */
        //[Event(name="loadError", type="away3d.events.LoaderEvent")]
        /**
        * Dispatched when an error occurs during parsing.
        *
        * @eventType away3d.events.ParserEvent
        */
        //[Event(name="parseError", type="away3d.events.ParserEvent")]
        /**
        * Dispatched when a skybox asset has been costructed from a ressource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="skyboxComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a camera3d asset has been costructed from a ressource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="cameraComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a mesh asset has been costructed from a ressource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="meshComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a geometry asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="geometryComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a skeleton asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="skeletonComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a skeleton pose asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="skeletonPoseComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a container asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="containerComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a texture asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="textureComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a texture projector asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="textureProjectorComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a material asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="materialComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a animator asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animatorComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation set has been constructed from a group of animation state resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animationSetComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation state has been constructed from a group of animation node resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animationStateComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation node has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animationNodeComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation state transition has been constructed from a group of animation node resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="stateTransitionComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an light asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="lightComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an light picker asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="lightPickerComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an effect method asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="effectMethodComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an shadow map method asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="shadowMapMethodComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an image asset dimensions are not a power of 2
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="textureSizeError", type="away3d.events.AssetEvent")]
        /**
        * Loader3D can load any file format that Away3D supports (or for which a third-party parser
        * has been plugged in) and be added directly to the scene. As assets are encountered
        * they are added to the Loader3D container. Assets that can not be displayed in the scene
        * graph (e.g. unused bitmaps/materials/skeletons etc) will be ignored.
        *
        * This provides a fast and easy way to load models (no need for event listeners) but is not
        * very versatile since many types of assets are ignored.
        *
        * Loader3D by default uses the AssetLibrary to load all assets, which means that they also
        * ends up in the library. To circumvent this, Loader3D can be configured to not use the
        * AssetLibrary in which case it will use the AssetLoader directly.
        *
        * @see away.net.AssetLoader
        * @see away.library.AssetLibrary
        */
        var Loader3D = (function (_super) {
            __extends(Loader3D, _super);
            function Loader3D(useAssetLibrary, assetLibraryId) {
                if (typeof useAssetLibrary === "undefined") { useAssetLibrary = true; }
                if (typeof assetLibraryId === "undefined") { assetLibraryId = null; }
                _super.call(this);

                this._loadingSessions = new Array();
                this._useAssetLib = useAssetLibrary;
                this._assetLibId = assetLibraryId;

                this._onResourceCompleteDelegate = away.utils.Delegate.create(this, this.onResourceComplete);
                this._onAssetCompleteDelegate = away.utils.Delegate.create(this, this.onAssetComplete);
            }
            /**
            * Loads a file and (optionally) all of its dependencies.
            *
            * @param req The URLRequest object containing the URL of the file to be loaded.
            * @param context An optional context object providing additional parameters for loading
            * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
            * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
            */
            Loader3D.prototype.load = function (req, context, ns, parser) {
                if (typeof context === "undefined") { context = null; }
                if (typeof ns === "undefined") { ns = null; }
                if (typeof parser === "undefined") { parser = null; }
                var token;

                if (this._useAssetLib) {
                    var lib;
                    lib = away.library.AssetLibraryBundle.getInstance(this._assetLibId);
                    token = lib.load(req, context, ns, parser);
                } else {
                    var loader = new away.net.AssetLoader();
                    this._loadingSessions.push(loader);
                    token = loader.load(req, context, ns, parser);
                }

                token.addEventListener(away.events.LoaderEvent.RESOURCE_COMPLETE, this._onResourceCompleteDelegate);
                token.addEventListener(away.events.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);

                // Error are handled separately (see documentation for addErrorHandler)
                token._iLoader._iAddErrorHandler(this.onLoadError);
                token._iLoader._iAddParseErrorHandler(this.onParseError);

                return token;
            };

            /**
            * Loads a resource from already loaded data.
            *
            * @param data The data object containing all resource information.
            * @param context An optional context object providing additional parameters for loading
            * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
            * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
            */
            Loader3D.prototype.loadData = function (data, context, ns, parser) {
                if (typeof context === "undefined") { context = null; }
                if (typeof ns === "undefined") { ns = null; }
                if (typeof parser === "undefined") { parser = null; }
                var token;

                if (this._useAssetLib) {
                    var lib;
                    lib = away.library.AssetLibraryBundle.getInstance(this._assetLibId);
                    token = lib.loadData(data, context, ns, parser);
                } else {
                    var loader = new away.net.AssetLoader();
                    this._loadingSessions.push(loader);
                    token = loader.loadData(data, '', context, ns, parser);
                }

                token.addEventListener(away.events.LoaderEvent.RESOURCE_COMPLETE, this._onResourceCompleteDelegate);
                token.addEventListener(away.events.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);

                // Error are handled separately (see documentation for addErrorHandler)
                token._iLoader._iAddErrorHandler(this.onLoadError);
                token._iLoader._iAddParseErrorHandler(this.onParseError);

                return token;
            };

            /**
            * Stop the current loading/parsing process.
            */
            Loader3D.prototype.stopLoad = function () {
                if (this._useAssetLib) {
                    var lib;
                    lib = away.library.AssetLibraryBundle.getInstance(this._assetLibId);
                    lib.stopAllLoadingSessions();
                    this._loadingSessions = null;
                    return;
                }
                var i/*int*/ ;
                var length = this._loadingSessions.length;
                for (i = 0; i < length; i++) {
                    this.removeListeners(this._loadingSessions[i]);
                    this._loadingSessions[i].stop();
                    this._loadingSessions[i] = null;
                }
                this._loadingSessions = null;
            };

            Loader3D.enableParser = /**
            * Enables a specific parser.
            * When no specific parser is set for a loading/parsing opperation,
            * loader3d can autoselect the correct parser to use.
            * A parser must have been enabled, to be considered when autoselecting the parser.
            *
            * @param parserClass The parser class to enable.
            * @see away.parsers.Parsers
            */
            function (parserClass) {
                away.net.AssetLoader.enableParser(parserClass);
            };

            Loader3D.enableParsers = /**
            * Enables a list of parsers.
            * When no specific parser is set for a loading/parsing opperation,
            * loader3d can autoselect the correct parser to use.
            * A parser must have been enabled, to be considered when autoselecting the parser.
            *
            * @param parserClasses A Vector of parser classes to enable.
            * @see away.parsers.Parsers
            */
            function (parserClasses) {
                away.net.AssetLoader.enableParsers(parserClasses);
            };

            Loader3D.prototype.removeListeners = function (dispatcher) {
                dispatcher.removeEventListener(away.events.LoaderEvent.RESOURCE_COMPLETE, this._onResourceCompleteDelegate);
                dispatcher.removeEventListener(away.events.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
            };

            Loader3D.prototype.onAssetComplete = function (ev) {
                if (ev.type == away.events.AssetEvent.ASSET_COMPLETE) {
                    // TODO: not used
                    // var type : string = ev.asset.assetType;
                    var obj;
                    switch (ev.asset.assetType) {
                        case away.library.AssetType.LIGHT:
                            obj = ev.asset;
                            break;
                        case away.library.AssetType.CONTAINER:
                            obj = ev.asset;
                            break;
                        case away.library.AssetType.MESH:
                            obj = ev.asset;
                            break;

                            break;

                            break;
                        case away.library.AssetType.CAMERA:
                            obj = ev.asset;
                            break;
                        case away.library.AssetType.SEGMENT_SET:
                            obj = ev.asset;
                            break;
                    }

                    if (obj && obj.parent == null)
                        this.addChild(obj);
                }

                this.dispatchEvent(ev.clone());
            };

            /**
            * Called when an error occurs during loading
            */
            Loader3D.prototype.onLoadError = function (event) {
                if (this.hasEventListener(away.events.IOErrorEvent.IO_ERROR, this.onLoadError)) {
                    this.dispatchEvent(event);
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Called when a an error occurs during parsing
            */
            Loader3D.prototype.onParseError = function (event) {
                if (this.hasEventListener(away.events.ParserEvent.PARSE_ERROR, this.onParseError)) {
                    this.dispatchEvent(event);
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Called when the resource and all of its dependencies was retrieved.
            */
            Loader3D.prototype.onResourceComplete = function (event) {
                var loader = event.target;

                this.dispatchEvent(event);
            };
            return Loader3D;
        })(away.containers.DisplayObjectContainer);
        containers.Loader3D = Loader3D;
    })(away.containers || (away.containers = {}));
    var containers = away.containers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (filters) {
        var Filter3DTaskBase = (function () {
            function Filter3DTaskBase(requireDepthRender) {
                if (typeof requireDepthRender === "undefined") { requireDepthRender = false; }
                this._scaledTextureWidth = -1;
                this._scaledTextureHeight = -1;
                this._textureWidth = -1;
                this._textureHeight = -1;
                this._textureDimensionsInvalid = true;
                this._program3DInvalid = true;
                this._textureScale = 0;
                this._requireDepthRender = requireDepthRender;
            }
            Object.defineProperty(Filter3DTaskBase.prototype, "textureScale", {
                get: /**
                * The texture scale for the input of this texture. This will define the output of the previous entry in the chain
                */
                function () {
                    return this._textureScale;
                },
                set: function (value) {
                    if (this._textureScale == value) {
                        return;
                    }

                    this._textureScale = value;
                    this._scaledTextureWidth = this._textureWidth >> this._textureScale;
                    this._scaledTextureHeight = this._textureHeight >> this._textureScale;
                    this._textureDimensionsInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Filter3DTaskBase.prototype, "target", {
                get: function () {
                    return this._target;
                },
                set: function (value) {
                    this._target = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Filter3DTaskBase.prototype, "textureWidth", {
                get: function () {
                    return this._textureWidth;
                },
                set: function (value) {
                    if (this._textureWidth == value) {
                        return;
                    }

                    this._textureWidth = value;
                    this._scaledTextureWidth = this._textureWidth >> this._textureScale;
                    this._textureDimensionsInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Filter3DTaskBase.prototype, "textureHeight", {
                get: function () {
                    return this._textureHeight;
                },
                set: function (value) {
                    if (this._textureHeight == value) {
                        return;
                    }

                    this._textureHeight = value;
                    this._scaledTextureHeight = this._textureHeight >> this._textureScale;
                    this._textureDimensionsInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Filter3DTaskBase.prototype.getMainInputTexture = function (stage) {
                if (this._textureDimensionsInvalid) {
                    this.pUpdateTextures(stage);
                }

                return this._mainInputTexture;
            };

            Filter3DTaskBase.prototype.dispose = function () {
                if (this._mainInputTexture) {
                    this._mainInputTexture.dispose();
                }

                if (this._program3D) {
                    this._program3D.dispose();
                }
            };

            Filter3DTaskBase.prototype.pInvalidateProgram = function () {
                this._program3DInvalid = true;
            };

            Filter3DTaskBase.prototype.pUpdateProgram = function (stage) {
                if (this._program3D) {
                    this._program3D.dispose();
                }

                this._program3D = stage.contextGL.createProgram();

                //away.Debug.log( 'Filder3DTaskBase' , 'pUpdateProgram' , 'Program.upload / AGAL <> GLSL implementation' );
                // TODO: imeplement AGAL <> GLSL
                //this._program3D.upload(new AGALMiniAssembler(Debug.active).assemble(ContextGLProgramType.VERTEX, getVertexCode()),new AGALMiniAssembler(Debug.active).assemble(ContextGLProgramType.FRAGMENT, getFragmentCode()));
                //new AGALMiniAssembler(Debug.active).assemble(ContextGLProgramType.VERTEX, getVertexCode()),
                //new AGALMiniAssembler(Debug.active).assemble(ContextGLProgramType.FRAGMENT, getFragmentCode()));
                var vertCompiler = new aglsl.AGLSLCompiler();
                var fragCompiler = new aglsl.AGLSLCompiler();

                var vertString = vertCompiler.compile(away.gl.ContextGLProgramType.VERTEX, this.pGetVertexCode());
                var fragString = fragCompiler.compile(away.gl.ContextGLProgramType.FRAGMENT, this.pGetFragmentCode());

                this._program3D.upload(vertString, fragString);
                this._program3DInvalid = false;
            };

            Filter3DTaskBase.prototype.pGetVertexCode = function () {
                // TODO: imeplement AGAL <> GLSL
                return "mov op, va0\n" + "mov v0, va1\n";
            };

            Filter3DTaskBase.prototype.pGetFragmentCode = function () {
                throw new away.errors.AbstractMethodError();

                return null;
            };

            Filter3DTaskBase.prototype.pUpdateTextures = function (stage) {
                if (this._mainInputTexture) {
                    this._mainInputTexture.dispose();
                }

                this._mainInputTexture = stage.contextGL.createTexture(this._scaledTextureWidth, this._scaledTextureHeight, away.gl.ContextGLTextureFormat.BGRA, true);

                this._textureDimensionsInvalid = false;
            };

            Filter3DTaskBase.prototype.getProgram = function (stageGL) {
                if (this._program3DInvalid) {
                    this.pUpdateProgram(stageGL);
                }

                return this._program3D;
            };

            Filter3DTaskBase.prototype.activate = function (stageGL, camera, depthTexture) {
            };

            Filter3DTaskBase.prototype.deactivate = function (stageGL) {
            };

            Object.defineProperty(Filter3DTaskBase.prototype, "requireDepthRender", {
                get: function () {
                    return this._requireDepthRender;
                },
                enumerable: true,
                configurable: true
            });
            return Filter3DTaskBase;
        })();
        filters.Filter3DTaskBase = Filter3DTaskBase;
    })(away.filters || (away.filters = {}));
    var filters = away.filters;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (filters) {
        var Filter3DBase = (function () {
            function Filter3DBase() {
                this._tasks = new Array();
            }
            Object.defineProperty(Filter3DBase.prototype, "requireDepthRender", {
                get: function () {
                    return this._requireDepthRender;
                },
                enumerable: true,
                configurable: true
            });

            Filter3DBase.prototype.pAddTask = function (filter) {
                this._tasks.push(filter);

                if (this._requireDepthRender == null) {
                    this._requireDepthRender = filter.requireDepthRender;
                }
            };

            Object.defineProperty(Filter3DBase.prototype, "tasks", {
                get: function () {
                    return this._tasks;
                },
                enumerable: true,
                configurable: true
            });

            Filter3DBase.prototype.getMainInputTexture = function (stageGL) {
                return this._tasks[0].getMainInputTexture(stageGL);
            };

            Object.defineProperty(Filter3DBase.prototype, "textureWidth", {
                get: function () {
                    return this._textureWidth;
                },
                set: function (value) {
                    this._textureWidth = value;

                    for (var i = 0; i < this._tasks.length; ++i) {
                        this._tasks[i].textureWidth = value;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Filter3DBase.prototype, "textureHeight", {
                get: function () {
                    return this._textureHeight;
                },
                set: function (value) {
                    this._textureHeight = value;

                    for (var i = 0; i < this._tasks.length; ++i) {
                        this._tasks[i].textureHeight = value;
                    }
                },
                enumerable: true,
                configurable: true
            });


            // link up the filters correctly with the next filter
            Filter3DBase.prototype.setRenderTargets = function (mainTarget, stageGL) {
                this._tasks[this._tasks.length - 1].target = mainTarget;
            };

            Filter3DBase.prototype.dispose = function () {
                for (var i = 0; i < this._tasks.length; ++i) {
                    this._tasks[i].dispose();
                }
            };

            Filter3DBase.prototype.update = function (stage, camera) {
            };
            return Filter3DBase;
        })();
        filters.Filter3DBase = Filter3DBase;
    })(away.filters || (away.filters = {}));
    var filters = away.filters;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (lights) {
        var LightBase = (function (_super) {
            __extends(LightBase, _super);
            function LightBase() {
                _super.call(this);
                this._color = 0xffffff;
                this._colorR = 1;
                this._colorG = 1;
                this._colorB = 1;
                this._ambientColor = 0xffffff;
                this._ambient = 0;
                this._iAmbientR = 0;
                this._iAmbientG = 0;
                this._iAmbientB = 0;
                this._specular = 1;
                this._iSpecularR = 1;
                this._iSpecularG = 1;
                this._iSpecularB = 1;
                this._diffuse = 1;
                this._iDiffuseR = 1;
                this._iDiffuseG = 1;
                this._iDiffuseB = 1;
                this._castsShadows = false;
            }
            Object.defineProperty(LightBase.prototype, "castsShadows", {
                get: function () {
                    return this._castsShadows;
                },
                set: function (value) {
                    if (this._castsShadows == value)
                        return;

                    this._castsShadows = value;

                    if (value) {
                        if (this._shadowMapper == null)
                            this._shadowMapper = this.pCreateShadowMapper();

                        this._shadowMapper.light = this;
                    } else {
                        this._shadowMapper.dispose();
                        this._shadowMapper = null;
                    }

                    //*/
                    this.dispatchEvent(new away.events.LightEvent(away.events.LightEvent.CASTS_SHADOW_CHANGE));
                },
                enumerable: true,
                configurable: true
            });


            LightBase.prototype.pCreateShadowMapper = function () {
                throw new away.errors.AbstractMethodError();
            };

            Object.defineProperty(LightBase.prototype, "specular", {
                get: function () {
                    return this._specular;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;

                    this._specular = value;
                    this.updateSpecular();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightBase.prototype, "diffuse", {
                get: function () {
                    return this._diffuse;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;

                    this._diffuse = value;
                    this.updateDiffuse();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightBase.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    this._color = value;
                    this._colorR = ((this._color >> 16) & 0xff) / 0xff;
                    this._colorG = ((this._color >> 8) & 0xff) / 0xff;
                    this._colorB = (this._color & 0xff) / 0xff;
                    this.updateDiffuse();
                    this.updateSpecular();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightBase.prototype, "ambient", {
                get: function () {
                    return this._ambient;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;
else if (value > 1)
                        value = 1;

                    this._ambient = value;
                    this.updateAmbient();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightBase.prototype, "ambientColor", {
                get: function () {
                    return this._ambientColor;
                },
                set: function (value) {
                    this._ambientColor = value;
                    this.updateAmbient();
                },
                enumerable: true,
                configurable: true
            });


            LightBase.prototype.updateAmbient = function () {
                this._iAmbientR = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient;
                this._iAmbientG = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient;
                this._iAmbientB = (this._ambientColor & 0xff) / 0xff * this._ambient;
            };

            LightBase.prototype.iGetObjectProjectionMatrix = function (entity, camera, target) {
                if (typeof target === "undefined") { target = null; }
                throw new away.errors.AbstractMethodError();
            };

            Object.defineProperty(LightBase.prototype, "assetType", {
                get: //@override
                function () {
                    return away.library.AssetType.LIGHT;
                },
                enumerable: true,
                configurable: true
            });

            LightBase.prototype.updateSpecular = function () {
                this._iSpecularR = this._colorR * this._specular;
                this._iSpecularG = this._colorG * this._specular;
                this._iSpecularB = this._colorB * this._specular;
            };

            LightBase.prototype.updateDiffuse = function () {
                this._iDiffuseR = this._colorR * this._diffuse;
                this._iDiffuseG = this._colorG * this._diffuse;
                this._iDiffuseB = this._colorB * this._diffuse;
            };

            Object.defineProperty(LightBase.prototype, "shadowMapper", {
                get: function () {
                    return this._shadowMapper;
                },
                set: function (value) {
                    this._shadowMapper = value;
                    this._shadowMapper.light = this;
                },
                enumerable: true,
                configurable: true
            });

            return LightBase;
        })(away.containers.DisplayObjectContainer);
        lights.LightBase = LightBase;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (lights) {
        var LightProbe = (function (_super) {
            __extends(LightProbe, _super);
            function LightProbe(diffuseMap, specularMap) {
                if (typeof specularMap === "undefined") { specularMap = null; }
                _super.call(this);

                this._pIsEntity = true;

                this._diffuseMap = diffuseMap;
                this._specularMap = specularMap;
            }
            Object.defineProperty(LightProbe.prototype, "diffuseMap", {
                get: function () {
                    return this._diffuseMap;
                },
                set: function (value) {
                    this._diffuseMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightProbe.prototype, "specularMap", {
                get: function () {
                    return this._specularMap;
                },
                set: function (value) {
                    this._specularMap = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @protected
            */
            LightProbe.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.LightProbeNode(this);
            };

            //@override
            LightProbe.prototype.pUpdateBounds = function () {
                this._pBoundsInvalid = false;
            };

            //@override
            LightProbe.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.NullBounds();
            };

            //@override
            LightProbe.prototype.iGetObjectProjectionMatrix = function (entity, camera, target) {
                if (typeof target === "undefined") { target = null; }
                throw new away.errors.Error("Object projection matrices are not supported for LightProbe objects!");
            };
            return LightProbe;
        })(away.lights.LightBase);
        lights.LightProbe = LightProbe;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (lights) {
        var PointLight = (function (_super) {
            __extends(PointLight, _super);
            function PointLight() {
                _super.call(this);
                this._pRadius = 90000;
                this._pFallOff = 100000;

                this._pIsEntity = true;

                this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
            }
            PointLight.prototype.pCreateShadowMapper = function () {
                return new away.lights.CubeMapShadowMapper();
            };

            Object.defineProperty(PointLight.prototype, "radius", {
                get: function () {
                    return this._pRadius;
                },
                set: function (value) {
                    this._pRadius = value;

                    if (this._pRadius < 0) {
                        this._pRadius = 0;
                    } else if (this._pRadius > this._pFallOff) {
                        this._pFallOff = this._pRadius;
                        this.pInvalidateBounds();
                    }
                    this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
                },
                enumerable: true,
                configurable: true
            });


            PointLight.prototype.iFallOffFactor = function () {
                return this._pFallOffFactor;
            };

            Object.defineProperty(PointLight.prototype, "fallOff", {
                get: function () {
                    return this._pFallOff;
                },
                set: function (value) {
                    this._pFallOff = value;

                    if (this._pFallOff < 0)
                        this._pFallOff = 0;

                    if (this._pFallOff < this._pRadius)
                        this._pRadius = this._pFallOff;

                    this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
                    this.pInvalidateBounds();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @protected
            */
            PointLight.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.PointLightNode(this);
            };

            PointLight.prototype.pUpdateBounds = function () {
                this._pBounds.fromSphere(new away.geom.Vector3D(), this._pFallOff);
                this._pBoundsInvalid = false;
            };

            PointLight.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.BoundingSphere();
            };

            PointLight.prototype.iGetObjectProjectionMatrix = function (entity, camera, target) {
                if (typeof target === "undefined") { target = null; }
                var raw = new Array(16);
                var bounds = entity.bounds;
                var m = new away.geom.Matrix3D();

                // todo: do not use lookAt on Light
                m.copyFrom(entity.getRenderSceneTransform(camera));
                m.append(this._pParent.inverseSceneTransform);
                this.lookAt(m.position);

                m.copyFrom(entity.getRenderSceneTransform(camera));
                m.append(this.inverseSceneTransform);

                var box = bounds.aabb;
                var v1 = m.deltaTransformVector(new away.geom.Vector3D(box.left, box.bottom, box.front));
                var v2 = m.deltaTransformVector(new away.geom.Vector3D(box.right, box.top, box.back));
                var d1 = v1.x * v1.x + v1.y * v1.y + v1.z * v1.z;
                var d2 = v2.x * v2.x + v2.y * v2.y + v2.z * v2.z;
                var d = Math.sqrt(d1 > d2 ? d1 : d2);
                var zMin;
                var zMax;

                var z = m.rawData[14];
                zMin = z - d;
                zMax = z + d;

                raw[5] = raw[0] = zMin / d;
                raw[10] = zMax / (zMax - zMin);
                raw[11] = 1;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[12] = raw[13] = raw[15] = 0;
                raw[14] = -zMin * raw[10];

                if (!target)
                    target = new away.geom.Matrix3D();

                target.copyRawDataFrom(raw);
                target.prepend(m);

                return target;
            };
            return PointLight;
        })(away.lights.LightBase);
        lights.PointLight = PointLight;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (lights) {
        var DirectionalLight = (function (_super) {
            __extends(DirectionalLight, _super);
            function DirectionalLight(xDir, yDir, zDir) {
                if (typeof xDir === "undefined") { xDir = 0; }
                if (typeof yDir === "undefined") { yDir = -1; }
                if (typeof zDir === "undefined") { zDir = 1; }
                _super.call(this);

                this._pIsEntity = true;

                this.direction = new away.geom.Vector3D(xDir, yDir, zDir);

                this._sceneDirection = new away.geom.Vector3D();
            }
            Object.defineProperty(DirectionalLight.prototype, "sceneDirection", {
                get: function () {
                    if (this._pSceneTransformDirty) {
                        this.pUpdateSceneTransform();
                    }
                    return this._sceneDirection;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DirectionalLight.prototype, "direction", {
                get: function () {
                    return this._direction;
                },
                set: function (value) {
                    this._direction = value;

                    if (!this._tmpLookAt) {
                        this._tmpLookAt = new away.geom.Vector3D();
                    }
                    this._tmpLookAt.x = this.x + this._direction.x;
                    this._tmpLookAt.y = this.y + this._direction.y;
                    this._tmpLookAt.z = this.z + this._direction.z;

                    this.lookAt(this._tmpLookAt);
                },
                enumerable: true,
                configurable: true
            });


            //@override
            DirectionalLight.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.NullBounds();
            };

            //@override
            DirectionalLight.prototype.pUpdateBounds = function () {
            };

            //@override
            DirectionalLight.prototype.pUpdateSceneTransform = function () {
                _super.prototype.pUpdateSceneTransform.call(this);
                this.sceneTransform.copyColumnTo(2, this._sceneDirection);
                this._sceneDirection.normalize();
            };

            //@override
            DirectionalLight.prototype.pCreateShadowMapper = function () {
                return new away.lights.DirectionalShadowMapper();
            };

            /**
            * @protected
            */
            DirectionalLight.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.DirectionalLightNode(this);
            };

            //override
            DirectionalLight.prototype.iGetObjectProjectionMatrix = function (entity, camera, target) {
                if (typeof target === "undefined") { target = null; }
                var raw = new Array();
                var bounds = entity.bounds;
                var m = new away.geom.Matrix3D();

                m.copyFrom(entity.getRenderSceneTransform(camera));
                m.append(this.inverseSceneTransform);

                if (!this._projAABBPoints) {
                    this._projAABBPoints = [];
                }
                m.transformVectors(bounds.aabbPoints, this._projAABBPoints);

                var xMin = Infinity, xMax = -Infinity;
                var yMin = Infinity, yMax = -Infinity;
                var zMin = Infinity, zMax = -Infinity;
                var d;
                for (var i = 0; i < 24;) {
                    d = this._projAABBPoints[i++];
                    if (d < xMin)
                        xMin = d;
                    if (d > xMax)
                        xMax = d;
                    d = this._projAABBPoints[i++];
                    if (d < yMin)
                        yMin = d;
                    if (d > yMax)
                        yMax = d;
                    d = this._projAABBPoints[i++];
                    if (d < zMin)
                        zMin = d;
                    if (d > zMax)
                        zMax = d;
                }

                var invXRange = 1 / (xMax - xMin);
                var invYRange = 1 / (yMax - yMin);
                var invZRange = 1 / (zMax - zMin);
                raw[0] = 2 * invXRange;
                raw[5] = 2 * invYRange;
                raw[10] = invZRange;
                raw[12] = -(xMax + xMin) * invXRange;
                raw[13] = -(yMax + yMin) * invYRange;
                raw[14] = -zMin * invZRange;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
                raw[15] = 1;

                if (!target) {
                    target = new away.geom.Matrix3D();
                }
                target.copyRawDataFrom(raw);
                target.prepend(m);

                return target;
            };
            return DirectionalLight;
        })(away.lights.LightBase);
        lights.DirectionalLight = DirectionalLight;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (lights) {
        var ShadowMapperBase = (function () {
            function ShadowMapperBase() {
                this._pDepthMapSize = 2048;
                this._autoUpdateShadows = true;
                this._pCasterCollector = this.pCreateCasterCollector();
            }
            ShadowMapperBase.prototype.pCreateCasterCollector = function () {
                return new away.traverse.ShadowCasterCollector();
            };

            Object.defineProperty(ShadowMapperBase.prototype, "autoUpdateShadows", {
                get: function () {
                    return this._autoUpdateShadows;
                },
                set: function (value) {
                    this._autoUpdateShadows = value;
                },
                enumerable: true,
                configurable: true
            });


            ShadowMapperBase.prototype.updateShadows = function () {
                this._iShadowsInvalid = true;
            };

            ShadowMapperBase.prototype.iSetDepthMap = function (depthMap) {
                if (this._depthMap == depthMap) {
                    return;
                }
                if (this._depthMap && !this._explicitDepthMap) {
                    this._depthMap.dispose();
                }
                this._depthMap = depthMap;
                if (this._depthMap) {
                    this._explicitDepthMap = true;
                    this._pDepthMapSize = this._depthMap.width;
                } else {
                    this._explicitDepthMap = false;
                }
            };

            Object.defineProperty(ShadowMapperBase.prototype, "light", {
                get: function () {
                    return this._pLight;
                },
                set: function (value) {
                    this._pLight = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShadowMapperBase.prototype, "depthMap", {
                get: function () {
                    if (!this._depthMap) {
                        this._depthMap = this.pCreateDepthTexture();
                    }
                    return this._depthMap;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShadowMapperBase.prototype, "depthMapSize", {
                get: function () {
                    return this._pDepthMapSize;
                },
                set: function (value) {
                    if (value == this._pDepthMapSize)
                        return;

                    this._pSetDepthMapSize(value);
                },
                enumerable: true,
                configurable: true
            });


            ShadowMapperBase.prototype.dispose = function () {
                this._pCasterCollector = null;

                if (this._depthMap && !this._explicitDepthMap)
                    this._depthMap.dispose();

                this._depthMap = null;
            };

            ShadowMapperBase.prototype.pCreateDepthTexture = function () {
                return new away.textures.RenderTexture(this._pDepthMapSize, this._pDepthMapSize);
            };

            ShadowMapperBase.prototype.iRenderDepthMap = function (stageGL, entityCollector, renderer) {
                this._iShadowsInvalid = false;

                this.pUpdateDepthProjection(entityCollector.camera);

                if (!this._depthMap)
                    this._depthMap = this.pCreateDepthTexture();

                this.pDrawDepthMap(this._depthMap.getTextureForStageGL(stageGL), entityCollector.scene, renderer);
            };

            ShadowMapperBase.prototype.pUpdateDepthProjection = function (viewCamera) {
                throw new away.errors.AbstractMethodError();
            };

            ShadowMapperBase.prototype.pDrawDepthMap = function (target, scene, renderer) {
                throw new away.errors.AbstractMethodError();
            };

            ShadowMapperBase.prototype._pSetDepthMapSize = function (value) {
                this._pDepthMapSize = value;

                if (this._explicitDepthMap) {
                    throw Error("Cannot set depth map size for the current renderer.");
                } else if (this._depthMap) {
                    this._depthMap.dispose();
                    this._depthMap = null;
                }
            };
            return ShadowMapperBase;
        })();
        lights.ShadowMapperBase = ShadowMapperBase;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (lights) {
        var CubeMapShadowMapper = (function (_super) {
            __extends(CubeMapShadowMapper, _super);
            function CubeMapShadowMapper() {
                _super.call(this);

                this._pDepthMapSize = 512;
                this._needsRender = [];
                this.initCameras();
            }
            CubeMapShadowMapper.prototype.initCameras = function () {
                this._depthCameras = [];
                this._projections = [];

                // posX, negX, posY, negY, posZ, negZ
                this.addCamera(0, 90, 0);
                this.addCamera(0, -90, 0);
                this.addCamera(-90, 0, 0);
                this.addCamera(90, 0, 0);
                this.addCamera(0, 0, 0);
                this.addCamera(0, 180, 0);
            };

            CubeMapShadowMapper.prototype.addCamera = function (rotationX, rotationY, rotationZ) {
                var cam = new away.entities.Camera();
                cam.rotationX = rotationX;
                cam.rotationY = rotationY;
                cam.rotationZ = rotationZ;
                cam.projection.near = .01;

                var projection = cam.projection;
                projection.fieldOfView = 90;
                this._projections.push(projection);
                cam.projection.iAspectRatio = 1;
                this._depthCameras.push(cam);
            };

            //@override
            CubeMapShadowMapper.prototype.pCreateDepthTexture = function () {
                throw new away.errors.PartialImplementationError();
                /*
                return new away.textures.RenderCubeTexture( this._depthMapSize );
                */
            };

            //@override
            CubeMapShadowMapper.prototype.pUpdateDepthProjection = function (viewCamera) {
                var light = (this._pLight);
                var maxDistance = light._pFallOff;
                var pos = this._pLight.scenePosition;

                for (var i = 0; i < 6; ++i) {
                    this._projections[i].far = maxDistance;
                    this._depthCameras[i].transform.position = pos;
                    this._needsRender[i] = true;
                }
            };

            //@override
            CubeMapShadowMapper.prototype.pDrawDepthMap = function (target, scene, renderer) {
                for (var i = 0; i < 6; ++i) {
                    if (this._needsRender[i]) {
                        this._pCasterCollector.camera = this._depthCameras[i];
                        this._pCasterCollector.clear();
                        scene.traversePartitions(this._pCasterCollector);
                        renderer._iRender(this._pCasterCollector, target, null, i);
                    }
                }
            };
            return CubeMapShadowMapper;
        })(away.lights.ShadowMapperBase);
        lights.CubeMapShadowMapper = CubeMapShadowMapper;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts" />
    (function (lights) {
        var DirectionalShadowMapper = (function (_super) {
            __extends(DirectionalShadowMapper, _super);
            function DirectionalShadowMapper() {
                _super.call(this);
                this._pLightOffset = 10000;
                this._pSnap = 64;
                this._pCullPlanes = [];
                this._pOverallDepthProjection = new away.projections.FreeMatrixProjection();
                this._pOverallDepthCamera = new away.entities.Camera(this._pOverallDepthProjection);
                this._pLocalFrustum = [];
                this._pMatrix = new away.geom.Matrix3D();
            }
            Object.defineProperty(DirectionalShadowMapper.prototype, "snap", {
                get: function () {
                    return this._pSnap;
                },
                set: function (value) {
                    this._pSnap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DirectionalShadowMapper.prototype, "lightOffset", {
                get: function () {
                    return this._pLightOffset;
                },
                set: function (value) {
                    this._pLightOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DirectionalShadowMapper.prototype, "iDepthProjection", {
                get: //@arcane
                function () {
                    return this._pOverallDepthCamera.viewProjection;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DirectionalShadowMapper.prototype, "depth", {
                get: //@arcane
                function () {
                    return this._pMaxZ - this._pMinZ;
                },
                enumerable: true,
                configurable: true
            });

            //@override
            DirectionalShadowMapper.prototype.pDrawDepthMap = function (target, scene, renderer) {
                this._pCasterCollector.camera = this._pOverallDepthCamera;
                this._pCasterCollector.cullPlanes = this._pCullPlanes;
                this._pCasterCollector.clear();
                scene.traversePartitions(this._pCasterCollector);
                renderer._iRender(this._pCasterCollector, target);
            };

            //@protected
            DirectionalShadowMapper.prototype.pUpdateCullPlanes = function (viewCamera) {
                var lightFrustumPlanes = this._pOverallDepthCamera.frustumPlanes;
                var viewFrustumPlanes = viewCamera.frustumPlanes;
                this._pCullPlanes.length = 4;

                this._pCullPlanes[0] = lightFrustumPlanes[0];
                this._pCullPlanes[1] = lightFrustumPlanes[1];
                this._pCullPlanes[2] = lightFrustumPlanes[2];
                this._pCullPlanes[3] = lightFrustumPlanes[3];

                var light = this._pLight;
                var dir = light.sceneDirection;
                var dirX = dir.x;
                var dirY = dir.y;
                var dirZ = dir.z;
                var j = 4;
                for (var i = 0; i < 6; ++i) {
                    var plane = viewFrustumPlanes[i];
                    if (plane.a * dirX + plane.b * dirY + plane.c * dirZ < 0) {
                        this._pCullPlanes[j++] = plane;
                    }
                }
            };

            //@override
            DirectionalShadowMapper.prototype.pUpdateDepthProjection = function (viewCamera) {
                this.pUpdateProjectionFromFrustumCorners(viewCamera, viewCamera.projection.frustumCorners, this._pMatrix);
                this._pOverallDepthProjection.matrix = this._pMatrix;
                this.pUpdateCullPlanes(viewCamera);
            };

            DirectionalShadowMapper.prototype.pUpdateProjectionFromFrustumCorners = function (viewCamera, corners, matrix) {
                var raw = new Array();
                var dir;
                var x, y, z;
                var minX, minY;
                var maxX, maxY;
                var i;

                var light = this._pLight;
                dir = light.sceneDirection;
                this._pOverallDepthCamera.transform.matrix3D = this._pLight.sceneTransform;
                x = Math.floor((viewCamera.x - dir.x * this._pLightOffset) / this._pSnap) * this._pSnap;
                y = Math.floor((viewCamera.y - dir.y * this._pLightOffset) / this._pSnap) * this._pSnap;
                z = Math.floor((viewCamera.z - dir.z * this._pLightOffset) / this._pSnap) * this._pSnap;
                this._pOverallDepthCamera.x = x;
                this._pOverallDepthCamera.y = y;
                this._pOverallDepthCamera.z = z;

                this._pMatrix.copyFrom(this._pOverallDepthCamera.inverseSceneTransform);
                this._pMatrix.prepend(viewCamera.sceneTransform);
                this._pMatrix.transformVectors(corners, this._pLocalFrustum);

                minX = maxX = this._pLocalFrustum[0];
                minY = maxY = this._pLocalFrustum[1];
                this._pMaxZ = this._pLocalFrustum[2];

                i = 3;
                while (i < 24) {
                    x = this._pLocalFrustum[i];
                    y = this._pLocalFrustum[i + 1];
                    z = this._pLocalFrustum[i + 2];
                    if (x < minX)
                        minX = x;
                    if (x > maxX)
                        maxX = x;
                    if (y < minY)
                        minY = y;
                    if (y > maxY)
                        maxY = y;
                    if (z > this._pMaxZ)
                        this._pMaxZ = z;
                    i += 3;
                }
                this._pMinZ = 1;

                var w = maxX - minX;
                var h = maxY - minY;
                var d = 1 / (this._pMaxZ - this._pMinZ);

                if (minX < 0) {
                    minX -= this._pSnap;
                }
                if (minY < 0) {
                    minY -= this._pSnap;
                }
                minX = Math.floor(minX / this._pSnap) * this._pSnap;
                minY = Math.floor(minY / this._pSnap) * this._pSnap;

                var snap2 = 2 * this._pSnap;
                w = Math.floor(w / snap2 + 2) * snap2;
                h = Math.floor(h / snap2 + 2) * snap2;

                maxX = minX + w;
                maxY = minY + h;

                w = 1 / w;
                h = 1 / h;

                raw[0] = 2 * w;
                raw[5] = 2 * h;
                raw[10] = d;
                raw[12] = -(maxX + minX) * w;
                raw[13] = -(maxY + minY) * h;
                raw[14] = -this._pMinZ * d;
                raw[15] = 1;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;

                matrix.copyRawDataFrom(raw);
            };
            return DirectionalShadowMapper;
        })(away.lights.ShadowMapperBase);
        lights.DirectionalShadowMapper = DirectionalShadowMapper;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    (function (lights) {
        var Camera = away.entities.Camera;
        var FreeMatrixProjection = away.projections.FreeMatrixProjection;
        var ProjectionBase = away.projections.ProjectionBase;
        var Scene = away.containers.Scene;
        var Matrix3DUtils = away.geom.Matrix3DUtils;
        var DepthRenderer = away.render.DepthRenderer;

        var TextureBase = away.gl.TextureBase;
        var Event = away.events.Event;
        var EventDispatcher = away.events.EventDispatcher;
        
        var Matrix3D = away.geom.Matrix3D;
        var Rectangle = away.geom.Rectangle;

        var CascadeShadowMapper = (function (_super) {
            __extends(CascadeShadowMapper, _super);
            function CascadeShadowMapper(numCascades) {
                if (typeof numCascades === "undefined") { numCascades = 3; }
                _super.call(this);
                this._pScissorRectsInvalid = true;

                if (numCascades < 1 || numCascades > 4)
                    throw new Error("numCascades must be an integer between 1 and 4");

                this._numCascades = numCascades;
                this._changeDispatcher = new EventDispatcher(this);
                this.init();
            }
            CascadeShadowMapper.prototype.getSplitRatio = function (index/*uint*/ ) {
                return this._splitRatios[index];
            };

            CascadeShadowMapper.prototype.setSplitRatio = function (index/*uint*/ , value) {
                if (value < 0)
                    value = 0;
else if (value > 1)
                    value = 1;

                if (index >= this._numCascades)
                    throw new Error("index must be smaller than the number of cascades!");

                this._splitRatios[index] = value;
            };

            CascadeShadowMapper.prototype.getDepthProjections = function (partition/*uint*/ ) {
                return this._depthCameras[partition].viewProjection;
            };

            CascadeShadowMapper.prototype.init = function () {
                this._splitRatios = new Array(this._numCascades);
                this._nearPlaneDistances = new Array(this._numCascades);

                var s = 1;
                for (var i = this._numCascades - 1; i >= 0; --i) {
                    this._splitRatios[i] = s;
                    s *= .4;
                }

                this._texOffsetsX = Array(-1, 1, -1, 1);
                this._texOffsetsY = Array(1, 1, -1, -1);
                this._pScissorRects = new Array(4);
                this._depthLenses = new Array();
                this._depthCameras = new Array();

                for (i = 0; i < this._numCascades; ++i) {
                    this._depthLenses[i] = new FreeMatrixProjection();
                    this._depthCameras[i] = new Camera(this._depthLenses[i]);
                }
            };

            CascadeShadowMapper.prototype._pSetDepthMapSize = function (value/*uint*/ ) {
                _super.prototype._pSetDepthMapSize.call(this, value);

                this.invalidateScissorRects();
            };

            CascadeShadowMapper.prototype.invalidateScissorRects = function () {
                this._pScissorRectsInvalid = true;
            };

            Object.defineProperty(CascadeShadowMapper.prototype, "numCascades", {
                get: function () {
                    return this._numCascades;
                },
                set: function (value/*int*/ ) {
                    if (value == this._numCascades)
                        return;
                    if (value < 1 || value > 4)
                        throw new Error("numCascades must be an integer between 1 and 4");
                    this._numCascades = value;
                    this.invalidateScissorRects();
                    this.init();
                    this.dispatchEvent(new Event(Event.CHANGE));
                },
                enumerable: true,
                configurable: true
            });


            CascadeShadowMapper.prototype.pDrawDepthMap = function (target, scene, renderer) {
                if (this._pScissorRectsInvalid)
                    this.updateScissorRects();

                this._pCasterCollector.cullPlanes = this._pCullPlanes;
                this._pCasterCollector.camera = this._pOverallDepthCamera;
                this._pCasterCollector.clear();
                scene.traversePartitions(this._pCasterCollector);

                renderer.iRenderCascades(this._pCasterCollector, target, this._numCascades, this._pScissorRects, this._depthCameras);
            };

            CascadeShadowMapper.prototype.updateScissorRects = function () {
                var half = this._pDepthMapSize * .5;

                this._pScissorRects[0] = new Rectangle(0, 0, half, half);
                this._pScissorRects[1] = new Rectangle(half, 0, half, half);
                this._pScissorRects[2] = new Rectangle(0, half, half, half);
                this._pScissorRects[3] = new Rectangle(half, half, half, half);

                this._pScissorRectsInvalid = false;
            };

            CascadeShadowMapper.prototype.pUpdateDepthProjection = function (viewCamera) {
                var matrix;
                var projection = viewCamera.projection;
                var projectionNear = projection.near;
                var projectionRange = projection.far - projectionNear;

                this.pUpdateProjectionFromFrustumCorners(viewCamera, viewCamera.projection.frustumCorners, this._pMatrix);
                this._pMatrix.appendScale(.96, .96, 1);
                this._pOverallDepthProjection.matrix = this._pMatrix;
                this.pUpdateCullPlanes(viewCamera);

                for (var i = 0; i < this._numCascades; ++i) {
                    matrix = this._depthLenses[i].matrix;

                    this._nearPlaneDistances[i] = projectionNear + this._splitRatios[i] * projectionRange;
                    this._depthCameras[i].transform = this._pOverallDepthCamera.transform;

                    this.updateProjectionPartition(matrix, this._splitRatios[i], this._texOffsetsX[i], this._texOffsetsY[i]);

                    this._depthLenses[i].matrix = matrix;
                }
            };

            CascadeShadowMapper.prototype.updateProjectionPartition = function (matrix, splitRatio, texOffsetX, texOffsetY) {
                var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
                var xN, yN, zN;
                var xF, yF, zF;
                var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, minZ;
                var maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY, maxZ = Number.NEGATIVE_INFINITY;
                var i = 0;

                while (i < 12) {
                    xN = this._pLocalFrustum[i];
                    yN = this._pLocalFrustum[i + 1];
                    zN = this._pLocalFrustum[i + 2];
                    xF = xN + (this._pLocalFrustum[i + 12] - xN) * splitRatio;
                    yF = yN + (this._pLocalFrustum[i + 13] - yN) * splitRatio;
                    zF = zN + (this._pLocalFrustum[i + 14] - zN) * splitRatio;
                    if (xN < minX)
                        minX = xN;
                    if (xN > maxX)
                        maxX = xN;
                    if (yN < minY)
                        minY = yN;
                    if (yN > maxY)
                        maxY = yN;
                    if (zN > maxZ)
                        maxZ = zN;
                    if (xF < minX)
                        minX = xF;
                    if (xF > maxX)
                        maxX = xF;
                    if (yF < minY)
                        minY = yF;
                    if (yF > maxY)
                        maxY = yF;
                    if (zF > maxZ)
                        maxZ = zF;
                    i += 3;
                }

                minZ = 1;

                var w = (maxX - minX);
                var h = (maxY - minY);
                var d = 1 / (maxZ - minZ);

                if (minX < 0)
                    minX -= this._pSnap;
                if (minY < 0)
                    minY -= this._pSnap;
                minX = Math.floor(minX / this._pSnap) * this._pSnap;
                minY = Math.floor(minY / this._pSnap) * this._pSnap;

                var snap2 = 2 * this._pSnap;
                w = Math.floor(w / snap2 + 1) * snap2;
                h = Math.floor(h / snap2 + 1) * snap2;

                maxX = minX + w;
                maxY = minY + h;

                w = 1 / w;
                h = 1 / h;

                raw[0] = 2 * w;
                raw[5] = 2 * h;
                raw[10] = d;
                raw[12] = -(maxX + minX) * w;
                raw[13] = -(maxY + minY) * h;
                raw[14] = -minZ * d;
                raw[15] = 1;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;

                matrix.copyRawDataFrom(raw);
                matrix.appendScale(.96, .96, 1);
                matrix.appendTranslation(texOffsetX, texOffsetY, 0);
                matrix.appendScale(.5, .5, 1);
            };

            CascadeShadowMapper.prototype.addEventListener = function (type, listener) {
                this._changeDispatcher.addEventListener(type, listener);
            };

            CascadeShadowMapper.prototype.removeEventListener = function (type, listener) {
                this._changeDispatcher.removeEventListener(type, listener);
            };

            CascadeShadowMapper.prototype.dispatchEvent = function (event) {
                return this._changeDispatcher.dispatchEvent(event);
            };

            CascadeShadowMapper.prototype.hasEventListener = function (type) {
                return this._changeDispatcher.hasEventListener(type);
            };

            Object.defineProperty(CascadeShadowMapper.prototype, "_iNearPlaneDistances", {
                get: function () {
                    return this._nearPlaneDistances;
                },
                enumerable: true,
                configurable: true
            });
            return CascadeShadowMapper;
        })(lights.DirectionalShadowMapper);
        lights.CascadeShadowMapper = CascadeShadowMapper;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts" />
    (function (lights) {
        var Camera = away.entities.Camera;

        var NearDirectionalShadowMapper = (function (_super) {
            __extends(NearDirectionalShadowMapper, _super);
            function NearDirectionalShadowMapper(coverageRatio) {
                if (typeof coverageRatio === "undefined") { coverageRatio = .5; }
                _super.call(this);
                this.coverageRatio = coverageRatio;
            }
            Object.defineProperty(NearDirectionalShadowMapper.prototype, "coverageRatio", {
                get: /**
                * A value between 0 and 1 to indicate the ratio of the view frustum that needs to be covered by the shadow map.
                */
                function () {
                    return this._coverageRatio;
                },
                set: function (value) {
                    if (value > 1)
                        value = 1;
else if (value < 0)
                        value = 0;

                    this._coverageRatio = value;
                },
                enumerable: true,
                configurable: true
            });


            NearDirectionalShadowMapper.prototype.pUpdateDepthProjection = function (viewCamera) {
                var corners = viewCamera.projection.frustumCorners;

                for (var i = 0; i < 12; ++i) {
                    var v = corners[i];
                    this._pLocalFrustum[i] = v;
                    this._pLocalFrustum[i + 12] = v + (corners[i + 12] - v) * this._coverageRatio;
                }

                this.pUpdateProjectionFromFrustumCorners(viewCamera, this._pLocalFrustum, this._pMatrix);
                this._pOverallDepthProjection.matrix = this._pMatrix;
            };
            return NearDirectionalShadowMapper;
        })(lights.DirectionalShadowMapper);
        lights.NearDirectionalShadowMapper = NearDirectionalShadowMapper;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    // Reference note: http://www.w3schools.com/jsref/dom_obj_event.asp
    (function (managers) {
        //import away3d.arcane;
        //import away3d.containers.ObjectContainer3D;
        //import away3d.containers.View;
        //import away3d.core.pick.IPicker;
        //import away3d.core.pick.PickingCollisionVO;
        //import away3d.core.pick.PickingType;
        //import away3d.events.MouseEvent3D;
        //import flash.display.DisplayObject;
        //import flash.display.DisplayObjectContainer;
        //import flash.display.Stage;
        //import flash.events.MouseEvent;
        //import flash.geom.Vector3D;
        //import flash.utils.Dictionary;
        //use namespace arcane;
        /**
        * Mouse3DManager enforces a singleton pattern and is not intended to be instanced.
        * it provides a manager class for detecting 3D mouse hits on View objects and sending out 3D mouse events.
        */
        var Mouse3DManager = (function () {
            /**
            * Creates a new <code>Mouse3DManager</code> object.
            */
            function Mouse3DManager() {
                this._updateDirty = true;
                this._nullVector = new away.geom.Vector3D();
                this._mousePicker = away.pick.PickingType.RAYCAST_FIRST_ENCOUNTERED;
                this._childDepth = 0;
                if (!Mouse3DManager._view3Ds) {
                    Mouse3DManager._view3Ds = new Object();
                    Mouse3DManager._view3DLookup = new Array();
                }
            }
            // ---------------------------------------------------------------------
            // Interface.
            // ---------------------------------------------------------------------
            // TODO: required dependency stageGL
            Mouse3DManager.prototype.updateCollider = function (view) {
                throw new away.errors.PartialImplementationError('stageGL');
                /*
                this._previousCollidingView = this._collidingView;
                
                if (view) {
                // Clear the current colliding objects for multiple views if backBuffer just cleared
                if (view.stageGL.bufferClear)
                _collidingViewObjects = new Vector.<PickingCollisionVO>(_viewCount);
                
                if (!view.shareContext) {
                if (view == _activeView && (_forceMouseMove || _updateDirty)) { // If forceMouseMove is off, and no 2D mouse events dirtied the update, don't update either.
                _collidingObject = _mousePicker.getViewCollision(view.mouseX, view.mouseY, view);
                }
                } else {
                if (view.getBounds(view.parent).contains(view.mouseX + view.x, view.mouseY + view.y)) {
                if (!_collidingViewObjects)
                _collidingViewObjects = new Vector.<PickingCollisionVO>(_viewCount);
                _collidingObject = _collidingViewObjects[_view3Ds[view]] = _mousePicker.getViewCollision(view.mouseX, view.mouseY, view);
                }
                }
                }
                */
            };

            Mouse3DManager.prototype.fireMouseEvents = function () {
                throw new away.errors.PartialImplementationError('View().layeredView');
                /*
                
                var i:number;
                var len:number;
                var event:away.events.MouseEvent3D;
                var dispatcher:away.containers.ObjectContainer3D;
                
                
                
                // If multiple view are used, determine the best hit based on the depth intersection.
                if ( Mouse3DManager._collidingViewObjects )
                {
                Mouse3DManager._pCollidingObject = null;//_collidingObject = null;
                
                // Get the top-most view colliding object
                var distance:number = Infinity;
                var view:away.containers.View;
                
                for (var v:number = Mouse3DManager._viewCount - 1; v >= 0; v--)
                {
                view = _view3DLookup[v];
                
                if ( Mouse3DManager._collidingViewObjects[v] && (view.layeredView || Mouse3DManager._collidingViewObjects[v].rayEntryDistance < distance))
                {
                
                distance = Mouse3DManager._collidingViewObjects[v].rayEntryDistance;
                
                Mouse3DManager._pCollidingObject = Mouse3DManager._collidingViewObjects[v];//_collidingObject = Mouse3DManager._collidingViewObjects[v];
                
                if (view.layeredView)
                {
                
                break;
                
                }
                
                }
                }
                }
                
                // If colliding object has changed, queue over/out events.
                if (Mouse3DManager._pCollidingObject  != Mouse3DManager._previousCollidingObject)
                {
                
                if (Mouse3DManager._previousCollidingObject)
                {
                
                this.queueDispatch(Mouse3DManager._mouseOut, this._mouseMoveEvent, Mouse3DManager._previousCollidingObject);
                
                }
                
                if (Mouse3DManager._pCollidingObject)
                {
                this.queueDispatch(Mouse3DManager._mouseOver, this._mouseMoveEvent, Mouse3DManager._pCollidingObject );
                }
                
                }
                
                // Fire mouse move events here if forceMouseMove is on.
                if ( this._forceMouseMove && Mouse3DManager._pCollidingObject)
                {
                
                this.queueDispatch( Mouse3DManager._mouseMove, this._mouseMoveEvent, Mouse3DManager._pCollidingObject);
                
                }
                
                
                // Dispatch all queued events.
                len = Mouse3DManager._queuedEvents.length;
                
                for (i = 0; i < len; ++i)
                {
                // Only dispatch from first implicitly enabled object ( one that is not a child of a mouseChildren = false hierarchy ).
                event = Mouse3DManager._queuedEvents[i];
                dispatcher = event.object;
                
                while (dispatcher && ! dispatcher._iAncestorsAllowMouseEnabled )
                {
                
                dispatcher = dispatcher.parent;
                
                }
                
                
                if (dispatcher)
                {
                
                dispatcher.dispatchEvent(event);
                
                }
                
                }
                Mouse3DManager._queuedEvents.length = 0;
                
                this._updateDirty = false;
                Mouse3DManager._previousCollidingObject = Mouse3DManager._pCollidingObject;//_collidingObject;
                //*/
            };

            Mouse3DManager.prototype.addViewLayer = function (view) {
                throw new away.errors.PartialImplementationError('StageGL, Stage, DisplayObjectContainer ( as3 / native ) ');
                /*
                var stg:Stage = view.stage;
                
                // Add instance to mouse3dmanager to fire mouse events for multiple views
                if (!view.stageGL.mouse3DManager)
                view.stageGL.mouse3DManager = this;
                
                if (!hasKey(view))
                _view3Ds[view] = 0;
                
                _childDepth = 0;
                traverseDisplayObjects(stg);
                _viewCount = _childDepth;
                */
            };

            Mouse3DManager.prototype.enableMouseListeners = function (view) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
                /*
                view.addEventListener(MouseEvent.CLICK, onClick);
                view.addEventListener(MouseEvent.DOUBLE_CLICK, onDoubleClick);
                view.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);
                view.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMove);
                view.addEventListener(MouseEvent.MOUSE_UP, onMouseUp);
                view.addEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheel);
                view.addEventListener(MouseEvent.MOUSE_OVER, onMouseOver);
                view.addEventListener(MouseEvent.MOUSE_OUT, onMouseOut);
                */
            };

            Mouse3DManager.prototype.disableMouseListeners = function (view) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
                /*
                view.removeEventListener(MouseEvent.CLICK, onClick);
                view.removeEventListener(MouseEvent.DOUBLE_CLICK, onDoubleClick);
                view.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);
                view.removeEventListener(MouseEvent.MOUSE_MOVE, onMouseMove);
                view.removeEventListener(MouseEvent.MOUSE_UP, onMouseUp);
                view.removeEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheel);
                view.removeEventListener(MouseEvent.MOUSE_OVER, onMouseOver);
                view.removeEventListener(MouseEvent.MOUSE_OUT, onMouseOut);
                */
            };

            Mouse3DManager.prototype.dispose = function () {
                this._mousePicker.dispose();
            };

            // ---------------------------------------------------------------------
            // Private.
            // ---------------------------------------------------------------------
            Mouse3DManager.prototype.queueDispatch = function (event, sourceEvent, collider) {
                if (typeof collider === "undefined") { collider = null; }
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
                /*
                // 2D properties.
                event.ctrlKey = sourceEvent.ctrlKey;
                event.altKey = sourceEvent.altKey;
                event.shiftKey = sourceEvent.shiftKey;
                event.delta = sourceEvent.delta;
                event.screenX = sourceEvent.localX;
                event.screenY = sourceEvent.localY;
                
                collider ||= _collidingObject;
                
                // 3D properties.
                if (collider) {
                // Object.
                event.object = collider.entity;
                event.renderable = collider.renderable;
                // UV.
                event.uv = collider.uv;
                // Position.
                event.localPosition = collider.localPosition? collider.localPosition.clone() : null;
                // Normal.
                event.localNormal = collider.localNormal? collider.localNormal.clone() : null;
                // Face index.
                event.index = collider.index;
                // SubGeometryIndex.
                event.subGeometryIndex = collider.subGeometryIndex;
                
                } else {
                // Set all to null.
                event.uv = null;
                event.object = null;
                event.localPosition = _nullVector;
                event.localNormal = _nullVector;
                event.index = 0;
                event.subGeometryIndex = 0;
                }
                
                // Store event to be dispatched later.
                _queuedEvents.push(event);
                */
            };

            Mouse3DManager.prototype.reThrowEvent = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent - AS3 <> JS Conversion');
            };

            Mouse3DManager.prototype.hasKey = function (view) {
                for (var v in Mouse3DManager._view3Ds) {
                    if (v === view) {
                        return true;
                    }
                }

                return false;
            };

            Mouse3DManager.prototype.traverseDisplayObjects = function (container) {
                throw new away.errors.PartialImplementationError('DisplayObjectContainer ( as3 / native ) as3 <> JS Conversion');
                /*
                var childCount:number = container.numChildren;
                var c:number = 0;
                var child:DisplayObject;
                for (c = 0; c < childCount; c++) {
                child = container.getChildAt(c);
                for (var v:* in _view3Ds) {
                if (child == v) {
                _view3Ds[child] = _childDepth;
                _view3DLookup[_childDepth] = v;
                _childDepth++;
                }
                }
                if (child is DisplayObjectContainer)
                traverseDisplayObjects(child as DisplayObjectContainer);
                }
                */
            };

            // ---------------------------------------------------------------------
            // Listeners.
            // ---------------------------------------------------------------------
            Mouse3DManager.prototype.onMouseMove = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
                /*
                if (Mouse3DManager._pCollidingObject)
                {
                
                this.queueDispatch(Mouse3DManager._mouseMove, this._mouseMoveEvent = event);
                
                }
                else
                {
                
                this.reThrowEvent(event);
                
                }
                
                this._updateDirty = true;
                */
            };

            Mouse3DManager.prototype.onMouseOut = function (event) {
                this._activeView = null;

                if (Mouse3DManager._pCollidingObject) {
                    this.queueDispatch(Mouse3DManager._mouseOut, event, Mouse3DManager._pCollidingObject);
                }

                this._updateDirty = true;

                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
            };

            Mouse3DManager.prototype.onMouseOver = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
            };

            Mouse3DManager.prototype.onClick = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
            };

            Mouse3DManager.prototype.onDoubleClick = function (event) {
                if (Mouse3DManager._pCollidingObject) {
                    this.queueDispatch(Mouse3DManager._mouseDoubleClick, event);
                } else {
                    this.reThrowEvent(event);
                }

                this._updateDirty = true;
            };

            Mouse3DManager.prototype.onMouseDown = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
            };

            Mouse3DManager.prototype.onMouseUp = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
            };

            Mouse3DManager.prototype.onMouseWheel = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
            };

            Object.defineProperty(Mouse3DManager.prototype, "forceMouseMove", {
                get: // ---------------------------------------------------------------------
                // Getters & setters.
                // ---------------------------------------------------------------------
                function () {
                    return this._forceMouseMove;
                },
                set: function (value) {
                    this._forceMouseMove = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Mouse3DManager.prototype, "mousePicker", {
                get: function () {
                    return this._mousePicker;
                },
                set: function (value) {
                    this._mousePicker = value;
                },
                enumerable: true,
                configurable: true
            });

            Mouse3DManager._viewCount = 0;

            Mouse3DManager._queuedEvents = new Array();

            Mouse3DManager._mouseUp = new away.events.MouseEvent3D(away.events.MouseEvent3D.MOUSE_UP);
            Mouse3DManager._mouseClick = new away.events.MouseEvent3D(away.events.MouseEvent3D.CLICK);
            Mouse3DManager._mouseOut = new away.events.MouseEvent3D(away.events.MouseEvent3D.MOUSE_OUT);
            Mouse3DManager._mouseDown = new away.events.MouseEvent3D(away.events.MouseEvent3D.MOUSE_DOWN);
            Mouse3DManager._mouseMove = new away.events.MouseEvent3D(away.events.MouseEvent3D.MOUSE_MOVE);
            Mouse3DManager._mouseOver = new away.events.MouseEvent3D(away.events.MouseEvent3D.MOUSE_OVER);
            Mouse3DManager._mouseWheel = new away.events.MouseEvent3D(away.events.MouseEvent3D.MOUSE_WHEEL);
            Mouse3DManager._mouseDoubleClick = new away.events.MouseEvent3D(away.events.MouseEvent3D.DOUBLE_CLICK);

            Mouse3DManager._previousCollidingView = -1;
            Mouse3DManager._collidingView = -1;
            return Mouse3DManager;
        })();
        managers.Mouse3DManager = Mouse3DManager;
    })(away.managers || (away.managers = {}));
    var managers = away.managers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (managers) {
        var StageGLEvent = away.events.StageGLEvent;

        var AGALProgramCache = away.managers.AGALProgramCache;
        var StageGL = away.base.StageGL;

        var AGALProgramCache = (function () {
            function AGALProgramCache(stageGL, agalProgramCacheSingletonEnforcer) {
                if (!agalProgramCacheSingletonEnforcer)
                    throw new Error("This class is a multiton and cannot be instantiated manually. Use StageGLManager.getInstance instead.");

                this._stageGL = stageGL;

                this._program3Ds = new Object();
                this._ids = new Object();
                this._usages = new Object();
                this._keys = new Object();
            }
            AGALProgramCache.getInstance = function (stageGL) {
                var index = stageGL._iStageGLIndex;

                if (AGALProgramCache._instances == null)
                    AGALProgramCache._instances = new Array(8);

                if (!AGALProgramCache._instances[index]) {
                    AGALProgramCache._instances[index] = new AGALProgramCache(stageGL, new AGALProgramCacheSingletonEnforcer());

                    stageGL.addEventListener(StageGLEvent.CONTEXTGL_DISPOSED, AGALProgramCache.onContextGLDisposed);
                    stageGL.addEventListener(StageGLEvent.CONTEXTGL_CREATED, AGALProgramCache.onContextGLDisposed);
                    stageGL.addEventListener(StageGLEvent.CONTEXTGL_RECREATED, AGALProgramCache.onContextGLDisposed);
                }

                return AGALProgramCache._instances[index];
            };

            AGALProgramCache.getInstanceFromIndex = function (index) {
                if (!AGALProgramCache._instances[index])
                    throw new Error("Instance not created yet!");

                return AGALProgramCache._instances[index];
            };

            AGALProgramCache.onContextGLDisposed = function (event) {
                var stageGL = event.target;

                var index = stageGL._iStageGLIndex;

                AGALProgramCache._instances[index].dispose();
                AGALProgramCache._instances[index] = null;

                stageGL.removeEventListener(StageGLEvent.CONTEXTGL_DISPOSED, AGALProgramCache.onContextGLDisposed);
                stageGL.removeEventListener(StageGLEvent.CONTEXTGL_CREATED, AGALProgramCache.onContextGLDisposed);
                stageGL.removeEventListener(StageGLEvent.CONTEXTGL_RECREATED, AGALProgramCache.onContextGLDisposed);
            };

            AGALProgramCache.prototype.dispose = function () {
                for (var key in this._program3Ds)
                    this.destroyProgram(key);

                this._keys = null;
                this._program3Ds = null;
                this._usages = null;
            };

            AGALProgramCache.prototype.setProgram = function (pass, vertexCode, fragmentCode) {
                var stageIndex = this._stageGL._iStageGLIndex;
                var program;
                var key = this.getKey(vertexCode, fragmentCode);

                if (this._program3Ds[key] == null) {
                    this._keys[AGALProgramCache._currentId] = key;
                    this._usages[AGALProgramCache._currentId] = 0;
                    this._ids[key] = AGALProgramCache._currentId;
                    ++AGALProgramCache._currentId;

                    program = this._stageGL.contextGL.createProgram();

                    //away.Debug.throwPIR( 'AGALProgramCache' , 'setProgram' , 'Dependency: AGALMiniAssembler.assemble');
                    //TODO: implement AGAL <> GLSL
                    //var vertexByteCode:ByteArray = new AGALMiniAssembler(Debug.active).assemble(ContextGLProgramType.VERTEX, vertexCode);
                    //var fragmentByteCode:ByteArray = new AGALMiniAssembler(Debug.active).assemble(ContextGLProgramType.FRAGMENT, fragmentCode);
                    //program.upload(vertexByteCode, fragmentByteCode);
                    /*
                    var vertexByteCode  : ByteArray = new AGLSLCompiler().assemble( ContextGLProgramType.VERTEX , vertexCode );
                    var fragmentByteCode: ByteArray = new AGLSLCompiler().assemble( ContextGLProgramType.FRAGMENT , fragmentCode );
                    
                    program.uploadGLSL(vertexByteCode, fragmentByteCode);
                    
                    */
                    var vertCompiler = new aglsl.AGLSLCompiler();
                    var fragCompiler = new aglsl.AGLSLCompiler();

                    var vertString = vertCompiler.compile(away.gl.ContextGLProgramType.VERTEX, vertexCode);
                    var fragString = fragCompiler.compile(away.gl.ContextGLProgramType.FRAGMENT, fragmentCode);

                    console.log('===GLSL=========================================================');
                    console.log('vertString');
                    console.log(vertString);
                    console.log('fragString');
                    console.log(fragString);

                    console.log('===AGAL=========================================================');
                    console.log('vertexCode');
                    console.log(vertexCode);
                    console.log('fragmentCode');
                    console.log(fragmentCode);

                    program.upload(vertString, fragString);

                    /*
                    
                    var vertCompiler:aglsl.AGLSLCompiler = new aglsl.AGLSLCompiler();
                    var fragCompiler:aglsl.AGLSLCompiler = new aglsl.AGLSLCompiler();
                    
                    var vertString : string = vertCompiler.compile( away.gl.ContextGLProgramType.VERTEX, this.pGetVertexCode() );
                    var fragString : string = fragCompiler.compile( away.gl.ContextGLProgramType.FRAGMENT, this.pGetFragmentCode() );
                    
                    this._program3D.upload( vertString , fragString );
                    
                    */
                    this._program3Ds[key] = program;
                }

                var oldId = pass._iProgramids[stageIndex];
                var newId = this._ids[key];

                if (oldId != newId) {
                    if (oldId >= 0)
                        this.freeProgram(oldId);

                    this._usages[newId]++;
                }

                pass._iProgramids[stageIndex] = newId;
                pass._iPrograms[stageIndex] = this._program3Ds[key];
            };

            AGALProgramCache.prototype.freeProgram = function (programId) {
                this._usages[programId]--;

                if (this._usages[programId] == 0)
                    this.destroyProgram(this._keys[programId]);
            };

            AGALProgramCache.prototype.destroyProgram = function (key) {
                this._program3Ds[key].dispose();
                this._program3Ds[key] = null;

                delete this._program3Ds[key];

                this._ids[key] = -1;
            };

            AGALProgramCache.prototype.getKey = function (vertexCode, fragmentCode) {
                return vertexCode + "---" + fragmentCode;
            };
            AGALProgramCache._currentId = 0;
            return AGALProgramCache;
        })();
        managers.AGALProgramCache = AGALProgramCache;
    })(away.managers || (away.managers = {}));
    var managers = away.managers;
})(away || (away = {}));

var AGALProgramCacheSingletonEnforcer = (function () {
    function AGALProgramCacheSingletonEnforcer() {
    }
    return AGALProgramCacheSingletonEnforcer;
})();
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var ContextGL = away.gl.ContextGL;
        var ContextGLBlendFactor = away.gl.ContextGLBlendFactor;
        var ContextGLCompareMode = away.gl.ContextGLCompareMode;
        var ContextGLTriangleFace = away.gl.ContextGLTriangleFace;
        var Program = away.gl.Program;
        var TextureBase = away.gl.TextureBase;
        var Event = away.events.Event;
        var Rectangle = away.geom.Rectangle;
        var StageGL = away.base.StageGL;
        var Delegate = away.utils.Delegate;

        /**
        * MaterialPassBase provides an abstract base class for material shader passes. A material pass constitutes at least
        * a render call per required renderable.
        */
        var MaterialPassBase = (function (_super) {
            __extends(MaterialPassBase, _super);
            /**
            * Creates a new MaterialPassBase object.
            *
            * @param renderToTexture Indicates whether this pass is a render-to-texture pass.
            */
            function MaterialPassBase(renderToTexture) {
                if (typeof renderToTexture === "undefined") { renderToTexture = false; }
                _super.call(this);
                this._iPrograms = new Array(8);
                this._iProgramids = new Array(-1, -1, -1, -1, -1, -1, -1, -1);
                this._contextGLs = new Array(8);
                this._pSmooth = true;
                this._pRepeat = false;
                this._pMipmap = true;
                this._depthCompareMode = ContextGLCompareMode.LESS_EQUAL;
                this._blendFactorSource = ContextGLBlendFactor.ONE;
                this._blendFactorDest = ContextGLBlendFactor.ZERO;
                this._pEnableBlending = false;
                // TODO: AGAL conversion
                this._pAnimatableAttributes = new Array("va0");
                // TODO: AGAL conversion
                this._pAnimationTargetRegisters = new Array("vt0");
                // TODO: AGAL conversion
                this._pShadedTarget = "ft0";
                this._defaultCulling = ContextGLTriangleFace.BACK;
                this._pAlphaPremultiplied = false;
                this._writeDepth = true;

                this._onLightsChangeDelegate = Delegate.create(this, this.onLightsChange);

                this._renderToTexture = renderToTexture;
                this._pNumUsedStreams = 1;
                this._pNumUsedVertexConstants = 5;

                this._iUniqueId = MaterialPassBase.MATERIALPASS_ID_COUNT++;
            }
            Object.defineProperty(MaterialPassBase.prototype, "material", {
                get: /**
                * The material to which this pass belongs.
                */
                function () {
                    return this._pMaterial;
                },
                set: function (value) {
                    this._pMaterial = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "writeDepth", {
                get: /**
                * Indicate whether this pass should write to the depth buffer or not. Ignored when blending is enabled.
                */
                function () {
                    return this._writeDepth;
                },
                set: function (value) {
                    this._writeDepth = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "mipmap", {
                get: /**
                * Defines whether any used textures should use mipmapping.
                */
                function () {
                    return this._pMipmap;
                },
                set: function (value) {
                    this.setMipMap(value);
                },
                enumerable: true,
                configurable: true
            });


            MaterialPassBase.prototype.setMipMap = function (value) {
                if (this._pMipmap == value) {
                    return;
                }

                this._pMipmap = value;
                this.iInvalidateShaderProgram();
            };

            Object.defineProperty(MaterialPassBase.prototype, "smooth", {
                get: /**
                * Defines whether smoothing should be applied to any used textures.
                */
                function () {
                    return this._pSmooth;
                },
                set: function (value) {
                    if (this._pSmooth == value) {
                        return;
                    }

                    this._pSmooth = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "repeat", {
                get: /**
                * Defines whether textures should be tiled.
                */
                function () {
                    return this._pRepeat;
                },
                set: function (value) {
                    if (this._pRepeat == value) {
                        return;
                    }

                    this._pRepeat = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "bothSides", {
                get: /**
                * Defines whether or not the material should perform backface culling.
                */
                function () {
                    return this._pBothSides;
                },
                set: function (value) {
                    this._pBothSides = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "depthCompareMode", {
                get: /**
                * The depth compare mode used to render the renderables using this material.
                *
                * @see flash.displayGL.ContextGLCompareMode
                */
                function () {
                    return this._depthCompareMode;
                },
                set: function (value) {
                    this._depthCompareMode = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "animationSet", {
                get: /**
                * Returns the animation data set adding animations to the material.
                */
                function () {
                    return this._animationSet;
                },
                set: function (value) {
                    if (this._animationSet == value) {
                        return;
                    }

                    this._animationSet = value;

                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "renderToTexture", {
                get: /**
                * Specifies whether this pass renders to texture
                */
                function () {
                    return this._renderToTexture;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Cleans up any resources used by the current object.
            * @param deep Indicates whether other resources should be cleaned up, that could potentially be shared across different instances.
            */
            MaterialPassBase.prototype.dispose = function () {
                if (this._pLightPicker) {
                    this._pLightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);
                }

                for (var i = 0; i < 8; ++i) {
                    if (this._iPrograms[i]) {
                        //away.Debug.throwPIR( 'MaterialPassBase' , 'dispose' , 'required dependency: AGALProgramCache');
                        away.managers.AGALProgramCache.getInstanceFromIndex(i).freeProgram(this._iProgramids[i]);
                        this._iPrograms[i] = null;
                    }
                }
            };

            Object.defineProperty(MaterialPassBase.prototype, "numUsedStreams", {
                get: /**
                * The amount of used vertex streams in the vertex code. Used by the animation code generation to know from which index on streams are available.
                */
                function () {
                    return this._pNumUsedStreams;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "numUsedVertexConstants", {
                get: /**
                * The amount of used vertex constants in the vertex code. Used by the animation code generation to know from which index on registers are available.
                */
                function () {
                    return this._pNumUsedVertexConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "numUsedVaryings", {
                get: function () {
                    return this._pNumUsedVaryings;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "numUsedFragmentConstants", {
                get: /**
                * The amount of used fragment constants in the fragment code. Used by the animation code generation to know from which index on registers are available.
                */
                function () {
                    return this._pNumUsedFragmentConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "needFragmentAnimation", {
                get: function () {
                    return this._pNeedFragmentAnimation;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "needUVAnimation", {
                get: /**
                * Indicates whether the pass requires any UV animatin code.
                */
                function () {
                    return this._pNeedUVAnimation;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Sets up the animation state. This needs to be called before render()
            *
            * @private
            */
            MaterialPassBase.prototype.iUpdateAnimationState = function (renderable, stageGL, camera) {
                (renderable.materialOwner.animator).setRenderState(stageGL, renderable, this._pNumUsedVertexConstants, this._pNumUsedStreams, camera);
            };

            /**
            * Renders an object to the current render target.
            *
            * @private
            */
            MaterialPassBase.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Returns the vertex AGAL code for the material.
            */
            MaterialPassBase.prototype.iGetVertexCode = function () {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Returns the fragment AGAL code for the material.
            */
            MaterialPassBase.prototype.iGetFragmentCode = function (fragmentAnimatorCode) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * The blend mode to use when drawing this renderable. The following blend modes are supported:
            * <ul>
            * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
            * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
            * <li>BlendMode.MULTIPLY</li>
            * <li>BlendMode.ADD</li>
            * <li>BlendMode.ALPHA</li>
            * </ul>
            */
            MaterialPassBase.prototype.setBlendMode = function (value) {
                switch (value) {
                    case away.base.BlendMode.NORMAL:
                        this._blendFactorSource = ContextGLBlendFactor.ONE;
                        this._blendFactorDest = ContextGLBlendFactor.ZERO;
                        this._pEnableBlending = false;

                        break;

                    case away.base.BlendMode.LAYER:
                        this._blendFactorSource = ContextGLBlendFactor.SOURCE_ALPHA;
                        this._blendFactorDest = ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA;
                        this._pEnableBlending = true;

                        break;

                    case away.base.BlendMode.MULTIPLY:
                        this._blendFactorSource = ContextGLBlendFactor.ZERO;
                        this._blendFactorDest = ContextGLBlendFactor.SOURCE_COLOR;
                        this._pEnableBlending = true;

                        break;

                    case away.base.BlendMode.ADD:
                        this._blendFactorSource = ContextGLBlendFactor.SOURCE_ALPHA;
                        this._blendFactorDest = ContextGLBlendFactor.ONE;
                        this._pEnableBlending = true;

                        break;

                    case away.base.BlendMode.ALPHA:
                        this._blendFactorSource = ContextGLBlendFactor.ZERO;
                        this._blendFactorDest = ContextGLBlendFactor.SOURCE_ALPHA;
                        this._pEnableBlending = true;

                        break;

                    default:
                        throw new away.errors.ArgumentError("Unsupported blend mode!");
                }
            };

            /**
            * Sets the render state for the pass that is independent of the rendered object. This needs to be called before
            * calling renderPass. Before activating a pass, the previously used pass needs to be deactivated.
            * @param stageGL The StageGL object which is currently used for rendering.
            * @param camera The camera from which the scene is viewed.
            * @private
            */
            MaterialPassBase.prototype.iActivate = function (stageGL, camera) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                context.setDepthTest((this._writeDepth && !this._pEnableBlending), this._depthCompareMode);

                if (this._pEnableBlending) {
                    context.setBlendFactors(this._blendFactorSource, this._blendFactorDest);
                }

                if (this._contextGLs[contextIndex] != context || !this._iPrograms[contextIndex]) {
                    this._contextGLs[contextIndex] = context;

                    this.iUpdateProgram(stageGL);
                    this.dispatchEvent(new Event(Event.CHANGE));
                }

                var prevUsed = MaterialPassBase._previousUsedStreams[contextIndex];
                var i;

                for (i = this._pNumUsedStreams; i < prevUsed; ++i) {
                    context.setVertexBufferAt(i, null);
                }

                prevUsed = MaterialPassBase._previousUsedTexs[contextIndex];

                for (i = this._pNumUsedTextures; i < prevUsed; ++i) {
                    context.setTextureAt(i, null);
                }

                if (this._animationSet && !this._animationSet.usesCPU) {
                    this._animationSet.activate(stageGL, this);
                }

                context.setProgram(this._iPrograms[contextIndex]);

                context.setCulling(this._pBothSides ? ContextGLTriangleFace.NONE : this._defaultCulling);

                if (this._renderToTexture) {
                    this._oldTarget = stageGL.renderTarget;
                    this._oldSurface = stageGL.renderSurfaceSelector;
                    this._oldDepthStencil = stageGL.enableDepthAndStencil;
                    this._oldRect = stageGL.scissorRect;
                }
            };

            /**
            * Clears the render state for the pass. This needs to be called before activating another pass.
            * @param stageGL The StageGL used for rendering
            *
            * @private
            */
            MaterialPassBase.prototype.iDeactivate = function (stageGL) {
                var index = stageGL._iStageGLIndex;
                MaterialPassBase._previousUsedStreams[index] = this._pNumUsedStreams;
                MaterialPassBase._previousUsedTexs[index] = this._pNumUsedTextures;

                if (this._animationSet && !this._animationSet.usesCPU) {
                    this._animationSet.deactivate(stageGL, this);
                }

                if (this._renderToTexture) {
                    // kindly restore state
                    stageGL.setRenderTarget(this._oldTarget, this._oldDepthStencil, this._oldSurface);
                    stageGL.scissorRect = this._oldRect;
                }

                stageGL.contextGL.setDepthTest(true, ContextGLCompareMode.LESS_EQUAL);
            };

            /**
            * Marks the shader program as invalid, so it will be recompiled before the next render.
            *
            * @param updateMaterial Indicates whether the invalidation should be performed on the entire material. Should always pass "true" unless it's called from the material itself.
            */
            MaterialPassBase.prototype.iInvalidateShaderProgram = function (updateMaterial) {
                if (typeof updateMaterial === "undefined") { updateMaterial = true; }
                for (var i = 0; i < 8; ++i) {
                    this._iPrograms[i] = null;
                }

                if (this._pMaterial && updateMaterial) {
                    this._pMaterial.iInvalidatePasses(this);
                }
            };

            /**
            * Compiles the shader program.
            * @param polyOffsetReg An optional register that contains an amount by which to inflate the model (used in single object depth map rendering).
            */
            MaterialPassBase.prototype.iUpdateProgram = function (stageGL) {
                var animatorCode = "";
                var UVAnimatorCode = "";
                var fragmentAnimatorCode = "";
                var vertexCode = this.iGetVertexCode();

                if (this._animationSet && !this._animationSet.usesCPU) {
                    animatorCode = this._animationSet.getAGALVertexCode(this, this._pAnimatableAttributes, this._pAnimationTargetRegisters, stageGL.profile);

                    if (this._pNeedFragmentAnimation)
                        fragmentAnimatorCode = this._animationSet.getAGALFragmentCode(this, this._pShadedTarget, stageGL.profile);

                    if (this._pNeedUVAnimation)
                        UVAnimatorCode = this._animationSet.getAGALUVCode(this, this._pUVSource, this._pUVTarget);

                    this._animationSet.doneAGALCode(this);
                } else {
                    var len = this._pAnimatableAttributes.length;

                    for (var i = 0; i < len; ++i)
                        animatorCode += "mov " + this._pAnimationTargetRegisters[i] + ", " + this._pAnimatableAttributes[i] + "\n";

                    if (this._pNeedUVAnimation)
                        UVAnimatorCode = "mov " + this._pUVTarget + "," + this._pUVSource + "\n";
                }

                vertexCode = animatorCode + UVAnimatorCode + vertexCode;

                var fragmentCode = this.iGetFragmentCode(fragmentAnimatorCode);

                /*
                if (this.Debug.active) {
                trace("Compiling AGAL Code:");
                trace("--------------------");
                trace(vertexCode);
                trace("--------------------");
                trace(fragmentCode);
                }
                */
                away.managers.AGALProgramCache.getInstance(stageGL).setProgram(this, vertexCode, fragmentCode);
            };

            Object.defineProperty(MaterialPassBase.prototype, "lightPicker", {
                get: /**
                * The light picker used by the material to provide lights to the material if it supports lighting.
                *
                * @see away.materials.LightPickerBase
                * @see away.materials.StaticLightPicker
                */
                function () {
                    return this._pLightPicker;
                },
                set: function (value) {
                    if (this._pLightPicker) {
                        this._pLightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);
                    }

                    this._pLightPicker = value;

                    if (this._pLightPicker) {
                        this._pLightPicker.addEventListener(Event.CHANGE, this._onLightsChangeDelegate);
                    }

                    this.pUpdateLights();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Called when the light picker's configuration changes.
            */
            MaterialPassBase.prototype.onLightsChange = function (event) {
                this.pUpdateLights();
            };

            /**
            * Implemented by subclasses if the pass uses lights to update the shader.
            */
            MaterialPassBase.prototype.pUpdateLights = function () {
            };

            Object.defineProperty(MaterialPassBase.prototype, "alphaPremultiplied", {
                get: /**
                * Indicates whether visible textures (or other pixels) used by this material have
                * already been premultiplied. Toggle this if you are seeing black halos around your
                * blended alpha edges.
                */
                function () {
                    return this._pAlphaPremultiplied;
                },
                set: function (value) {
                    this._pAlphaPremultiplied = value;
                    this.iInvalidateShaderProgram(false);
                },
                enumerable: true,
                configurable: true
            });

            MaterialPassBase.MATERIALPASS_ID_COUNT = 0;

            MaterialPassBase._previousUsedStreams = new Array(0, 0, 0, 0, 0, 0, 0, 0);
            MaterialPassBase._previousUsedTexs = new Array(0, 0, 0, 0, 0, 0, 0, 0);
            return MaterialPassBase;
        })(away.events.EventDispatcher);
        materials.MaterialPassBase = MaterialPassBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var Matrix = away.geom.Matrix;
        var Matrix3D = away.geom.Matrix3D;
        var Matrix3DUtils = away.geom.Matrix3DUtils;
        var Texture2DBase = away.textures.Texture2DBase;
        var StageGL = away.base.StageGL;
        var Delegate = away.utils.Delegate;

        var IRenderable = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ShadingMethodEvent = away.events.ShadingMethodEvent;

        /**
        * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,
        * using material methods to define their appearance.
        */
        var CompiledPass = (function (_super) {
            __extends(CompiledPass, _super);
            /**
            * Creates a new CompiledPass object.
            * @param material The material to which this pass belongs.
            */
            function CompiledPass(material) {
                _super.call(this);
                this._pSpecularLightSources = 0x01;
                this._pDiffuseLightSources = 0x03;
                this._pVertexConstantData = new Array();
                this._pFragmentConstantData = new Array();
                this._preserveAlpha = true;
                this._animateUVs = false;
                this._pNumPointLights = 0;
                this._pNumDirectionalLights = 0;
                this._pNumLightProbes = 0;
                this._enableLightFallOff = true;
                this._forceSeparateMVP = false;

                this._pMaterial = material;

                this._onShaderInvalidatedDelegate = Delegate.create(this, this.onShaderInvalidated);

                this.init();
            }
            Object.defineProperty(CompiledPass.prototype, "enableLightFallOff", {
                get: /**
                * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
                * compatibility for constrained mode.
                */
                function () {
                    return this._enableLightFallOff;
                },
                set: function (value) {
                    if (value != this._enableLightFallOff)
                        this.iInvalidateShaderProgram(true);

                    this._enableLightFallOff = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "forceSeparateMVP", {
                get: /**
                * Indicates whether the screen projection should be calculated by forcing a separate scene matrix and
                * view-projection matrix. This is used to prevent rounding errors when using multiple passes with different
                * projection code.
                */
                function () {
                    return this._forceSeparateMVP;
                },
                set: function (value) {
                    this._forceSeparateMVP = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "iNumPointLights", {
                get: /**
                * The amount of point lights that need to be supported.
                */
                function () {
                    return this._pNumPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompiledPass.prototype, "iNumDirectionalLights", {
                get: /**
                * The amount of directional lights that need to be supported.
                */
                function () {
                    return this._pNumDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompiledPass.prototype, "iNumLightProbes", {
                get: /**
                * The amount of light probes that need to be supported.
                */
                function () {
                    return this._pNumLightProbes;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iUpdateProgram = function (stageGL) {
                this.reset(stageGL.profile);
                _super.prototype.iUpdateProgram.call(this, stageGL);
            };

            /**
            * Resets the compilation state.
            *
            * @param profile The compatibility profile used by the renderer.
            */
            CompiledPass.prototype.reset = function (profile) {
                this.iInitCompiler(profile);

                this.pUpdateShaderProperties();
                this.initConstantData();

                this.pCleanUp();
            };

            /**
            * Updates the amount of used register indices.
            */
            CompiledPass.prototype.updateUsedOffsets = function () {
                this._pNumUsedVertexConstants = this._pCompiler.numUsedVertexConstants;
                this._pNumUsedFragmentConstants = this._pCompiler.numUsedFragmentConstants;
                this._pNumUsedStreams = this._pCompiler.numUsedStreams;
                this._pNumUsedTextures = this._pCompiler.numUsedTextures;
                this._pNumUsedVaryings = this._pCompiler.numUsedVaryings;
                this._pNumUsedFragmentConstants = this._pCompiler.numUsedFragmentConstants;
            };

            /**
            * Initializes the unchanging constant data for this material.
            */
            CompiledPass.prototype.initConstantData = function () {
                this._pVertexConstantData.length = this._pNumUsedVertexConstants * 4;
                this._pFragmentConstantData.length = this._pNumUsedFragmentConstants * 4;

                this.pInitCommonsData();

                if (this._uvTransformIndex >= 0)
                    this.pInitUVTransformData();

                if (this._pCameraPositionIndex >= 0)
                    this._pVertexConstantData[this._pCameraPositionIndex + 3] = 1;

                this.pUpdateMethodConstants();
            };

            /**
            * Initializes the compiler for this pass.
            * @param profile The compatibility profile used by the renderer.
            */
            CompiledPass.prototype.iInitCompiler = function (profile) {
                this._pCompiler = this.pCreateCompiler(profile);
                this._pCompiler.forceSeperateMVP = this._forceSeparateMVP;
                this._pCompiler.numPointLights = this._pNumPointLights;
                this._pCompiler.numDirectionalLights = this._pNumDirectionalLights;
                this._pCompiler.numLightProbes = this._pNumLightProbes;
                this._pCompiler.methodSetup = this._pMethodSetup;
                this._pCompiler.diffuseLightSources = this._pDiffuseLightSources;
                this._pCompiler.specularLightSources = this._pSpecularLightSources;
                this._pCompiler.setTextureSampling(this._pSmooth, this._pRepeat, this._pMipmap);
                this._pCompiler.setConstantDataBuffers(this._pVertexConstantData, this._pFragmentConstantData);
                this._pCompiler.animateUVs = this._animateUVs;
                this._pCompiler.alphaPremultiplied = this._pAlphaPremultiplied && this._pEnableBlending;
                this._pCompiler.preserveAlpha = this._preserveAlpha && this._pEnableBlending;
                this._pCompiler.enableLightFallOff = this._enableLightFallOff;
                this._pCompiler.compile();
            };

            /**
            * Factory method to create a concrete compiler object for this pass.
            * @param profile The compatibility profile used by the renderer.
            */
            CompiledPass.prototype.pCreateCompiler = function (profile) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Copies the shader's properties from the compiler.
            */
            CompiledPass.prototype.pUpdateShaderProperties = function () {
                this._pAnimatableAttributes = this._pCompiler.animatableAttributes;
                this._pAnimationTargetRegisters = this._pCompiler.animationTargetRegisters;
                this._vertexCode = this._pCompiler.vertexCode;
                this._fragmentLightCode = this._pCompiler.fragmentLightCode;
                this._framentPostLightCode = this._pCompiler.fragmentPostLightCode;
                this._pShadedTarget = this._pCompiler.shadedTarget;
                this._usingSpecularMethod = this._pCompiler.usingSpecularMethod;
                this._usesNormals = this._pCompiler.usesNormals;
                this._pNeedUVAnimation = this._pCompiler.needUVAnimation;
                this._pUVSource = this._pCompiler.UVSource;
                this._pUVTarget = this._pCompiler.UVTarget;

                this.pUpdateRegisterIndices();
                this.updateUsedOffsets();
            };

            /**
            * Updates the indices for various registers.
            */
            CompiledPass.prototype.pUpdateRegisterIndices = function () {
                this._uvBufferIndex = this._pCompiler.uvBufferIndex;
                this._uvTransformIndex = this._pCompiler.uvTransformIndex;
                this._secondaryUVBufferIndex = this._pCompiler.secondaryUVBufferIndex;
                this._normalBufferIndex = this._pCompiler.normalBufferIndex;
                this._tangentBufferIndex = this._pCompiler.tangentBufferIndex;
                this._pLightFragmentConstantIndex = this._pCompiler.lightFragmentConstantIndex;
                this._pCameraPositionIndex = this._pCompiler.cameraPositionIndex;
                this._commonsDataIndex = this._pCompiler.commonsDataIndex;
                this._sceneMatrixIndex = this._pCompiler.sceneMatrixIndex;
                this._sceneNormalMatrixIndex = this._pCompiler.sceneNormalMatrixIndex;
                this._pProbeWeightsIndex = this._pCompiler.probeWeightsIndex;
                this._pLightProbeDiffuseIndices = this._pCompiler.lightProbeDiffuseIndices;
                this._pLightProbeSpecularIndices = this._pCompiler.lightProbeSpecularIndices;
            };

            Object.defineProperty(CompiledPass.prototype, "preserveAlpha", {
                get: /**
                * Indicates whether the output alpha value should remain unchanged compared to the material's original alpha.
                */
                function () {
                    return this._preserveAlpha;
                },
                set: function (value) {
                    if (this._preserveAlpha == value)
                        return;

                    this._preserveAlpha = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "animateUVs", {
                get: /**
                * Indicate whether UV coordinates need to be animated using the renderable's transformUV matrix.
                */
                function () {
                    return this._animateUVs;
                },
                set: function (value) {
                    this._animateUVs = value;

                    if ((value && !this._animateUVs) || (!value && this._animateUVs))
                        this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "mipmap", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    if (this._pMipmap == value)
                        return;

                    _super.prototype.setMipMap.call(this, value);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompiledPass.prototype, "normalMap", {
                get: /**
                * The normal map to modulate the direction of the surface for each texel. The default normal method expects
                * tangent-space normal maps, but others could expect object-space maps.
                */
                function () {
                    return this._pMethodSetup._iNormalMethod.normalMap;
                },
                set: function (value) {
                    this._pMethodSetup._iNormalMethod.normalMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "normalMethod", {
                get: /**
                * The method used to generate the per-pixel normals. Defaults to BasicNormalMethod.
                */
                function () {
                    return this._pMethodSetup.normalMethod;
                },
                set: function (value) {
                    this._pMethodSetup.normalMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "ambientMethod", {
                get: /**
                * The method that provides the ambient lighting contribution. Defaults to BasicAmbientMethod.
                */
                function () {
                    return this._pMethodSetup.ambientMethod;
                },
                set: function (value) {
                    this._pMethodSetup.ambientMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "shadowMethod", {
                get: /**
                * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
                */
                function () {
                    return this._pMethodSetup.shadowMethod;
                },
                set: function (value) {
                    this._pMethodSetup.shadowMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "diffuseMethod", {
                get: /**
                * The method that provides the diffuse lighting contribution. Defaults to BasicDiffuseMethod.
                */
                function () {
                    return this._pMethodSetup.diffuseMethod;
                },
                set: function (value) {
                    this._pMethodSetup.diffuseMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "specularMethod", {
                get: /**
                * The method that provides the specular lighting contribution. Defaults to BasicSpecularMethod.
                */
                function () {
                    return this._pMethodSetup.specularMethod;
                },
                set: function (value) {
                    this._pMethodSetup.specularMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Initializes the pass.
            */
            CompiledPass.prototype.init = function () {
                this._pMethodSetup = new materials.ShaderMethodSetup();

                this._pMethodSetup.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this._pMethodSetup.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                this._pMethodSetup.dispose();
                this._pMethodSetup = null;
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iInvalidateShaderProgram = function (updateMaterial) {
                if (typeof updateMaterial === "undefined") { updateMaterial = true; }
                var oldPasses = this._iPasses;
                this._iPasses = new Array();

                if (this._pMethodSetup) {
                    this.pAddPassesFromMethods();
                }

                if (!oldPasses || this._iPasses.length != oldPasses.length) {
                    this._iPassesDirty = true;
                    return;
                }

                for (var i = 0; i < this._iPasses.length; ++i) {
                    if (this._iPasses[i] != oldPasses[i]) {
                        this._iPassesDirty = true;
                        return;
                    }
                }

                _super.prototype.iInvalidateShaderProgram.call(this, updateMaterial);
            };

            /**
            * Adds any possible passes needed by the used methods.
            */
            CompiledPass.prototype.pAddPassesFromMethods = function () {
                if (this._pMethodSetup._iNormalMethod && this._pMethodSetup._iNormalMethod.iHasOutput)
                    this.pAddPasses(this._pMethodSetup._iNormalMethod.passes);

                if (this._pMethodSetup._iAmbientMethod)
                    this.pAddPasses(this._pMethodSetup._iAmbientMethod.passes);

                if (this._pMethodSetup._iShadowMethod)
                    this.pAddPasses(this._pMethodSetup._iShadowMethod.passes);

                if (this._pMethodSetup._iDiffuseMethod)
                    this.pAddPasses(this._pMethodSetup._iDiffuseMethod.passes);

                if (this._pMethodSetup._iSpecularMethod)
                    this.pAddPasses(this._pMethodSetup._iSpecularMethod.passes);
            };

            /**
            * Adds internal passes to the material.
            *
            * @param passes The passes to add.
            */
            CompiledPass.prototype.pAddPasses = function (passes) {
                if (!passes)
                    return;

                var len = passes.length;

                for (var i = 0; i < len; ++i) {
                    passes[i].material = this.material;
                    passes[i].lightPicker = this._pLightPicker;
                    this._iPasses.push(passes[i]);
                }
            };

            /**
            * Initializes the default UV transformation matrix.
            */
            CompiledPass.prototype.pInitUVTransformData = function () {
                this._pVertexConstantData[this._uvTransformIndex] = 1;
                this._pVertexConstantData[this._uvTransformIndex + 1] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 2] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 3] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 4] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 5] = 1;
                this._pVertexConstantData[this._uvTransformIndex + 6] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 7] = 0;
            };

            /**
            * Initializes commonly required constant values.
            */
            CompiledPass.prototype.pInitCommonsData = function () {
                this._pFragmentConstantData[this._commonsDataIndex] = .5;
                this._pFragmentConstantData[this._commonsDataIndex + 1] = 0;
                this._pFragmentConstantData[this._commonsDataIndex + 2] = 1 / 255;
                this._pFragmentConstantData[this._commonsDataIndex + 3] = 1;
            };

            /**
            * Cleans up the after compiling.
            */
            CompiledPass.prototype.pCleanUp = function () {
                this._pCompiler.dispose();
                this._pCompiler = null;
            };

            /**
            * Updates method constants if they have changed.
            */
            CompiledPass.prototype.pUpdateMethodConstants = function () {
                if (this._pMethodSetup._iNormalMethod)
                    this._pMethodSetup._iNormalMethod.iInitConstants(this._pMethodSetup._iNormalMethodVO);

                if (this._pMethodSetup._iDiffuseMethod)
                    this._pMethodSetup._iDiffuseMethod.iInitConstants(this._pMethodSetup._iDiffuseMethodVO);

                if (this._pMethodSetup._iAmbientMethod)
                    this._pMethodSetup._iAmbientMethod.iInitConstants(this._pMethodSetup._iAmbientMethodVO);

                if (this._usingSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iInitConstants(this._pMethodSetup._iSpecularMethodVO);

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iInitConstants(this._pMethodSetup._iShadowMethodVO);
            };

            /**
            * Updates constant data render state used by the lights. This method is optional for subclasses to implement.
            */
            CompiledPass.prototype.pUpdateLightConstants = function () {
                // up to subclasses to optionally implement
            };

            /**
            * Updates constant data render state used by the light probes. This method is optional for subclasses to implement.
            */
            CompiledPass.prototype.pUpdateProbes = function (stageGL) {
            };

            /**
            * Called when any method's shader code is invalidated.
            */
            CompiledPass.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iGetVertexCode = function () {
                return this._vertexCode;
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iGetFragmentCode = function (animatorCode) {
                //TODO: AGAL <> GLSL conversion
                return this._fragmentLightCode + animatorCode + this._framentPostLightCode;
            };

            // RENDER LOOP
            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iActivate = function (stageGL, camera) {
                _super.prototype.iActivate.call(this, stageGL, camera);

                if (this._usesNormals)
                    this._pMethodSetup._iNormalMethod.iActivate(this._pMethodSetup._iNormalMethodVO, stageGL);

                this._pMethodSetup._iAmbientMethod.iActivate(this._pMethodSetup._iAmbientMethodVO, stageGL);

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iActivate(this._pMethodSetup._iShadowMethodVO, stageGL);

                this._pMethodSetup._iDiffuseMethod.iActivate(this._pMethodSetup._iDiffuseMethodVO, stageGL);

                if (this._usingSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iActivate(this._pMethodSetup._iSpecularMethodVO, stageGL);
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                var i;
                var context = stageGL.contextGL;
                if (this._uvBufferIndex >= 0)
                    renderable.subGeometry.activateUVBuffer(this._uvBufferIndex, stageGL);

                if (this._secondaryUVBufferIndex >= 0)
                    renderable.subGeometry.activateSecondaryUVBuffer(this._secondaryUVBufferIndex, stageGL);

                if (this._normalBufferIndex >= 0)
                    renderable.subGeometry.activateVertexNormalBuffer(this._normalBufferIndex, stageGL);

                if (this._tangentBufferIndex >= 0)
                    renderable.subGeometry.activateVertexTangentBuffer(this._tangentBufferIndex, stageGL);

                if (this._animateUVs) {
                    var uvTransform = renderable.materialOwner.uvTransform.matrix;

                    if (uvTransform) {
                        this._pVertexConstantData[this._uvTransformIndex] = uvTransform.a;
                        this._pVertexConstantData[this._uvTransformIndex + 1] = uvTransform.b;
                        this._pVertexConstantData[this._uvTransformIndex + 3] = uvTransform.tx;
                        this._pVertexConstantData[this._uvTransformIndex + 4] = uvTransform.c;
                        this._pVertexConstantData[this._uvTransformIndex + 5] = uvTransform.d;
                        this._pVertexConstantData[this._uvTransformIndex + 7] = uvTransform.ty;
                    } else {
                        this._pVertexConstantData[this._uvTransformIndex] = 1;
                        this._pVertexConstantData[this._uvTransformIndex + 1] = 0;
                        this._pVertexConstantData[this._uvTransformIndex + 3] = 0;
                        this._pVertexConstantData[this._uvTransformIndex + 4] = 0;
                        this._pVertexConstantData[this._uvTransformIndex + 5] = 1;
                        this._pVertexConstantData[this._uvTransformIndex + 7] = 0;
                    }
                }

                this._pAmbientLightR = this._pAmbientLightG = this._pAmbientLightB = 0;

                if (this.pUsesLights())
                    this.pUpdateLightConstants();

                if (this.pUsesProbes())
                    this.pUpdateProbes(stageGL);

                if (this._sceneMatrixIndex >= 0) {
                    renderable.sourceEntity.getRenderSceneTransform(camera).copyRawDataTo(this._pVertexConstantData, this._sceneMatrixIndex, true);
                    viewProjection.copyRawDataTo(this._pVertexConstantData, 0, true);
                    //this._pVertexConstantData = renderable.getRenderSceneTransform(camera).copyRawDataTo( this._sceneMatrixIndex, true);
                    //this._pVertexConstantData = viewProjection.copyRawDataTo( 0, true);
                } else {
                    var matrix3D = Matrix3DUtils.CALCULATION_MATRIX;

                    matrix3D.copyFrom(renderable.sourceEntity.getRenderSceneTransform(camera));
                    matrix3D.append(viewProjection);

                    matrix3D.copyRawDataTo(this._pVertexConstantData, 0, true);
                    //this._pVertexConstantData = matrix3D.copyRawDataTo( 0, true);
                }

                if (this._sceneNormalMatrixIndex >= 0) {
                    renderable.sourceEntity.inverseSceneTransform.copyRawDataTo(this._pVertexConstantData, this._sceneNormalMatrixIndex, false);
                    //this._pVertexConstantData = renderable.inverseSceneTransform.copyRawDataTo(this._sceneNormalMatrixIndex, false);
                }

                if (this._usesNormals)
                    this._pMethodSetup._iNormalMethod.iSetRenderState(this._pMethodSetup._iNormalMethodVO, renderable, stageGL, camera);

                var ambientMethod = this._pMethodSetup._iAmbientMethod;
                ambientMethod._iLightAmbientR = this._pAmbientLightR;
                ambientMethod._iLightAmbientG = this._pAmbientLightG;
                ambientMethod._iLightAmbientB = this._pAmbientLightB;
                ambientMethod.iSetRenderState(this._pMethodSetup._iAmbientMethodVO, renderable, stageGL, camera);

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iSetRenderState(this._pMethodSetup._iShadowMethodVO, renderable, stageGL, camera);

                this._pMethodSetup._iDiffuseMethod.iSetRenderState(this._pMethodSetup._iDiffuseMethodVO, renderable, stageGL, camera);

                if (this._usingSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iSetRenderState(this._pMethodSetup._iSpecularMethodVO, renderable, stageGL, camera);

                if (this._pMethodSetup._iColorTransformMethod)
                    this._pMethodSetup._iColorTransformMethod.iSetRenderState(this._pMethodSetup._iColorTransformMethodVO, renderable, stageGL, camera);

                var methods = this._pMethodSetup._iMethods;
                var len = methods.length;

                for (i = 0; i < len; ++i) {
                    var aset = methods[i];

                    aset.method.iSetRenderState(aset.data, renderable, stageGL, camera);
                }

                context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.VERTEX, 0, this._pVertexConstantData, this._pNumUsedVertexConstants);
                context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.FRAGMENT, 0, this._pFragmentConstantData, this._pNumUsedFragmentConstants);

                renderable.subGeometry.activateVertexBuffer(0, stageGL);
                context.drawTriangles(renderable.subGeometry.getIndexBuffer(stageGL), 0, renderable.subGeometry.numTriangles);
            };

            /**
            * Indicates whether the shader uses any light probes.
            */
            CompiledPass.prototype.pUsesProbes = function () {
                return this._pNumLightProbes > 0 && ((this._pDiffuseLightSources | this._pSpecularLightSources) & materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether the shader uses any lights.
            */
            CompiledPass.prototype.pUsesLights = function () {
                return (this._pNumPointLights > 0 || this._pNumDirectionalLights > 0) && ((this._pDiffuseLightSources | this._pSpecularLightSources) & materials.LightSources.LIGHTS) != 0;
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iDeactivate = function (stageGL) {
                _super.prototype.iDeactivate.call(this, stageGL);

                if (this._usesNormals)
                    this._pMethodSetup._iNormalMethod.iDeactivate(this._pMethodSetup._iNormalMethodVO, stageGL);

                this._pMethodSetup._iAmbientMethod.iDeactivate(this._pMethodSetup._iAmbientMethodVO, stageGL);

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iDeactivate(this._pMethodSetup._iShadowMethodVO, stageGL);

                this._pMethodSetup._iDiffuseMethod.iDeactivate(this._pMethodSetup._iDiffuseMethodVO, stageGL);

                if (this._usingSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iDeactivate(this._pMethodSetup._iSpecularMethodVO, stageGL);
            };

            Object.defineProperty(CompiledPass.prototype, "specularLightSources", {
                get: /**
                * Define which light source types to use for specular reflections. This allows choosing between regular lights
                * and/or light probes for specular reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._pSpecularLightSources;
                },
                set: function (value) {
                    this._pSpecularLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "diffuseLightSources", {
                get: /**
                * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
                * and/or light probes for diffuse reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._pDiffuseLightSources;
                },
                set: function (value) {
                    this._pDiffuseLightSources = value;
                },
                enumerable: true,
                configurable: true
            });

            return CompiledPass;
        })(materials.MaterialPassBase);
        materials.CompiledPass = CompiledPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * SuperShaderPass is a shader pass that uses shader methods to compile a complete program. It includes all methods
        * associated with a material.
        *
        * @see away3d.materials.methods.ShadingMethodBase
        */
        var SuperShaderPass = (function (_super) {
            __extends(SuperShaderPass, _super);
            /**
            * Creates a new SuperShaderPass objects.
            *
            * @param material The material to which this material belongs.
            */
            function SuperShaderPass(material) {
                _super.call(this, material);
                this._includeCasters = true;
                this._pNeedFragmentAnimation = true;
            }
            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pCreateCompiler = function (profile) {
                return new materials.SuperShaderCompiler(profile);
            };

            Object.defineProperty(SuperShaderPass.prototype, "includeCasters", {
                get: /**
                * Indicates whether lights that cast shadows should be included in the pass.
                */
                function () {
                    return this._includeCasters;
                },
                set: function (value) {
                    if (this._includeCasters == value)
                        return;
                    this._includeCasters = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SuperShaderPass.prototype, "colorTransform", {
                get: /**
                * The ColorTransform object to transform the colour of the material with. Defaults to null.
                */
                function () {
                    return this._pMethodSetup._iColorTransformMethod ? this._pMethodSetup._iColorTransformMethod.colorTransform : null;
                },
                set: function (value) {
                    if (value) {
                        if (this.colorTransformMethod == null) {
                            this.colorTransformMethod = new materials.ColorTransformMethod();
                        }

                        this._pMethodSetup._iColorTransformMethod.colorTransform = value;
                    } else if (!value) {
                        if (this._pMethodSetup._iColorTransformMethod) {
                            this.colorTransformMethod = null;
                        }

                        this.colorTransformMethod = this._pMethodSetup._iColorTransformMethod = null;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SuperShaderPass.prototype, "colorTransformMethod", {
                get: /**
                * The ColorTransformMethod object to transform the colour of the material with. Defaults to null.
                */
                function () {
                    return this._pMethodSetup._iColorTransformMethod;
                },
                set: function (value) {
                    this._pMethodSetup.iColorTransformMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
            * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
            * methods added prior.
            */
            SuperShaderPass.prototype.addMethod = function (method) {
                this._pMethodSetup.addMethod(method);
            };

            Object.defineProperty(SuperShaderPass.prototype, "numMethods", {
                get: /**
                * The number of "effect" methods added to the material.
                */
                function () {
                    return this._pMethodSetup.numMethods;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Queries whether a given effect method was added to the material.
            *
            * @param method The method to be queried.
            * @return true if the method was added to the material, false otherwise.
            */
            SuperShaderPass.prototype.hasMethod = function (method) {
                return this._pMethodSetup.hasMethod(method);
            };

            /**
            * Returns the method added at the given index.
            * @param index The index of the method to retrieve.
            * @return The method at the given index.
            */
            SuperShaderPass.prototype.getMethodAt = function (index) {
                return this._pMethodSetup.getMethodAt(index);
            };

            /**
            * Adds an effect method at the specified index amongst the methods already added to the material. Effect
            * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
            * etc. The method will be applied to the result of the methods with a lower index.
            */
            SuperShaderPass.prototype.addMethodAt = function (method, index) {
                this._pMethodSetup.addMethodAt(method, index);
            };

            /**
            * Removes an effect method from the material.
            * @param method The method to be removed.
            */
            SuperShaderPass.prototype.removeMethod = function (method) {
                this._pMethodSetup.removeMethod(method);
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pUpdateLights = function () {
                if (this._pLightPicker && !this._ignoreLights) {
                    this._pNumPointLights = this._pLightPicker.numPointLights;
                    this._pNumDirectionalLights = this._pLightPicker.numDirectionalLights;
                    this._pNumLightProbes = this._pLightPicker.numLightProbes;

                    if (this._includeCasters) {
                        this._pNumPointLights += this._pLightPicker.numCastingPointLights;
                        this._pNumDirectionalLights += this._pLightPicker.numCastingDirectionalLights;
                    }
                } else {
                    this._pNumPointLights = 0;
                    this._pNumDirectionalLights = 0;
                    this._pNumLightProbes = 0;
                }

                this.iInvalidateShaderProgram();
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.iActivate = function (stageGL, camera) {
                _super.prototype.iActivate.call(this, stageGL, camera);

                if (this._pMethodSetup._iColorTransformMethod)
                    this._pMethodSetup._iColorTransformMethod.iActivate(this._pMethodSetup._iColorTransformMethodVO, stageGL);

                var methods = this._pMethodSetup._iMethods;
                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    var aset = methods[i];
                    aset.method.iActivate(aset.data, stageGL);
                }

                if (this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;

                    this._pVertexConstantData[this._pCameraPositionIndex] = pos.x;
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = pos.y;
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = pos.z;
                }
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.iDeactivate = function (stageGL) {
                _super.prototype.iDeactivate.call(this, stageGL);

                if (this._pMethodSetup._iColorTransformMethod) {
                    this._pMethodSetup._iColorTransformMethod.iDeactivate(this._pMethodSetup._iColorTransformMethodVO, stageGL);
                }

                var aset;
                var methods = this._pMethodSetup._iMethods;
                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    aset = methods[i];
                    aset.method.iDeactivate(aset.data, stageGL);
                }
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pAddPassesFromMethods = function () {
                _super.prototype.pAddPassesFromMethods.call(this);

                if (this._pMethodSetup._iColorTransformMethod) {
                    this.pAddPasses(this._pMethodSetup._iColorTransformMethod.passes);
                }
                var methods = this._pMethodSetup._iMethods;

                for (var i = 0; i < methods.length; ++i) {
                    this.pAddPasses(methods[i].method.passes);
                }
            };

            /**
            * Indicates whether any light probes are used to contribute to the specular shading.
            */
            SuperShaderPass.prototype.usesProbesForSpecular = function () {
                return this._pNumLightProbes > 0 && (this._pSpecularLightSources & materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether any light probes are used to contribute to the diffuse shading.
            */
            SuperShaderPass.prototype.usesProbesForDiffuse = function () {
                return this._pNumLightProbes > 0 && (this._pDiffuseLightSources & materials.LightSources.PROBES) != 0;
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pUpdateMethodConstants = function () {
                _super.prototype.pUpdateMethodConstants.call(this);

                if (this._pMethodSetup._iColorTransformMethod) {
                    this._pMethodSetup._iColorTransformMethod.iInitConstants(this._pMethodSetup._iColorTransformMethodVO);
                }

                var methods = this._pMethodSetup._iMethods;
                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    methods[i].method.iInitConstants(methods[i].data);
                }
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pUpdateLightConstants = function () {
                // first dirs, then points
                var dirLight;

                var pointLight;

                var i, k;

                var len;

                var dirPos;

                var total = 0;

                var numLightTypes = this._includeCasters ? 2 : 1;

                k = this._pLightFragmentConstantIndex;

                for (var cast = 0; cast < numLightTypes; ++cast) {
                    var dirLights = cast ? this._pLightPicker.castingDirectionalLights : this._pLightPicker.directionalLights;
                    len = dirLights.length;
                    total += len;

                    for (i = 0; i < len; ++i) {
                        dirLight = dirLights[i];
                        dirPos = dirLight.sceneDirection;

                        this._pAmbientLightR += dirLight._iAmbientR;
                        this._pAmbientLightG += dirLight._iAmbientG;
                        this._pAmbientLightB += dirLight._iAmbientB;

                        this._pFragmentConstantData[k++] = -dirPos.x;
                        this._pFragmentConstantData[k++] = -dirPos.y;
                        this._pFragmentConstantData[k++] = -dirPos.z;
                        this._pFragmentConstantData[k++] = 1;

                        this._pFragmentConstantData[k++] = dirLight._iDiffuseR;
                        this._pFragmentConstantData[k++] = dirLight._iDiffuseG;
                        this._pFragmentConstantData[k++] = dirLight._iDiffuseB;
                        this._pFragmentConstantData[k++] = 1;

                        this._pFragmentConstantData[k++] = dirLight._iSpecularR;
                        this._pFragmentConstantData[k++] = dirLight._iSpecularG;
                        this._pFragmentConstantData[k++] = dirLight._iSpecularB;
                        this._pFragmentConstantData[k++] = 1;
                    }
                }

                if (this._pNumDirectionalLights > total) {
                    i = k + (this._pNumDirectionalLights - total) * 12;

                    while (k < i) {
                        this._pFragmentConstantData[k++] = 0;
                    }
                }

                total = 0;
                for (cast = 0; cast < numLightTypes; ++cast) {
                    var pointLights = cast ? this._pLightPicker.castingPointLights : this._pLightPicker.pointLights;

                    len = pointLights.length;

                    for (i = 0; i < len; ++i) {
                        pointLight = pointLights[i];
                        dirPos = pointLight.scenePosition;

                        this._pAmbientLightR += pointLight._iAmbientR;
                        this._pAmbientLightG += pointLight._iAmbientG;
                        this._pAmbientLightB += pointLight._iAmbientB;

                        this._pFragmentConstantData[k++] = dirPos.x;
                        this._pFragmentConstantData[k++] = dirPos.y;
                        this._pFragmentConstantData[k++] = dirPos.z;
                        this._pFragmentConstantData[k++] = 1;

                        this._pFragmentConstantData[k++] = pointLight._iDiffuseR;
                        this._pFragmentConstantData[k++] = pointLight._iDiffuseG;
                        this._pFragmentConstantData[k++] = pointLight._iDiffuseB;
                        this._pFragmentConstantData[k++] = pointLight._pRadius * pointLight._pRadius;

                        this._pFragmentConstantData[k++] = pointLight._iSpecularR;
                        this._pFragmentConstantData[k++] = pointLight._iSpecularG;
                        this._pFragmentConstantData[k++] = pointLight._iSpecularB;
                        this._pFragmentConstantData[k++] = pointLight._pFallOffFactor;
                    }
                }

                if (this._pNumPointLights > total) {
                    i = k + (total - this._pNumPointLights) * 12;

                    for (; k < i; ++k) {
                        this._pFragmentConstantData[k] = 0;
                    }
                }
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pUpdateProbes = function (stageGL) {
                var probe;
                var lightProbes = this._pLightPicker.lightProbes;
                var weights = this._pLightPicker.lightProbeWeights;
                var len = lightProbes.length;
                var addDiff = this.usesProbesForDiffuse();
                var addSpec = (this._pMethodSetup._iSpecularMethod && this.usesProbesForSpecular());
                var context = stageGL.contextGL;

                if (!(addDiff || addSpec)) {
                    return;
                }

                for (var i = 0; i < len; ++i) {
                    probe = lightProbes[i];

                    if (addDiff) {
                        context.setTextureAt(this._pLightProbeSpecularIndices[i], probe.diffuseMap.getTextureForStageGL(stageGL));
                    }

                    if (addSpec) {
                        context.setTextureAt(this._pLightProbeSpecularIndices[i], probe.specularMap.getTextureForStageGL(stageGL));
                    }
                }

                this._pFragmentConstantData[this._pProbeWeightsIndex] = weights[0];
                this._pFragmentConstantData[this._pProbeWeightsIndex + 1] = weights[1];
                this._pFragmentConstantData[this._pProbeWeightsIndex + 2] = weights[2];
                this._pFragmentConstantData[this._pProbeWeightsIndex + 3] = weights[3];
            };


            Object.defineProperty(SuperShaderPass.prototype, "iIgnoreLights", {
                get: function () {
                    return this._ignoreLights;
                },
                set: /**
                * Indicates whether lights should be ignored in this pass. This is used when only effect methods are rendered in
                * a multipass material.
                */
                function (ignoreLights) {
                    this._ignoreLights = ignoreLights;
                },
                enumerable: true,
                configurable: true
            });
            return SuperShaderPass;
        })(materials.CompiledPass);
        materials.SuperShaderPass = SuperShaderPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //use namespace arcane;
        /**
        * DepthMapPass is a pass that writes depth values to a depth map as a 32-bit value exploded over the 4 texture channels.
        * This is used to render shadow maps, depth maps, etc.
        */
        var DepthMapPass = (function (_super) {
            __extends(DepthMapPass, _super);
            /**
            * Creates a new DepthMapPass object.
            */
            function DepthMapPass() {
                _super.call(this);
                this._alphaThreshold = 0;

                this._data = new Array(1.0, 255.0, 65025.0, 16581375.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0, 0.0, 0.0, 0.0, 0.0);
            }
            Object.defineProperty(DepthMapPass.prototype, "alphaThreshold", {
                get: /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                function () {
                    return this._alphaThreshold;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;
else if (value > 1)
                        value = 1;

                    if (value == this._alphaThreshold)
                        return;

                    if (value == 0 || this._alphaThreshold == 0)
                        this.iInvalidateShaderProgram();

                    this._alphaThreshold = value;
                    this._data[8] = this._alphaThreshold;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DepthMapPass.prototype, "alphaMask", {
                get: /**
                * A texture providing alpha data to be able to prevent semi-transparent pixels to write to the alpha mask.
                * Usually the diffuse texture when alphaThreshold is used.
                */
                function () {
                    return this._alphaMask;
                },
                set: function (value) {
                    this._alphaMask = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DepthMapPass.prototype.iGetVertexCode = function () {
                var code = "";

                // project
                //TODO: AGAL <> GLSL conversion
                code = "m44 vt1, vt0, vc0		\n" + "mov op, vt1	\n";

                if (this._alphaThreshold > 0) {
                    this._pNumUsedTextures = 1;
                    this._pNumUsedStreams = 2;
                    code += "mov v0, vt1\n" + "mov v1, va1\n";
                } else {
                    this._pNumUsedTextures = 0;
                    this._pNumUsedStreams = 1;
                    code += "mov v0, vt1\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            DepthMapPass.prototype.iGetFragmentCode = function (code) {
                var wrap = this._pRepeat ? "wrap" : "clamp";
                var filter;

                if (this._pSmooth)
                    filter = this._pMipmap ? "linear,miplinear" : "linear";
else
                    filter = this._pMipmap ? "nearest,mipnearest" : "nearest";

                // TODO: AGAL<>GLSL
                var codeF = "div ft2, v0, v0.w		\n" + "mul ft0, fc0, ft2.z	\n" + "frc ft0, ft0			\n" + "mul ft1, ft0.yzww, fc1	\n";

                if (this._alphaThreshold > 0) {
                    var format;

                    switch (this._alphaMask.format) {
                        case away.gl.ContextGLTextureFormat.COMPRESSED:
                            format = "dxt1,";
                            break;

                        case "compressedAlpha":
                            format = "dxt5,";
                            break;

                        default:
                            format = "";
                    }

                    codeF += "tex ft3, v1, fs0 <2d," + filter + "," + format + wrap + ">\n" + "sub ft3.w, ft3.w, fc2.x\n" + "kil ft3.w\n";
                }

                codeF += "sub oc, ft0, ft1		\n";

                return codeF;
            };

            /**
            * @inheritDoc
            */
            DepthMapPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                if (this._alphaThreshold > 0)
                    renderable.subGeometry.activateUVBuffer(1, stageGL);

                var context = stageGL.contextGL;
                var matrix = away.geom.Matrix3DUtils.CALCULATION_MATRIX;

                matrix.copyFrom(renderable.sourceEntity.getRenderSceneTransform(camera));
                matrix.append(viewProjection);
                context.setProgramConstantsFromMatrix(away.gl.ContextGLProgramType.VERTEX, 0, matrix, true);
                renderable.subGeometry.activateVertexBuffer(0, stageGL);
                context.drawTriangles(renderable.subGeometry.getIndexBuffer(stageGL), 0, renderable.subGeometry.numTriangles);
            };

            /**
            * @inheritDoc
            */
            DepthMapPass.prototype.iActivate = function (stageGL, camera) {
                var context = stageGL.contextGL;

                _super.prototype.iActivate.call(this, stageGL, camera);

                if (this._alphaThreshold > 0) {
                    context.setTextureAt(0, this._alphaMask.getTextureForStageGL(stageGL));
                    context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.FRAGMENT, 0, this._data, 3);
                } else {
                    context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.FRAGMENT, 0, this._data, 2);
                }
            };
            return DepthMapPass;
        })(materials.MaterialPassBase);
        materials.DepthMapPass = DepthMapPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        //import away3d.cameras.Camera;
        //import away3d.core.base.IRenderable;
        //import away3d.base.StageGL;
        //import away3d.core.geom.Matrix3DUtils;
        //import away3d.textures.Texture2DBase;
        //import flash.displayGL.ContextGL;
        //import flash.displayGL.ContextGLProgramType;
        //import flash.displayGL.ContextGLTextureFormat;
        //import flash.geom.Matrix3D;
        //import flash.geom.Vector3D;
        //use namespace arcane;
        /**
        * DistanceMapPass is a pass that writes distance values to a depth map as a 32-bit value exploded over the 4 texture channels.
        * This is used to render omnidirectional shadow maps.
        */
        var DistanceMapPass = (function (_super) {
            __extends(DistanceMapPass, _super);
            /**
            * Creates a new DistanceMapPass object.
            */
            function DistanceMapPass() {
                _super.call(this);

                this._fragmentData = new Array(1.0, 255.0, 65025.0, 16581375.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0, 0.0, 0.0, 0.0, 0.0);
                this._vertexData = new Array(4);
                this._vertexData[3] = 1;
                this._pNumUsedVertexConstants = 9;
            }
            Object.defineProperty(DistanceMapPass.prototype, "alphaThreshold", {
                get: /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                function () {
                    return this._alphaThreshold;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;
else if (value > 1)
                        value = 1;

                    if (value == this._alphaThreshold)
                        return;

                    if (value == 0 || this._alphaThreshold == 0)
                        this.iInvalidateShaderProgram();

                    this._alphaThreshold = value;
                    this._fragmentData[8] = this._alphaThreshold;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DistanceMapPass.prototype, "alphaMask", {
                get: /**
                * A texture providing alpha data to be able to prevent semi-transparent pixels to write to the alpha mask.
                * Usually the diffuse texture when alphaThreshold is used.
                */
                function () {
                    return this._alphaMask;
                },
                set: function (value) {
                    this._alphaMask = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DistanceMapPass.prototype.iGetVertexCode = function () {
                //TODO: AGAL<> GLSL
                var code;
                code = "m44 op, vt0, vc0		\n" + "m44 vt1, vt0, vc5		\n" + "sub v0, vt1, vc9		\n";

                if (this._alphaThreshold > 0) {
                    code += "mov v1, va1\n";

                    this._pNumUsedTextures = 1;
                    this._pNumUsedStreams = 2;
                } else {
                    this._pNumUsedTextures = 0;
                    this._pNumUsedStreams = 1;
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            DistanceMapPass.prototype.iGetFragmentCode = function (animationCode) {
                var code;
                var wrap = this._pRepeat ? "wrap" : "clamp";
                var filter;

                if (this._pSmooth)
                    filter = this._pMipmap ? "linear,miplinear" : "linear";
else
                    filter = this._pMipmap ? "nearest,mipnearest" : "nearest";

                //TODO: AGAL<> GLSL
                // squared distance to view
                code = "dp3 ft2.z, v0.xyz, v0.xyz	\n" + "mul ft0, fc0, ft2.z	\n" + "frc ft0, ft0			\n" + "mul ft1, ft0.yzww, fc1	\n";

                if (this._alphaThreshold > 0) {
                    var format;

                    switch (this._alphaMask.format) {
                        case away.gl.ContextGLTextureFormat.COMPRESSED:
                            format = "dxt1,";
                            break;

                        case "compressedAlpha":
                            format = "dxt5,";
                            break;

                        default:
                            format = "";
                    }

                    code += "tex ft3, v1, fs0 <2d," + filter + "," + format + wrap + ">\n" + "sub ft3.w, ft3.w, fc2.x\n" + "kil ft3.w\n";
                }

                code += "sub oc, ft0, ft1		\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            DistanceMapPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                var context = stageGL.contextGL;
                var pos = camera.scenePosition;

                this._vertexData[0] = pos.x;
                this._vertexData[1] = pos.y;
                this._vertexData[2] = pos.z;
                this._vertexData[3] = 1;

                var sceneTransform = renderable.sourceEntity.getRenderSceneTransform(camera);

                context.setProgramConstantsFromMatrix(away.gl.ContextGLProgramType.VERTEX, 5, sceneTransform, true);

                context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.VERTEX, 9, this._vertexData, 1);

                if (this._alphaThreshold > 0)
                    renderable.subGeometry.activateUVBuffer(1, stageGL);

                var matrix = away.geom.Matrix3DUtils.CALCULATION_MATRIX;

                matrix.copyFrom(sceneTransform);
                matrix.append(viewProjection);

                context.setProgramConstantsFromMatrix(away.gl.ContextGLProgramType.VERTEX, 0, matrix, true);
                renderable.subGeometry.activateVertexBuffer(0, stageGL);
                context.drawTriangles(renderable.subGeometry.getIndexBuffer(stageGL), 0, renderable.subGeometry.numTriangles);
            };

            /**
            * @inheritDoc
            */
            DistanceMapPass.prototype.iActivate = function (stageGL, camera) {
                var context = stageGL.contextGL;
                _super.prototype.iActivate.call(this, stageGL, camera);

                var f = camera.projection.far;

                f = 1 / (2 * f * f);

                // sqrt(f*f+f*f) is largest possible distance for any frustum, so we need to divide by it. Rarely a tight fit, but with 32 bits precision, it's enough.
                this._fragmentData[0] = 1 * f;
                this._fragmentData[1] = 255.0 * f;
                this._fragmentData[2] = 65025.0 * f;
                this._fragmentData[3] = 16581375.0 * f;

                if (this._alphaThreshold > 0) {
                    context.setTextureAt(0, this._alphaMask.getTextureForStageGL(stageGL));
                    context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.FRAGMENT, 0, this._fragmentData, 3);
                } else {
                    context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.FRAGMENT, 0, this._fragmentData, 2);
                }
            };
            return DistanceMapPass;
        })(materials.MaterialPassBase);
        materials.DistanceMapPass = DistanceMapPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        //import away3d.cameras.Camera;
        //import away3d.core.base.IRenderable;
        //import away3d.base.StageGL;
        //import away3d.lights.DirectionalLight;
        //import away3d.lights.LightProbe;
        //import away3d.lights.PointLight;
        //import away3d.materials.LightSources;
        //import away3d.materials.MaterialBase;
        //import away3d.materials.compilation.LightingShaderCompiler;
        //import away3d.materials.compilation.ShaderCompiler;
        //import flash.displayGL.ContextGL;
        //import flash.geom.Matrix3D;
        //import flash.geom.Vector3D;
        //use namespace arcane;
        /**
        * LightingPass is a shader pass that uses shader methods to compile a complete program. It only includes the lighting
        * methods. It's used by multipass materials to accumulate lighting passes.
        *
        * @see away3d.materials.MultiPassMaterialBase
        */
        var LightingPass = (function (_super) {
            __extends(LightingPass, _super);
            /**
            * Creates a new LightingPass objects.
            *
            * @param material The material to which this pass belongs.
            */
            function LightingPass(material) {
                _super.call(this, material);
                this._includeCasters = true;
                this._inverseSceneMatrix = new Array();
                this._maxLights = 3;
            }
            Object.defineProperty(LightingPass.prototype, "directionalLightsOffset", {
                get: /**
                * Indicates the offset in the light picker's directional light vector for which to start including lights.
                * This needs to be set before the light picker is assigned.
                */
                function () {
                    return this._directionalLightsOffset;
                },
                set: function (value) {
                    this._directionalLightsOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightingPass.prototype, "pointLightsOffset", {
                get: /**
                * Indicates the offset in the light picker's point light vector for which to start including lights.
                * This needs to be set before the light picker is assigned.
                */
                function () {
                    return this._pointLightsOffset;
                },
                set: function (value) {
                    this._pointLightsOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightingPass.prototype, "lightProbesOffset", {
                get: /**
                * Indicates the offset in the light picker's light probes vector for which to start including lights.
                * This needs to be set before the light picker is assigned.
                */
                function () {
                    return this._lightProbesOffset;
                },
                set: function (value) {
                    this._lightProbesOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            LightingPass.prototype.pCreateCompiler = function (profile) {
                this._maxLights = profile == "baselineConstrained" ? 1 : 3;
                return new materials.LightingShaderCompiler(profile);
            };

            Object.defineProperty(LightingPass.prototype, "includeCasters", {
                get: /**
                * Indicates whether or not shadow casting lights need to be included.
                */
                function () {
                    return this._includeCasters;
                },
                set: function (value) {
                    if (this._includeCasters == value)
                        return;
                    this._includeCasters = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateLights = function () {
                _super.prototype.pUpdateLights.call(this);
                var numDirectionalLightsOld = this._pNumDirectionalLights;
                var numPointLightsOld = this._pNumPointLights;
                var numLightProbesOld = this._pNumLightProbes;

                if (this._pLightPicker) {
                    this._pNumDirectionalLights = this.calculateNumDirectionalLights(this._pLightPicker.numDirectionalLights);
                    this._pNumPointLights = this.calculateNumPointLights(this._pLightPicker.numPointLights);
                    this._pNumLightProbes = this.calculateNumProbes(this._pLightPicker.numLightProbes);

                    if (this._includeCasters) {
                        this._pNumDirectionalLights += this._pLightPicker.numCastingDirectionalLights;
                        this._pNumPointLights += this._pLightPicker.numCastingPointLights;
                    }
                } else {
                    this._pNumDirectionalLights = 0;
                    this._pNumPointLights = 0;
                    this._pNumLightProbes = 0;
                }

                if (numDirectionalLightsOld != this._pNumDirectionalLights || numPointLightsOld != this._pNumPointLights || numLightProbesOld != this._pNumLightProbes)
                    this.iInvalidateShaderProgram();
            };

            /**
            * Calculates the amount of directional lights this material will support.
            * @param numDirectionalLights The maximum amount of directional lights to support.
            * @return The amount of directional lights this material will support, bounded by the amount necessary.
            */
            LightingPass.prototype.calculateNumDirectionalLights = function (numDirectionalLights) {
                return Math.min(numDirectionalLights - this._directionalLightsOffset, this._maxLights);
            };

            /**
            * Calculates the amount of point lights this material will support.
            * @param numDirectionalLights The maximum amount of point lights to support.
            * @return The amount of point lights this material will support, bounded by the amount necessary.
            */
            LightingPass.prototype.calculateNumPointLights = function (numPointLights) {
                var numFree = this._maxLights - this._pNumDirectionalLights;
                return Math.min(numPointLights - this._pointLightsOffset, numFree);
            };

            /**
            * Calculates the amount of light probes this material will support.
            * @param numDirectionalLights The maximum amount of light probes to support.
            * @return The amount of light probes this material will support, bounded by the amount necessary.
            */
            LightingPass.prototype.calculateNumProbes = function (numLightProbes) {
                var numChannels = 0;
                if ((this._pSpecularLightSources & materials.LightSources.PROBES) != 0) {
                    ++numChannels;
                }
                if ((this._pDiffuseLightSources & materials.LightSources.PROBES) != 0)
                    ++numChannels;

                // 4 channels available
                return Math.min(numLightProbes - this._lightProbesOffset, (4 / numChannels) | 0);
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateShaderProperties = function () {
                _super.prototype.pUpdateShaderProperties.call(this);

                var compilerV = this._pCompiler;
                this._tangentSpace = compilerV.tangentSpace;
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateRegisterIndices = function () {
                _super.prototype.pUpdateRegisterIndices.call(this);

                var compilerV = this._pCompiler;
                this._lightVertexConstantIndex = compilerV.lightVertexConstantIndex;
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                renderable.sourceEntity.inverseSceneTransform.copyRawDataTo(this._inverseSceneMatrix);

                if (this._tangentSpace && this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;
                    var x = pos.x;
                    var y = pos.y;
                    var z = pos.z;

                    this._pVertexConstantData[this._pCameraPositionIndex] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z + this._inverseSceneMatrix[12];
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z + this._inverseSceneMatrix[13];
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z + this._inverseSceneMatrix[14];
                }

                _super.prototype.iRender.call(this, renderable, stageGL, camera, viewProjection);
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.iActivate = function (stageGL, camera) {
                _super.prototype.iActivate.call(this, stageGL, camera);

                if (!this._tangentSpace && this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;

                    this._pVertexConstantData[this._pCameraPositionIndex] = pos.x;
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = pos.y;
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = pos.z;
                }
            };

            /**
            * Indicates whether any light probes are used to contribute to the specular shading.
            */
            LightingPass.prototype.usesProbesForSpecular = function () {
                return this._pNumLightProbes > 0 && (this._pSpecularLightSources & materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether any light probes are used to contribute to the diffuse shading.
            */
            LightingPass.prototype.usesProbesForDiffuse = function () {
                return this._pNumLightProbes > 0 && (this._pDiffuseLightSources & materials.LightSources.PROBES) != 0;
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateLightConstants = function () {
                var dirLight;
                var pointLight;
                var i = 0;
                var k = 0;
                var len;
                var dirPos;
                var total = 0;
                var numLightTypes = this._includeCasters ? 2 : 1;
                var l;
                var offset;

                l = this._lightVertexConstantIndex;
                k = this._pLightFragmentConstantIndex;

                var cast = 0;
                var dirLights = this._pLightPicker.directionalLights;
                offset = this._directionalLightsOffset;
                len = this._pLightPicker.directionalLights.length;

                if (offset > len) {
                    cast = 1;
                    offset -= len;
                }

                for (; cast < numLightTypes; ++cast) {
                    if (cast)
                        dirLights = this._pLightPicker.castingDirectionalLights;
                    len = dirLights.length;
                    if (len > this._pNumDirectionalLights)
                        len = this._pNumDirectionalLights;

                    for (i = 0; i < len; ++i) {
                        dirLight = dirLights[offset + i];
                        dirPos = dirLight.sceneDirection;

                        this._pAmbientLightR += dirLight._iAmbientR;
                        this._pAmbientLightG += dirLight._iAmbientG;
                        this._pAmbientLightB += dirLight._iAmbientB;

                        if (this._tangentSpace) {
                            var x = -dirPos.x;
                            var y = -dirPos.y;
                            var z = -dirPos.z;

                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z;
                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z;
                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z;
                            this._pVertexConstantData[l++] = 1;
                        } else {
                            this._pFragmentConstantData[k++] = -dirPos.x;
                            this._pFragmentConstantData[k++] = -dirPos.y;
                            this._pFragmentConstantData[k++] = -dirPos.z;
                            this._pFragmentConstantData[k++] = 1;
                        }

                        this._pFragmentConstantData[k++] = dirLight._iDiffuseR;
                        this._pFragmentConstantData[k++] = dirLight._iDiffuseG;
                        this._pFragmentConstantData[k++] = dirLight._iDiffuseB;
                        this._pFragmentConstantData[k++] = 1;

                        this._pFragmentConstantData[k++] = dirLight._iSpecularR;
                        this._pFragmentConstantData[k++] = dirLight._iSpecularG;
                        this._pFragmentConstantData[k++] = dirLight._iSpecularB;
                        this._pFragmentConstantData[k++] = 1;

                        if (++total == this._pNumDirectionalLights) {
                            // break loop
                            i = len;
                            cast = numLightTypes;
                        }
                    }
                }

                if (this._pNumDirectionalLights > total) {
                    i = k + (this._pNumDirectionalLights - total) * 12;

                    while (k < i) {
                        this._pFragmentConstantData[k++] = 0;
                    }
                }

                total = 0;

                var pointLights = this._pLightPicker.pointLights;
                offset = this._pointLightsOffset;
                len = this._pLightPicker.pointLights.length;

                if (offset > len) {
                    cast = 1;
                    offset -= len;
                } else {
                    cast = 0;
                }

                for (; cast < numLightTypes; ++cast) {
                    if (cast) {
                        pointLights = this._pLightPicker.castingPointLights;
                    }

                    len = pointLights.length;

                    for (i = 0; i < len; ++i) {
                        pointLight = pointLights[offset + i];
                        dirPos = pointLight.scenePosition;

                        this._pAmbientLightR += pointLight._iAmbientR;
                        this._pAmbientLightG += pointLight._iAmbientG;
                        this._pAmbientLightB += pointLight._iAmbientB;

                        if (this._tangentSpace) {
                            x = dirPos.x;
                            y = dirPos.y;
                            z = dirPos.z;

                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z + this._inverseSceneMatrix[12];
                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z + this._inverseSceneMatrix[13];
                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z + this._inverseSceneMatrix[14];
                        } else {
                            this._pVertexConstantData[l++] = dirPos.x;
                            this._pVertexConstantData[l++] = dirPos.y;
                            this._pVertexConstantData[l++] = dirPos.z;
                        }
                        this._pVertexConstantData[l++] = 1;

                        this._pFragmentConstantData[k++] = pointLight._iDiffuseR;
                        this._pFragmentConstantData[k++] = pointLight._iDiffuseG;
                        this._pFragmentConstantData[k++] = pointLight._iDiffuseB;

                        var radius = pointLight._pRadius;
                        this._pFragmentConstantData[k++] = radius * radius;

                        this._pFragmentConstantData[k++] = pointLight._iSpecularR;
                        this._pFragmentConstantData[k++] = pointLight._iSpecularG;
                        this._pFragmentConstantData[k++] = pointLight._iSpecularB;
                        this._pFragmentConstantData[k++] = pointLight._pFallOffFactor;

                        if (++total == this._pNumPointLights) {
                            // break loop
                            i = len;
                            cast = numLightTypes;
                        }
                    }
                }

                if (this._pNumPointLights > total) {
                    i = k + (total - this._pNumPointLights) * 12;
                    for (; k < i; ++k) {
                        this._pFragmentConstantData[k] = 0;
                    }
                }
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateProbes = function (stageGL) {
                var context = stageGL.contextGL;
                var probe;
                var lightProbes = this._pLightPicker.lightProbes;
                var weights = this._pLightPicker.lightProbeWeights;
                var len = lightProbes.length - this._lightProbesOffset;
                var addDiff = this.usesProbesForDiffuse();
                var addSpec = (this._pMethodSetup._iSpecularMethod && this.usesProbesForSpecular());

                if (!(addDiff || addSpec))
                    return;

                if (len > this._pNumLightProbes) {
                    len = this._pNumLightProbes;
                }

                for (var i = 0; i < len; ++i) {
                    probe = lightProbes[this._lightProbesOffset + i];

                    if (addDiff) {
                        context.setTextureAt(this._pLightProbeDiffuseIndices[i], probe.diffuseMap.getTextureForStageGL(stageGL));
                    }
                    if (addSpec) {
                        context.setTextureAt(this._pLightProbeSpecularIndices[i], probe.specularMap.getTextureForStageGL(stageGL));
                    }
                }

                for (i = 0; i < len; ++i)
                    this._pFragmentConstantData[this._pProbeWeightsIndex + i] = weights[this._lightProbesOffset + i];
            };
            return LightingPass;
        })(materials.CompiledPass);
        materials.LightingPass = LightingPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * ShadowCasterPass is a shader pass that uses shader methods to compile a complete program. It only draws the lighting
        * contribution for a single shadow-casting light.
        *
        * @see away3d.materials.methods.ShadingMethodBase
        */
        var ShadowCasterPass = (function (_super) {
            __extends(ShadowCasterPass, _super);
            /**
            * Creates a new ShadowCasterPass objects.
            *
            * @param material The material to which this pass belongs.
            */
            function ShadowCasterPass(material) {
                _super.call(this, material);
                this._inverseSceneMatrix = new Array();
            }
            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pCreateCompiler = function (profile) {
                return new materials.LightingShaderCompiler(profile);
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateLights = function () {
                _super.prototype.pUpdateLights.call(this);

                var numPointLights = 0;
                var numDirectionalLights = 0;

                if (this._pLightPicker) {
                    numPointLights = this._pLightPicker.numCastingPointLights > 0 ? 1 : 0;
                    numDirectionalLights = this._pLightPicker.numCastingDirectionalLights > 0 ? 1 : 0;
                } else {
                    numPointLights = 0;
                    numDirectionalLights = 0;
                }

                this._pNumLightProbes = 0;

                if (numPointLights + numDirectionalLights > 1) {
                    throw new Error("Must have exactly one light!");
                }

                if (numPointLights != this._pNumPointLights || numDirectionalLights != this._pNumDirectionalLights) {
                    this._pNumPointLights = numPointLights;
                    this._pNumDirectionalLights = numDirectionalLights;
                    this.iInvalidateShaderProgram();
                }
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateShaderProperties = function () {
                _super.prototype.pUpdateShaderProperties.call(this);

                var c = this._pCompiler;
                this._tangentSpace = c.tangentSpace;
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateRegisterIndices = function () {
                _super.prototype.pUpdateRegisterIndices.call(this);

                var c = this._pCompiler;

                this._lightVertexConstantIndex = c.lightVertexConstantIndex;
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                renderable.sourceEntity.inverseSceneTransform.copyRawDataTo(this._inverseSceneMatrix);

                if (this._tangentSpace && this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;
                    var x = pos.x;
                    var y = pos.y;
                    var z = pos.z;
                    this._pVertexConstantData[this._pCameraPositionIndex] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z + this._inverseSceneMatrix[12];
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z + this._inverseSceneMatrix[13];
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z + this._inverseSceneMatrix[14];
                }

                _super.prototype.iRender.call(this, renderable, stageGL, camera, viewProjection);
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.iActivate = function (stageGL, camera) {
                _super.prototype.iActivate.call(this, stageGL, camera);

                if (!this._tangentSpace && this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;
                    this._pVertexConstantData[this._pCameraPositionIndex] = pos.x;
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = pos.y;
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = pos.z;
                }
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateLightConstants = function () {
                // first dirs, then points
                var dirLight;
                var pointLight;
                var k = 0;
                var l = 0;
                var dirPos;

                l = this._lightVertexConstantIndex;
                k = this._pLightFragmentConstantIndex;

                if (this._pNumDirectionalLights > 0) {
                    dirLight = this._pLightPicker.castingDirectionalLights[0];
                    dirPos = dirLight.sceneDirection;

                    this._pAmbientLightR += dirLight._iAmbientR;
                    this._pAmbientLightG += dirLight._iAmbientG;
                    this._pAmbientLightB += dirLight._iAmbientB;

                    if (this._tangentSpace) {
                        var x = -dirPos.x;
                        var y = -dirPos.y;
                        var z = -dirPos.z;
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z;
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z;
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z;
                        this._pVertexConstantData[l++] = 1;
                    } else {
                        this._pFragmentConstantData[k++] = -dirPos.x;
                        this._pFragmentConstantData[k++] = -dirPos.y;
                        this._pFragmentConstantData[k++] = -dirPos.z;
                        this._pFragmentConstantData[k++] = 1;
                    }

                    this._pFragmentConstantData[k++] = dirLight._iDiffuseR;
                    this._pFragmentConstantData[k++] = dirLight._iDiffuseG;
                    this._pFragmentConstantData[k++] = dirLight._iDiffuseB;
                    this._pFragmentConstantData[k++] = 1;

                    this._pFragmentConstantData[k++] = dirLight._iSpecularR;
                    this._pFragmentConstantData[k++] = dirLight._iSpecularG;
                    this._pFragmentConstantData[k++] = dirLight._iSpecularB;
                    this._pFragmentConstantData[k++] = 1;

                    return;
                }

                if (this._pNumPointLights > 0) {
                    pointLight = this._pLightPicker.castingPointLights[0];

                    dirPos = pointLight.scenePosition;

                    this._pAmbientLightR += pointLight._iAmbientR;
                    this._pAmbientLightG += pointLight._iAmbientG;
                    this._pAmbientLightB += pointLight._iAmbientB;

                    if (this._tangentSpace) {
                        x = dirPos.x;
                        y = dirPos.y;
                        z = dirPos.z;

                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z + this._inverseSceneMatrix[12];
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z + this._inverseSceneMatrix[13];
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z + this._inverseSceneMatrix[14];
                    } else {
                        this._pVertexConstantData[l++] = dirPos.x;
                        this._pVertexConstantData[l++] = dirPos.y;
                        this._pVertexConstantData[l++] = dirPos.z;
                    }
                    this._pVertexConstantData[l++] = 1;

                    this._pFragmentConstantData[k++] = pointLight._iDiffuseR;
                    this._pFragmentConstantData[k++] = pointLight._iDiffuseG;
                    this._pFragmentConstantData[k++] = pointLight._iDiffuseB;
                    this._pFragmentConstantData[k++] = pointLight._pRadius * pointLight._pRadius;

                    this._pFragmentConstantData[k++] = pointLight._iSpecularR;
                    this._pFragmentConstantData[k++] = pointLight._iSpecularG;
                    this._pFragmentConstantData[k++] = pointLight._iSpecularB;
                    this._pFragmentConstantData[k++] = pointLight._pFallOffFactor;
                }
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUsesProbes = function () {
                return false;
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUsesLights = function () {
                return true;
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateProbes = function (stageGL) {
            };
            return ShadowCasterPass;
        })(materials.CompiledPass);
        materials.ShadowCasterPass = ShadowCasterPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * SegmentPass is a material pass that draws wireframe segments.
        */
        var SegmentPass = (function (_super) {
            __extends(SegmentPass, _super);
            /**
            * Creates a new SegmentPass object.
            *
            * @param thickness the thickness of the segments to be drawn.
            */
            function SegmentPass(thickness) {
                _super.call(this);
                this._constants = new Array(0, 0, 0, 0);

                this._calcMatrix = new away.geom.Matrix3D();

                this._thickness = thickness;
                this._constants[1] = 1 / 255;
            }
            /**
            * @inheritDoc
            */
            SegmentPass.prototype.iGetVertexCode = function () {
                return "m44 vt0, va0, vc8			\n" + "m44 vt1, va1, vc8			\n" + "sub vt2, vt1, vt0 			\n" + "slt vt5.x, vt0.z, vc7.z			\n" + "sub vt5.y, vc5.x, vt5.x			\n" + "add vt4.x, vt0.z, vc7.z			\n" + "sub vt4.y, vt0.z, vt1.z			\n" + "seq vt4.z, vt4.y vc6.x			\n" + "add vt4.y, vt4.y, vt4.z			\n" + "div vt4.z, vt4.x, vt4.y			\n" + "mul vt4.xyz, vt4.zzz, vt2.xyz	\n" + "add vt3.xyz, vt0.xyz, vt4.xyz	\n" + "mov vt3.w, vc5.x			\n" + "mul vt0, vt0, vt5.yyyy			\n" + "mul vt3, vt3, vt5.xxxx			\n" + "add vt0, vt0, vt3				\n" + "sub vt2, vt1, vt0 			\n" + "nrm vt2.xyz, vt2.xyz			\n" + "nrm vt5.xyz, vt0.xyz			\n" + "mov vt5.w, vc5.x				\n" + "crs vt3.xyz, vt2, vt5			\n" + "nrm vt3.xyz, vt3.xyz			\n" + "mul vt3.xyz, vt3.xyz, va2.xxx	\n" + "mov vt3.w, vc5.x			\n" + "dp3 vt4.x, vt0, vc6			\n" + "mul vt4.x, vt4.x, vc7.x			\n" + "mul vt3.xyz, vt3.xyz, vt4.xxx	\n" + "add vt0.xyz, vt0.xyz, vt3.xyz	\n" + "m44 op, vt0, vc0			\n" + "mov v0, va3				\n";
            };

            /**
            * @inheritDoc
            */
            SegmentPass.prototype.iGetFragmentCode = function (animationCode) {
                return "mov oc, v0\n";
            };

            /**
            * @inheritDoc
            * todo: keep maps in dictionary per renderable
            */
            SegmentPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                var context = stageGL.contextGL;
                this._calcMatrix.copyFrom(renderable.sourceEntity.sceneTransform);
                this._calcMatrix.append(camera.inverseSceneTransform);

                var subGeometry = (renderable).subGeometry;

                var subSetCount = subGeometry.iSubSetCount;

                if (subGeometry.hasData) {
                    for (var i = 0; i < subSetCount; ++i) {
                        subGeometry.activateVertexBuffer(i, stageGL);
                        context.setProgramConstantsFromMatrix(away.gl.ContextGLProgramType.VERTEX, 8, this._calcMatrix, true);
                        context.drawTriangles(subGeometry.getIndexBuffer(stageGL), 0, subGeometry.numTriangles);
                    }
                }
            };

            /**
            * @inheritDoc
            */
            SegmentPass.prototype.iActivate = function (stageGL, camera) {
                var context = stageGL.contextGL;
                _super.prototype.iActivate.call(this, stageGL, camera);

                if (stageGL.scissorRect)
                    this._constants[0] = this._thickness / Math.min(stageGL.scissorRect.width, stageGL.scissorRect.height);
else
                    this._constants[0] = this._thickness / Math.min(stageGL.width, stageGL.height);

                // value to convert distance from camera to model length per pixel width
                this._constants[2] = camera.projection.near;

                context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.VERTEX, 5, SegmentPass.pONE_VECTOR, 1);
                context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.VERTEX, 6, SegmentPass.pFRONT_VECTOR, 1);
                context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.VERTEX, 7, this._constants, 1);

                // projection matrix
                context.setProgramConstantsFromMatrix(away.gl.ContextGLProgramType.VERTEX, 0, camera.projection.matrix, true);
            };

            /**
            * @inheritDoc
            */
            SegmentPass.prototype.pDeactivate = function (stageGL) {
                var context = stageGL.contextGL;
                context.setVertexBufferAt(0, null);
                context.setVertexBufferAt(1, null);
                context.setVertexBufferAt(2, null);
                context.setVertexBufferAt(3, null);
            };
            SegmentPass.pONE_VECTOR = Array(1, 1, 1, 1);
            SegmentPass.pFRONT_VECTOR = Array(0, 0, -1, 0);
            return SegmentPass;
        })(materials.MaterialPassBase);
        materials.SegmentPass = SegmentPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * SkyboxPass provides a material pass exclusively used to render sky boxes from a cube texture.
        */
        var SkyboxPass = (function (_super) {
            __extends(SkyboxPass, _super);
            /**
            * Creates a new SkyboxPass object.
            */
            function SkyboxPass() {
                _super.call(this);
                this.mipmap = false;
                this._pNumUsedTextures = 1;
                this._vertexData = new Array(0, 0, 0, 0, 1, 1, 1, 1);
            }
            Object.defineProperty(SkyboxPass.prototype, "cubeTexture", {
                get: /**
                * The cube texture to use as the skybox.
                */
                function () {
                    return this._cubeTexture;
                },
                set: function (value) {
                    this._cubeTexture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SkyboxPass.prototype.iGetVertexCode = function () {
                return "mul vt0, va0, vc5		\n" + "add vt0, vt0, vc4		\n" + "m44 op, vt0, vc0		\n" + "mov v0, va0\n";
            };

            /**
            * @inheritDoc
            */
            SkyboxPass.prototype.iGetFragmentCode = function (animationCode) {
                var format;
                switch (this._cubeTexture.format) {
                    case away.gl.ContextGLTextureFormat.COMPRESSED:
                        format = "dxt1,";
                        break;
                    case "compressedAlpha":
                        format = "dxt5,";
                        break;
                    default:
                        format = "";
                }

                var mip = ",mipnone";

                if (this._cubeTexture.hasMipMaps) {
                    mip = ",miplinear";
                }
                return "tex ft0, v0, fs0 <cube," + format + "linear,clamp" + mip + ">	\n" + "mov oc, ft0							\n";
            };

            /**
            * @inheritDoc
            */
            SkyboxPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                var context = stageGL.contextGL;
                var pos = camera.scenePosition;
                this._vertexData[0] = pos.x;
                this._vertexData[1] = pos.y;
                this._vertexData[2] = pos.z;
                this._vertexData[4] = this._vertexData[5] = this._vertexData[6] = camera.projection.far / Math.sqrt(3);
                context.setProgramConstantsFromMatrix(away.gl.ContextGLProgramType.VERTEX, 0, viewProjection, true);
                context.setProgramConstantsFromArray(away.gl.ContextGLProgramType.VERTEX, 4, this._vertexData, 2);
                renderable.subGeometry.activateVertexBuffer(0, stageGL);
                context.drawTriangles(renderable.subGeometry.getIndexBuffer(stageGL), 0, renderable.subGeometry.numTriangles);
            };

            /**
            * @inheritDoc
            */
            SkyboxPass.prototype.iActivate = function (stageGL, camera) {
                _super.prototype.iActivate.call(this, stageGL, camera);
                var context = stageGL.contextGL;
                context.setSamplerStateAt(0, away.gl.ContextGLWrapMode.CLAMP, away.gl.ContextGLTextureFilter.LINEAR, this._cubeTexture.hasMipMaps ? away.gl.ContextGLMipFilter.MIPLINEAR : away.gl.ContextGLMipFilter.MIPNONE);
                context.setDepthTest(false, away.gl.ContextGLCompareMode.LESS);
                context.setTextureAt(0, this._cubeTexture.getTextureForStageGL(stageGL));
            };
            return SkyboxPass;
        })(materials.MaterialPassBase);
        materials.SkyboxPass = SkyboxPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * MethodVO contains data for a given method for the use within a single material.
        * This allows methods to be shared across materials while their non-public state differs.
        */
        var MethodVO = (function () {
            /**
            * Creates a new MethodVO object.
            */
            function MethodVO() {
                this.useLightFallOff = true;
            }
            /**
            * Resets the values of the value object to their "unused" state.
            */
            MethodVO.prototype.reset = function () {
                this.texturesIndex = -1;
                this.vertexConstantsIndex = -1;
                this.fragmentConstantsIndex = -1;

                this.useMipmapping = true;
                this.useSmoothTextures = true;
                this.repeatTextures = false;

                this.needsProjection = false;
                this.needsView = false;
                this.needsNormals = false;
                this.needsTangents = false;
                this.needsUV = false;
                this.needsSecondaryUV = false;
                this.needsGlobalVertexPos = false;
                this.needsGlobalFragmentPos = false;

                this.numLights = 0;
                this.useLightFallOff = true;
            };
            return MethodVO;
        })();
        materials.MethodVO = MethodVO;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.*;
        //import away3d.cameras.*;
        //import away3d.core.base.*;
        //import away3d.managers.*;
        //import away3d.events.*;
        //import away3d.library.assets.*;
        //import away3d.materials.compilation.*;
        //import away3d.materials.passes.*;
        //import away3d.textures.*;
        //import flash.displayGL.*;
        //use namespace arcane;
        /**
        * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile
        * the final shading program.
        */
        var ShadingMethodBase = (function (_super) {
            __extends(ShadingMethodBase, _super);
            /**
            * Create a new ShadingMethodBase object.
            * @param needsNormals Defines whether or not the method requires normals.
            * @param needsView Defines whether or not the method requires the view direction.
            */
            function ShadingMethodBase() {
                _super.call(this);
            }
            /**
            * Initializes the properties for a MethodVO, including register and texture indices.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            */
            ShadingMethodBase.prototype.iInitVO = function (vo) {
            };

            /**
            * Initializes unchanging shader constants using the data from a MethodVO.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            */
            ShadingMethodBase.prototype.iInitConstants = function (vo) {
            };

            Object.defineProperty(ShadingMethodBase.prototype, "iSharedRegisters", {
                get: /**
                * The shared registers created by the compiler and possibly used by methods.
                */
                function () {
                    return this._sharedRegisters;
                },
                set: function (value) {
                    this._sharedRegisters = value;
                },
                enumerable: true,
                configurable: true
            });


            ShadingMethodBase.prototype.setISharedRegisters = function (value) {
                this._sharedRegisters = value;
            };

            Object.defineProperty(ShadingMethodBase.prototype, "passes", {
                get: /**
                * Any passes required that render to a texture used by this method.
                */
                function () {
                    return this._passes;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Cleans up any resources used by the current object.
            */
            ShadingMethodBase.prototype.dispose = function () {
            };

            /**
            * Creates a data container that contains material-dependent data. Provided as a factory method so a custom subtype can be overridden when needed.
            */
            ShadingMethodBase.prototype.iCreateMethodVO = function () {
                return new materials.MethodVO();
            };

            /**
            * Resets the compilation state of the method.
            */
            ShadingMethodBase.prototype.iReset = function () {
                this.iCleanCompilationData();
            };

            /**
            * Resets the method's state for compilation.
            * @private
            */
            ShadingMethodBase.prototype.iCleanCompilationData = function () {
            };

            /**
            * Get the vertex shader code for this method.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            * @private
            */
            ShadingMethodBase.prototype.iGetVertexCode = function (vo, regCache) {
                return "";
            };

            /**
            * Sets the render state for this method.
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param stageGL The StageGL object currently used for rendering.
            * @private
            */
            ShadingMethodBase.prototype.iActivate = function (vo, stageGL) {
            };

            /**
            * Sets the render state for a single renderable.
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param renderable The renderable currently being rendered.
            * @param stageGL The StageGL object currently used for rendering.
            * @param camera The camera from which the scene is currently rendered.
            */
            ShadingMethodBase.prototype.iSetRenderState = function (vo, renderable, stageGL, camera) {
            };

            /**
            * Clears the render state for this method.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param stageGL The StageGL object currently used for rendering.
            */
            ShadingMethodBase.prototype.iDeactivate = function (vo, stageGL) {
            };

            /**
            * A helper method that generates standard code for sampling from a texture using the normal uv coordinates.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param targetReg The register in which to store the sampled colour.
            * @param inputReg The texture stream register.
            * @param texture The texture which will be assigned to the given slot.
            * @param uvReg An optional uv register if coordinates different from the primary uv coordinates are to be used.
            * @param forceWrap If true, texture wrapping is enabled regardless of the material setting.
            * @return The fragment code that performs the sampling.
            */
            ShadingMethodBase.prototype.pGetTex2DSampleCode = function (vo, targetReg, inputReg, texture, uvReg, forceWrap) {
                if (typeof uvReg === "undefined") { uvReg = null; }
                if (typeof forceWrap === "undefined") { forceWrap = null; }
                var wrap = forceWrap || (vo.repeatTextures ? "wrap" : "clamp");
                var filter;

                var format = this.getFormatStringForTexture(texture);
                var enableMipMaps = vo.useMipmapping && texture.hasMipMaps;

                if (vo.useSmoothTextures)
                    filter = enableMipMaps ? "linear,miplinear" : "linear";
else
                    filter = enableMipMaps ? "nearest,mipnearest" : "nearest";

                if (uvReg == null)
                    uvReg = this._sharedRegisters.uvVarying;

                return "tex " + targetReg + ", " + uvReg + ", " + inputReg + " <2d," + filter + "," + format + wrap + ">\n";
            };

            /**
            * A helper method that generates standard code for sampling from a cube texture.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param targetReg The register in which to store the sampled colour.
            * @param inputReg The texture stream register.
            * @param texture The cube map which will be assigned to the given slot.
            * @param uvReg The direction vector with which to sample the cube map.
            */
            ShadingMethodBase.prototype.pGetTexCubeSampleCode = function (vo, targetReg, inputReg, texture, uvReg) {
                var filter;
                var format = this.getFormatStringForTexture(texture);
                var enableMipMaps = vo.useMipmapping && texture.hasMipMaps;

                if (vo.useSmoothTextures)
                    filter = enableMipMaps ? "linear,miplinear" : "linear";
else
                    filter = enableMipMaps ? "nearest,mipnearest" : "nearest";

                return "tex " + targetReg + ", " + uvReg + ", " + inputReg + " <cube," + format + filter + ">\n";
            };

            /**
            * Generates a texture format string for the sample instruction.
            * @param texture The texture for which to get the format string.
            * @return
            */
            ShadingMethodBase.prototype.getFormatStringForTexture = function (texture) {
                switch (texture.format) {
                    case away.gl.ContextGLTextureFormat.COMPRESSED:
                        return "dxt1,";
                        break;
                    case "compressedAlpha":
                        return "dxt5,";
                        break;
                    default:
                        return "";
                }
            };

            /**
            * Marks the shader program as invalid, so it will be recompiled before the next render.
            */
            ShadingMethodBase.prototype.iInvalidateShaderProgram = function () {
                this.dispatchEvent(new away.events.ShadingMethodEvent(away.events.ShadingMethodEvent.SHADER_INVALIDATED));
            };

            /**
            * Copies the state from a ShadingMethodBase object into the current object.
            */
            ShadingMethodBase.prototype.copyFrom = function (method) {
            };
            return ShadingMethodBase;
        })(away.library.NamedAssetBase);
        materials.ShadingMethodBase = ShadingMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,
        * and are in essence post-process effects on the materials.
        */
        var EffectMethodBase = (function (_super) {
            __extends(EffectMethodBase, _super);
            function EffectMethodBase() {
                _super.call(this);
            }
            Object.defineProperty(EffectMethodBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.EFFECTS_METHOD;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param regCache The register cache used during the compilation.
            * @param targetReg The register that will be containing the method's output.
            * @private
            */
            EffectMethodBase.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                throw new away.errors.AbstractMethodError();
                return "";
            };
            return EffectMethodBase;
        })(materials.ShadingMethodBase);
        materials.EffectMethodBase = EffectMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        /**
        * MethodVOSet provides a EffectMethodBase and MethodVO combination to be used by a material, allowing methods
        * to be shared across different materials while their internal state changes.
        */
        var MethodVOSet = (function () {
            /**
            * Creates a new MethodVOSet object.
            * @param method The method for which we need to store a MethodVO object.
            */
            function MethodVOSet(method) {
                this.method = method;
                this.data = method.iCreateMethodVO();
            }
            return MethodVOSet;
        })();
        materials.MethodVOSet = MethodVOSet;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var Delegate = away.utils.Delegate;

        var ShadingMethodEvent = away.events.ShadingMethodEvent;

        /**
        * ShaderMethodSetup contains the method configuration for an entire material.
        */
        var ShaderMethodSetup = (function (_super) {
            __extends(ShaderMethodSetup, _super);
            /**
            * Creates a new <code>ShaderMethodSetup</code> object.
            */
            function ShaderMethodSetup() {
                _super.call(this);

                this._onShaderInvalidatedDelegate = Delegate.create(this, this.onShaderInvalidated);

                this._iMethods = new Array();
                this._iNormalMethod = new materials.BasicNormalMethod();
                this._iAmbientMethod = new materials.BasicAmbientMethod();
                this._iDiffuseMethod = new materials.BasicDiffuseMethod();
                this._iSpecularMethod = new materials.BasicSpecularMethod();

                this._iNormalMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                this._iDiffuseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                this._iSpecularMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                this._iAmbientMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                this._iNormalMethodVO = this._iNormalMethod.iCreateMethodVO();
                this._iAmbientMethodVO = this._iAmbientMethod.iCreateMethodVO();
                this._iDiffuseMethodVO = this._iDiffuseMethod.iCreateMethodVO();
                this._iSpecularMethodVO = this._iSpecularMethod.iCreateMethodVO();
            }
            /**
            * Called when any method's code is invalidated.
            */
            ShaderMethodSetup.prototype.onShaderInvalidated = function (event) {
                this.invalidateShaderProgram();
            };

            /**
            * Invalidates the material's shader code.
            */
            ShaderMethodSetup.prototype.invalidateShaderProgram = function () {
                this.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));
            };

            Object.defineProperty(ShaderMethodSetup.prototype, "normalMethod", {
                get: /**
                *  The method used to generate the per-pixel normals.
                */
                function () {
                    return this._iNormalMethod;
                },
                set: function (value) {
                    if (this._iNormalMethod)
                        this._iNormalMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                    if (value) {
                        if (this._iNormalMethod)
                            value.copyFrom(this._iNormalMethod);

                        this._iNormalMethodVO = value.iCreateMethodVO();
                        value.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    }

                    this._iNormalMethod = value;

                    if (value)
                        this.invalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "ambientMethod", {
                get: /**
                * The method that provides the ambient lighting contribution.
                */
                function () {
                    return this._iAmbientMethod;
                },
                set: function (value) {
                    if (this._iAmbientMethod)
                        this._iAmbientMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                    if (value) {
                        if (this._iAmbientMethod)
                            value.copyFrom(this._iAmbientMethod);

                        value.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                        this._iAmbientMethodVO = value.iCreateMethodVO();
                    }

                    this._iAmbientMethod = value;

                    if (value)
                        this.invalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "shadowMethod", {
                get: /**
                * The method used to render shadows cast on this surface, or null if no shadows are to be rendered.
                */
                function () {
                    return this._iShadowMethod;
                },
                set: function (value) {
                    if (this._iShadowMethod)
                        this._iShadowMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                    this._iShadowMethod = value;

                    if (this._iShadowMethod) {
                        this._iShadowMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                        this._iShadowMethodVO = this._iShadowMethod.iCreateMethodVO();
                    } else {
                        this._iShadowMethodVO = null;
                    }

                    this.invalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "diffuseMethod", {
                get: /**
                * The method that provides the diffuse lighting contribution.
                */
                function () {
                    return this._iDiffuseMethod;
                },
                set: function (value) {
                    if (this._iDiffuseMethod)
                        this._iDiffuseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                    if (value) {
                        if (this._iDiffuseMethod)
                            value.copyFrom(this._iDiffuseMethod);

                        value.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                        this._iDiffuseMethodVO = value.iCreateMethodVO();
                    }

                    this._iDiffuseMethod = value;

                    if (value)
                        this.invalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "specularMethod", {
                get: /**
                * The method to perform specular shading.
                */
                function () {
                    return this._iSpecularMethod;
                },
                set: function (value) {
                    if (this._iSpecularMethod) {
                        this._iSpecularMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                        if (value)
                            value.copyFrom(this._iSpecularMethod);
                    }

                    this._iSpecularMethod = value;

                    if (this._iSpecularMethod) {
                        this._iSpecularMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                        this._iSpecularMethodVO = this._iSpecularMethod.iCreateMethodVO();
                    } else {
                        this._iSpecularMethodVO = null;
                    }

                    this.invalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "iColorTransformMethod", {
                get: /**
                * @private
                */
                function () {
                    return this._iColorTransformMethod;
                },
                set: function (value) {
                    if (this._iColorTransformMethod == value)
                        return;

                    if (this._iColorTransformMethod)
                        this._iColorTransformMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                    if (!this._iColorTransformMethod || !value)
                        this.invalidateShaderProgram();

                    this._iColorTransformMethod = value;

                    if (this._iColorTransformMethod) {
                        this._iColorTransformMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                        this._iColorTransformMethodVO = this._iColorTransformMethod.iCreateMethodVO();
                    } else {
                        this._iColorTransformMethodVO = null;
                    }
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Disposes the object.
            */
            ShaderMethodSetup.prototype.dispose = function () {
                this.clearListeners(this._iNormalMethod);
                this.clearListeners(this._iDiffuseMethod);
                this.clearListeners(this._iShadowMethod);
                this.clearListeners(this._iAmbientMethod);
                this.clearListeners(this._iSpecularMethod);

                for (var i = 0; i < this._iMethods.length; ++i)
                    this.clearListeners(this._iMethods[i].method);

                this._iMethods = null;
            };

            /**
            * Removes all listeners from a method.
            */
            ShaderMethodSetup.prototype.clearListeners = function (method) {
                if (method)
                    method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            };

            /**
            * Adds a method to change the material after all lighting is performed.
            * @param method The method to be added.
            */
            ShaderMethodSetup.prototype.addMethod = function (method) {
                this._iMethods.push(new materials.MethodVOSet(method));

                method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                this.invalidateShaderProgram();
            };

            /**
            * Queries whether a given effect method was added to the material.
            *
            * @param method The method to be queried.
            * @return true if the method was added to the material, false otherwise.
            */
            ShaderMethodSetup.prototype.hasMethod = function (method) {
                return this.getMethodSetForMethod(method) != null;
            };

            /**
            * Inserts a method to change the material after all lighting is performed at the given index.
            * @param method The method to be added.
            * @param index The index of the method's occurrence
            */
            ShaderMethodSetup.prototype.addMethodAt = function (method, index) {
                this._iMethods.splice(index, 0, new materials.MethodVOSet(method));

                method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                this.invalidateShaderProgram();
            };

            /**
            * Returns the method added at the given index.
            * @param index The index of the method to retrieve.
            * @return The method at the given index.
            */
            ShaderMethodSetup.prototype.getMethodAt = function (index) {
                if (index > this._iMethods.length - 1)
                    return null;

                return this._iMethods[index].method;
            };

            Object.defineProperty(ShaderMethodSetup.prototype, "numMethods", {
                get: /**
                * The number of "effect" methods added to the material.
                */
                function () {
                    return this._iMethods.length;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Removes a method from the pass.
            * @param method The method to be removed.
            */
            ShaderMethodSetup.prototype.removeMethod = function (method) {
                var methodSet = this.getMethodSetForMethod(method);

                if (methodSet != null) {
                    var index = this._iMethods.indexOf(methodSet);

                    this._iMethods.splice(index, 1);

                    method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                    this.invalidateShaderProgram();
                }
            };

            ShaderMethodSetup.prototype.getMethodSetForMethod = function (method) {
                var len = this._iMethods.length;

                for (var i = 0; i < len; ++i)
                    if (this._iMethods[i].method == method)
                        return this._iMethods[i];

                return null;
            };
            return ShaderMethodSetup;
        })(away.events.EventDispatcher);
        materials.ShaderMethodSetup = ShaderMethodSetup;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        //import away3d.materials.compilation.ShaderRegisterCache;
        //import away3d.materials.compilation.ShaderRegisterElement;
        //use namespace arcane;
        /**
        * LightingMethodBase provides an abstract base method for shading methods that uses lights.
        * Used for diffuse and specular shaders only.
        */
        var LightingMethodBase = (function (_super) {
            __extends(LightingMethodBase, _super);
            /**
            * Creates a new LightingMethodBase.
            */
            function LightingMethodBase() {
                _super.call(this);
            }
            /**
            * Get the fragment shader code that will be needed before any per-light code is added.
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param regCache The register cache used during the compilation.
            * @private
            */
            LightingMethodBase.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                return "";
            };

            /**
            * Get the fragment shader code that will generate the code relevant to a single light.
            *
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param lightDirReg The register containing the light direction vector.
            * @param lightColReg The register containing the light colour.
            * @param regCache The register cache used during the compilation.
            */
            LightingMethodBase.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                return "";
            };

            /**
            * Get the fragment shader code that will generate the code relevant to a single light probe object.
            *
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param cubeMapReg The register containing the cube map for the current probe
            * @param weightRegister A string representation of the register + component containing the current weight
            * @param regCache The register cache providing any necessary registers to the shader
            */
            LightingMethodBase.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                return "";
            };

            /**
            * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.
            *
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param regCache The register cache used during the compilation.
            * @param targetReg The register containing the final shading output.
            * @private
            */
            LightingMethodBase.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                return "";
            };
            return LightingMethodBase;
        })(materials.ShadingMethodBase);
        materials.LightingMethodBase = LightingMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.*;
        //import away3d.errors.*;
        //import away3d.library.assets.*;
        //import away3d.lights.*;
        //import away3d.lights.shadowmaps.*;
        //import away3d.materials.compilation.*;
        //use namespace arcane;
        /**
        * ShadowMapMethodBase provides an abstract base method for shadow map methods.
        */
        var ShadowMapMethodBase = (function (_super) {
            __extends(ShadowMapMethodBase, _super);
            /**
            * Creates a new ShadowMapMethodBase object.
            * @param castingLight The light used to cast shadows.
            */
            function ShadowMapMethodBase(castingLight) {
                _super.call(this);
                this._pEpsilon = .02;
                this._pAlpha = 1;
                this._pCastingLight = castingLight;
                castingLight.castsShadows = true;
                this._pShadowMapper = castingLight.shadowMapper;
            }
            Object.defineProperty(ShadowMapMethodBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.SHADOW_MAP_METHOD;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShadowMapMethodBase.prototype, "alpha", {
                get: /**
                * The "transparency" of the shadows. This allows making shadows less strong.
                */
                function () {
                    return this._pAlpha;
                },
                set: function (value) {
                    this._pAlpha = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShadowMapMethodBase.prototype, "castingLight", {
                get: /**
                * The light casting the shadows.
                */
                function () {
                    return this._pCastingLight;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShadowMapMethodBase.prototype, "epsilon", {
                get: /**
                * A small value to counter floating point precision errors when comparing values in the shadow map with the
                * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.
                */
                function () {
                    return this._pEpsilon;
                },
                set: function (value) {
                    this._pEpsilon = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ShadowMapMethodBase.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                throw new away.errors.AbstractMethodError();
                return null;
            };
            return ShadowMapMethodBase;
        })(materials.ShadingMethodBase);
        materials.ShadowMapMethodBase = ShadowMapMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * SimpleShadowMapMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.
        */
        var SimpleShadowMapMethodBase = (function (_super) {
            __extends(SimpleShadowMapMethodBase, _super);
            /**
            * Creates a new SimpleShadowMapMethodBase object.
            * @param castingLight The light used to cast shadows.
            */
            function SimpleShadowMapMethodBase(castingLight) {
                this._pUsePoint = (castingLight instanceof away.lights.PointLight);
                _super.call(this, castingLight);
            }
            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iInitVO = function (vo) {
                vo.needsView = true;
                vo.needsGlobalVertexPos = true;
                vo.needsGlobalFragmentPos = this._pUsePoint;
                vo.needsNormals = vo.numLights > 0;
            };

            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iInitConstants = function (vo) {
                var fragmentData = vo.fragmentData;
                var vertexData = vo.vertexData;
                var index = vo.fragmentConstantsIndex;
                fragmentData[index] = 1.0;
                fragmentData[index + 1] = 1 / 255.0;
                fragmentData[index + 2] = 1 / 65025.0;
                fragmentData[index + 3] = 1 / 16581375.0;

                fragmentData[index + 6] = 0;
                fragmentData[index + 7] = 1;

                if (this._pUsePoint) {
                    fragmentData[index + 8] = 0;
                    fragmentData[index + 9] = 0;
                    fragmentData[index + 10] = 0;
                    fragmentData[index + 11] = 1;
                }

                index = vo.vertexConstantsIndex;
                if (index != -1) {
                    vertexData[index] = .5;
                    vertexData[index + 1] = .5;
                    vertexData[index + 2] = 0.0;
                    vertexData[index + 3] = 1.0;
                }
            };

            Object.defineProperty(SimpleShadowMapMethodBase.prototype, "_iDepthMapCoordReg", {
                get: /**
                * Wrappers that override the vertex shader need to set this explicitly
                */
                function () {
                    return this._pDepthMapCoordReg;
                },
                set: function (value) {
                    this._pDepthMapCoordReg = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);

                this._pDepthMapCoordReg = null;
            };

            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iGetVertexCode = function (vo, regCache) {
                return this._pUsePoint ? this._pGetPointVertexCode(vo, regCache) : this.pGetPlanarVertexCode(vo, regCache);
            };

            /**
            * Gets the vertex code for shadow mapping with a point light.
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            */
            SimpleShadowMapMethodBase.prototype._pGetPointVertexCode = function (vo, regCache) {
                vo.vertexConstantsIndex = -1;
                return "";
            };

            /**
            * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            */
            SimpleShadowMapMethodBase.prototype.pGetPlanarVertexCode = function (vo, regCache) {
                var code = "";
                var temp = regCache.getFreeVertexVectorTemp();
                var dataReg = regCache.getFreeVertexConstant();
                var depthMapProj = regCache.getFreeVertexConstant();
                regCache.getFreeVertexConstant();
                regCache.getFreeVertexConstant();
                regCache.getFreeVertexConstant();
                this._pDepthMapCoordReg = regCache.getFreeVarying();
                vo.vertexConstantsIndex = dataReg.index * 4;

                // todo: can epsilon be applied here instead of fragment shader?
                code += "m44 " + temp + ", " + this._sharedRegisters.globalPositionVertex + ", " + depthMapProj + "\n" + "div " + temp + ", " + temp + ", " + temp + ".w\n" + "mul " + temp + ".xy, " + temp + ".xy, " + dataReg + ".xy\n" + "add " + this._pDepthMapCoordReg + ", " + temp + ", " + dataReg + ".xxwz\n";

                //"sub " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".w\n";
                return code;
            };

            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = this._pUsePoint ? this._pGetPointFragmentCode(vo, regCache, targetReg) : this._pGetPlanarFragmentCode(vo, regCache, targetReg);
                code += "add " + targetReg + ".w, " + targetReg + ".w, fc" + (vo.fragmentConstantsIndex / 4 + 1) + ".y\n" + "sat " + targetReg + ".w, " + targetReg + ".w\n";
                return code;
            };

            /**
            * Gets the fragment code for shadow mapping with a planar shadow map.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            * @param targetReg The register to contain the shadow coverage
            * @return
            */
            SimpleShadowMapMethodBase.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                throw new away.errors.AbstractMethodError();
                return "";
            };

            /**
            * Gets the fragment code for shadow mapping with a point light.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            * @param targetReg The register to contain the shadow coverage
            * @return
            */
            SimpleShadowMapMethodBase.prototype._pGetPointFragmentCode = function (vo, regCache, targetReg) {
                throw new away.errors.AbstractMethodError();
                return "";
            };

            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iSetRenderState = function (vo, renderable, stageGL, camera) {
                if (!this._pUsePoint)
                    (this._pShadowMapper).iDepthProjection.copyRawDataTo(vo.vertexData, vo.vertexConstantsIndex + 4, true);
            };

            /**
            * Gets the fragment code for combining this method with a cascaded shadow map method.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            * @param decodeRegister The register containing the data to decode the shadow map depth value.
            * @param depthTexture The texture containing the shadow map.
            * @param depthProjection The projection of the fragment relative to the light.
            * @param targetRegister The register to contain the shadow coverage
            * @return
            */
            SimpleShadowMapMethodBase.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                throw new Error("This shadow method is incompatible with cascade shadows");
            };

            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iActivate = function (vo, stageGL) {
                var fragmentData = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;

                if (this._pUsePoint)
                    fragmentData[index + 4] = -Math.pow(1 / ((this._pCastingLight).fallOff * this._pEpsilon), 2);
else
                    vo.vertexData[vo.vertexConstantsIndex + 3] = -1 / ((this._pShadowMapper).depth * this._pEpsilon);

                fragmentData[index + 5] = 1 - this._pAlpha;
                if (this._pUsePoint) {
                    var pos = this._pCastingLight.scenePosition;
                    fragmentData[index + 8] = pos.x;
                    fragmentData[index + 9] = pos.y;
                    fragmentData[index + 10] = pos.z;

                    // used to decompress distance
                    var f = (this._pCastingLight).fallOff;
                    fragmentData[index + 11] = 1 / (2 * f * f);
                }
                stageGL.contextGL.setTextureAt(vo.texturesIndex, this._pCastingLight.shadowMapper.depthMap.getTextureForStageGL(stageGL));
            };

            /**
            * Sets the method state for cascade shadow mapping.
            */
            SimpleShadowMapMethodBase.prototype.iActivateForCascade = function (vo, stageGL) {
                throw new Error("This shadow method is incompatible with cascade shadows");
            };
            return SimpleShadowMapMethodBase;
        })(materials.ShadowMapMethodBase);
        materials.SimpleShadowMapMethodBase = SimpleShadowMapMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * DitheredShadowMapMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison
        * results of neighbouring pixels.
        */
        var FilteredShadowMapMethod = (function (_super) {
            __extends(FilteredShadowMapMethod, _super);
            /**
            * Creates a new BasicDiffuseMethod object.
            *
            * @param castingLight The light casting the shadow
            */
            function FilteredShadowMapMethod(castingLight) {
                _super.call(this, castingLight);
            }
            /**
            * @inheritDoc
            */
            FilteredShadowMapMethod.prototype.iInitConstants = function (vo) {
                _super.prototype.iInitConstants.call(this, vo);

                var fragmentData = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                fragmentData[index + 8] = .5;
                var size = this.castingLight.shadowMapper.depthMapSize;
                fragmentData[index + 9] = size;
                fragmentData[index + 10] = 1 / size;
            };

            /**
            * @inheritDoc
            */
            FilteredShadowMapMethod.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var dataReg = regCache.getFreeFragmentConstant();

                // TODO: not used
                dataReg = dataReg;
                var customDataReg = regCache.getFreeFragmentConstant();
                var depthCol = regCache.getFreeFragmentVectorTemp();
                var uvReg;
                var code = "";
                vo.fragmentConstantsIndex = decReg.index * 4;

                regCache.addFragmentTempUsages(depthCol, 1);

                uvReg = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(uvReg, 1);

                code += "mov " + uvReg + ", " + this._pDepthMapCoordReg + "\n" + "tex " + depthCol + ", " + this._pDepthMapCoordReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + uvReg + ".z, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" + "add " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".z\n" + "tex " + depthCol + ", " + uvReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + uvReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" + "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".y\n" + "frc " + depthCol + ".x, " + depthCol + ".x\n" + "sub " + uvReg + ".w, " + uvReg + ".w, " + uvReg + ".z\n" + "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" + "add " + targetReg + ".w, " + uvReg + ".z, " + uvReg + ".w\n" + "mov " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x\n" + "add " + uvReg + ".y, " + this._pDepthMapCoordReg + ".y, " + customDataReg + ".z\n" + "tex " + depthCol + ", " + uvReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + uvReg + ".z, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" + "add " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".z\n" + "tex " + depthCol + ", " + uvReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + uvReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" + "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".y\n" + "frc " + depthCol + ".x, " + depthCol + ".x\n" + "sub " + uvReg + ".w, " + uvReg + ".w, " + uvReg + ".z\n" + "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" + "add " + uvReg + ".w, " + uvReg + ".z, " + uvReg + ".w\n" + "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".y, " + customDataReg + ".y\n" + "frc " + depthCol + ".x, " + depthCol + ".x\n" + "sub " + uvReg + ".w, " + uvReg + ".w, " + targetReg + ".w\n" + "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" + "add " + targetReg + ".w, " + targetReg + ".w, " + uvReg + ".w\n";

                regCache.removeFragmentTempUsage(depthCol);
                regCache.removeFragmentTempUsage(uvReg);

                vo.texturesIndex = depthMapRegister.index;

                return code;
            };

            /**
            * @inheritDoc
            */
            FilteredShadowMapMethod.prototype.iActivateForCascade = function (vo, stageGL) {
                var size = this.castingLight.shadowMapper.depthMapSize;
                var index = vo.secondaryFragmentConstantsIndex;
                var data = vo.fragmentData;
                data[index] = size;
                data[index + 1] = 1 / size;
            };

            /**
            * @inheritDoc
            */
            FilteredShadowMapMethod.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                var code;
                var dataReg = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = dataReg.index * 4;
                var temp = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(temp, 1);
                var predicate = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(predicate, 1);

                code = "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + predicate + ".x, " + depthProjection + ".z, " + temp + ".z\n" + "add " + depthProjection + ".x, " + depthProjection + ".x, " + dataReg + ".y\n" + "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + predicate + ".z, " + depthProjection + ".z, " + temp + ".z\n" + "add " + depthProjection + ".y, " + depthProjection + ".y, " + dataReg + ".y\n" + "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + predicate + ".w, " + depthProjection + ".z, " + temp + ".z\n" + "sub " + depthProjection + ".x, " + depthProjection + ".x, " + dataReg + ".y\n" + "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + predicate + ".y, " + depthProjection + ".z, " + temp + ".z\n" + "mul " + temp + ".xy, " + depthProjection + ".xy, " + dataReg + ".x\n" + "frc " + temp + ".xy, " + temp + ".xy\n" + "sub " + depthProjection + ", " + predicate + ".xyzw, " + predicate + ".zwxy\n" + "mul " + depthProjection + ", " + depthProjection + ", " + temp + ".x\n" + "add " + predicate + ".xy, " + predicate + ".xy, " + depthProjection + ".zw\n" + "sub " + predicate + ".y, " + predicate + ".y, " + predicate + ".x\n" + "mul " + predicate + ".y, " + predicate + ".y, " + temp + ".y\n" + "add " + targetRegister + ".w, " + predicate + ".x, " + predicate + ".y\n";

                regCache.removeFragmentTempUsage(temp);
                regCache.removeFragmentTempUsage(predicate);
                return code;
            };
            return FilteredShadowMapMethod;
        })(materials.SimpleShadowMapMethodBase);
        materials.FilteredShadowMapMethod = FilteredShadowMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var StageGL = away.base.StageGL;

        /**
        * FogMethod provides a method to add distance-based fog to a material.
        */
        var FogMethod = (function (_super) {
            __extends(FogMethod, _super);
            /**
            * Creates a new FogMethod object.
            * @param minDistance The distance from which the fog starts appearing.
            * @param maxDistance The distance at which the fog is densest.
            * @param fogColor The colour of the fog.
            */
            function FogMethod(minDistance, maxDistance, fogColor) {
                if (typeof fogColor === "undefined") { fogColor = 0x808080; }
                _super.call(this);
                this._minDistance = 0;
                this._maxDistance = 1000;
                this.minDistance = minDistance;
                this.maxDistance = maxDistance;
                this.fogColor = fogColor;
            }
            /**
            * @inheritDoc
            */
            FogMethod.prototype.iInitVO = function (vo) {
                vo.needsProjection = true;
            };

            /**
            * @inheritDoc
            */
            FogMethod.prototype.iInitConstants = function (vo) {
                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                data[index + 3] = 1;
                data[index + 6] = 0;
                data[index + 7] = 0;
            };

            Object.defineProperty(FogMethod.prototype, "minDistance", {
                get: /**
                * The distance from which the fog starts appearing.
                */
                function () {
                    return this._minDistance;
                },
                set: function (value) {
                    this._minDistance = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(FogMethod.prototype, "maxDistance", {
                get: /**
                * The distance at which the fog is densest.
                */
                function () {
                    return this._maxDistance;
                },
                set: function (value) {
                    this._maxDistance = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(FogMethod.prototype, "fogColor", {
                get: /**
                * The colour of the fog.
                */
                function () {
                    return this._fogColor;
                },
                set: function (value/*uint*/ ) {
                    this._fogColor = value;
                    this._fogR = ((value >> 16) & 0xff) / 0xff;
                    this._fogG = ((value >> 8) & 0xff) / 0xff;
                    this._fogB = (value & 0xff) / 0xff;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            FogMethod.prototype.iActivate = function (vo, stageGL) {
                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                data[index] = this._fogR;
                data[index + 1] = this._fogG;
                data[index + 2] = this._fogB;
                data[index + 4] = this._minDistance;
                data[index + 5] = 1 / (this._maxDistance - this._minDistance);
            };

            /**
            * @inheritDoc
            */
            FogMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var fogColor = regCache.getFreeFragmentConstant();
                var fogData = regCache.getFreeFragmentConstant();
                var temp = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(temp, 1);
                var temp2 = regCache.getFreeFragmentVectorTemp();
                var code = "";
                vo.fragmentConstantsIndex = fogColor.index * 4;

                code += "sub " + temp2 + ".w, " + this._sharedRegisters.projectionFragment + ".z, " + fogData + ".x          \n" + "mul " + temp2 + ".w, " + temp2 + ".w, " + fogData + ".y					\n" + "sat " + temp2 + ".w, " + temp2 + ".w										\n" + "sub " + temp + ", " + fogColor + ", " + targetReg + "\n" + "mul " + temp + ", " + temp + ", " + temp2 + ".w					\n" + "add " + targetReg + ", " + targetReg + ", " + temp + "\n";

                regCache.removeFragmentTempUsage(temp);

                return code;
            };
            return FogMethod;
        })(materials.EffectMethodBase);
        materials.FogMethod = FogMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * HardShadowMapMethod provides the cheapest shadow map method by using a single tap without any filtering.
        */
        var HardShadowMapMethod = (function (_super) {
            __extends(HardShadowMapMethod, _super);
            /**
            * Creates a new HardShadowMapMethod object.
            */
            function HardShadowMapMethod(castingLight) {
                _super.call(this, castingLight);
            }
            /**
            * @inheritDoc
            */
            HardShadowMapMethod.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();

                // needs to be reserved anyway. DO NOT REMOVE
                var dataReg = regCache.getFreeFragmentConstant();

                // TODO not used
                dataReg = dataReg;
                var depthCol = regCache.getFreeFragmentVectorTemp();
                var code = "";

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                code += "tex " + depthCol + ", " + this._pDepthMapCoordReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + targetReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            HardShadowMapMethod.prototype._pGetPointFragmentCode = function (vo, regCache, targetReg) {
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var epsReg = regCache.getFreeFragmentConstant();
                var posReg = regCache.getFreeFragmentConstant();
                var depthSampleCol = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(depthSampleCol, 1);
                var lightDir = regCache.getFreeFragmentVectorTemp();
                var code = "";

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                code += "sub " + lightDir + ", " + this._sharedRegisters.globalPositionVarying + ", " + posReg + "\n" + "dp3 " + lightDir + ".w, " + lightDir + ".xyz, " + lightDir + ".xyz\n" + "mul " + lightDir + ".w, " + lightDir + ".w, " + posReg + ".w\n" + "nrm " + lightDir + ".xyz, " + lightDir + ".xyz\n" + "tex " + depthSampleCol + ", " + lightDir + ", " + depthMapRegister + " <cube, nearest, clamp>\n" + "dp4 " + depthSampleCol + ".z, " + depthSampleCol + ", " + decReg + "\n" + "add " + targetReg + ".w, " + lightDir + ".w, " + epsReg + ".x\n" + "slt " + targetReg + ".w, " + targetReg + ".w, " + depthSampleCol + ".z\n";

                regCache.removeFragmentTempUsage(depthSampleCol);

                return code;
            };

            /**
            * @inheritDoc
            */
            HardShadowMapMethod.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                var temp = regCache.getFreeFragmentVectorTemp();
                return "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + targetRegister + ".w, " + depthProjection + ".z, " + temp + ".z\n";
            };

            /**
            * @inheritDoc
            */
            HardShadowMapMethod.prototype.iActivateForCascade = function (vo, stageGL) {
            };
            return HardShadowMapMethod;
        })(materials.SimpleShadowMapMethodBase);
        materials.HardShadowMapMethod = HardShadowMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * SoftShadowMapMethod provides a soft shadowing technique by randomly distributing sample points.
        */
        var SoftShadowMapMethod = (function (_super) {
            __extends(SoftShadowMapMethod, _super);
            /**
            * Creates a new BasicDiffuseMethod object.
            *
            * @param castingLight The light casting the shadows
            * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.
            */
            function SoftShadowMapMethod(castingLight, numSamples, range) {
                if (typeof numSamples === "undefined") { numSamples = 5; }
                if (typeof range === "undefined") { range = 1; }
                _super.call(this, castingLight);
                this._range = 1;

                this.numSamples = numSamples;
                this.range = range;
            }
            Object.defineProperty(SoftShadowMapMethod.prototype, "numSamples", {
                get: /**
                * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the
                * complexity of the shader.
                */
                function () {
                    return this._numSamples;
                },
                set: function (value/*int*/ ) {
                    this._numSamples = value;
                    if (this._numSamples < 1)
                        this._numSamples = 1;
else if (this._numSamples > 32)
                        this._numSamples = 32;

                    this._offsets = away.geom.PoissonLookup.getDistribution(this._numSamples);
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SoftShadowMapMethod.prototype, "range", {
                get: /**
                * The range in the shadow map in which to distribute the samples.
                */
                function () {
                    return this._range;
                },
                set: function (value) {
                    this._range = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SoftShadowMapMethod.prototype.iInitConstants = function (vo) {
                _super.prototype.iInitConstants.call(this, vo);

                vo.fragmentData[vo.fragmentConstantsIndex + 8] = 1 / this._numSamples;
                vo.fragmentData[vo.fragmentConstantsIndex + 9] = 0;
            };

            /**
            * @inheritDoc
            */
            SoftShadowMapMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);
                var texRange = .5 * this._range / this._pCastingLight.shadowMapper.depthMapSize;
                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex + 10;
                var len = this._numSamples << 1;

                for (var i = 0; i < len; ++i)
                    data[index + i] = this._offsets[i] * texRange;
            };

            /**
            * @inheritDoc
            */
            SoftShadowMapMethod.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                // todo: move some things to super
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var dataReg = regCache.getFreeFragmentConstant();
                var customDataReg = regCache.getFreeFragmentConstant();

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                return this.getSampleCode(regCache, depthMapRegister, decReg, targetReg, customDataReg);
            };

            /**
            * Adds the code for another tap to the shader code.
            * @param uv The uv register for the tap.
            * @param texture The texture register containing the depth map.
            * @param decode The register containing the depth map decoding data.
            * @param target The target register to add the tap comparison result.
            * @param regCache The register cache managing the registers.
            * @return
            */
            SoftShadowMapMethod.prototype.addSample = function (uv, texture, decode, target, regCache) {
                var temp = regCache.getFreeFragmentVectorTemp();
                return "tex " + temp + ", " + uv + ", " + texture + " <2d,nearest,clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decode + "\n" + "slt " + uv + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n" + "add " + target + ".w, " + target + ".w, " + uv + ".w\n";
            };

            /**
            * @inheritDoc
            */
            SoftShadowMapMethod.prototype.iActivateForCascade = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);
                var texRange = this._range / this._pCastingLight.shadowMapper.depthMapSize;
                var data = vo.fragmentData;
                var index = vo.secondaryFragmentConstantsIndex;
                var len = this._numSamples << 1;
                data[index] = 1 / this._numSamples;
                data[index + 1] = 0;
                index += 2;
                for (var i = 0; i < len; ++i)
                    data[index + i] = this._offsets[i] * texRange;

                if (len % 4 == 0) {
                    data[index + len] = 0;
                    data[index + len + 1] = 0;
                }
            };

            /**
            * @inheritDoc
            */
            SoftShadowMapMethod.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                this._pDepthMapCoordReg = depthProjection;

                var dataReg = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = dataReg.index * 4;

                return this.getSampleCode(regCache, depthTexture, decodeRegister, targetRegister, dataReg);
            };

            /**
            * Get the actual shader code for shadow mapping
            * @param regCache The register cache managing the registers.
            * @param depthTexture The texture register containing the depth map.
            * @param decodeRegister The register containing the depth map decoding data.
            * @param targetReg The target register to add the shadow coverage.
            * @param dataReg The register containing additional data.
            */
            SoftShadowMapMethod.prototype.getSampleCode = function (regCache, depthTexture, decodeRegister, targetRegister, dataReg) {
                var uvReg;
                var code;
                var offsets = new Array(dataReg + ".zw");
                uvReg = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(uvReg, 1);

                var temp = regCache.getFreeFragmentVectorTemp();

                var numRegs = this._numSamples >> 1;
                for (var i = 0; i < numRegs; ++i) {
                    var reg = regCache.getFreeFragmentConstant();
                    offsets.push(reg + ".xy");
                    offsets.push(reg + ".zw");
                }

                for (i = 0; i < this._numSamples; ++i) {
                    if (i == 0) {
                        code = "add " + uvReg + ", " + this._pDepthMapCoordReg + ", " + dataReg + ".zwyy\n";
                        code += "tex " + temp + ", " + uvReg + ", " + depthTexture + " <2d,nearest,clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + targetRegister + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n";
                    } else {
                        code += "add " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + offsets[i] + "\n";
                        code += this.addSample(uvReg, depthTexture, decodeRegister, targetRegister, regCache);
                    }
                }

                regCache.removeFragmentTempUsage(uvReg);
                code += "mul " + targetRegister + ".w, " + targetRegister + ".w, " + dataReg + ".x\n";
                return code;
            };
            return SoftShadowMapMethod;
        })(materials.SimpleShadowMapMethodBase);
        materials.SoftShadowMapMethod = SoftShadowMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * DitheredShadowMapMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.
        */
        var DitheredShadowMapMethod = (function (_super) {
            __extends(DitheredShadowMapMethod, _super);
            /**
            * Creates a new DitheredShadowMapMethod object.
            * @param castingLight The light casting the shadows
            * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.
            */
            function DitheredShadowMapMethod(castingLight, numSamples, range) {
                if (typeof numSamples === "undefined") { numSamples = 4; }
                if (typeof range === "undefined") { range = 1; }
                _super.call(this, castingLight);

                this._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;

                this.numSamples = numSamples;
                this.range = range;

                ++DitheredShadowMapMethod._grainUsages;

                if (!DitheredShadowMapMethod._grainTexture)
                    this.initGrainTexture();
            }
            Object.defineProperty(DitheredShadowMapMethod.prototype, "numSamples", {
                get: /**
                * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the
                * complexity of the shader.
                */
                function () {
                    return this._numSamples;
                },
                set: function (value/*int*/ ) {
                    this._numSamples = value;
                    if (this._numSamples < 1)
                        this._numSamples = 1;
else if (this._numSamples > 24)
                        this._numSamples = 24;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype.iInitVO = function (vo) {
                _super.prototype.iInitVO.call(this, vo);
                vo.needsProjection = true;
            };

            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype.iInitConstants = function (vo) {
                _super.prototype.iInitConstants.call(this, vo);

                var fragmentData = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                fragmentData[index + 8] = 1 / this._numSamples;
            };

            Object.defineProperty(DitheredShadowMapMethod.prototype, "range", {
                get: /**
                * The range in the shadow map in which to distribute the samples.
                */
                function () {
                    return this._range * 2;
                },
                set: function (value) {
                    this._range = value / 2;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Creates a texture containing the dithering noise texture.
            */
            DitheredShadowMapMethod.prototype.initGrainTexture = function () {
                DitheredShadowMapMethod._grainBitmapData = new away.base.BitmapData(64, 64, false);
                var vec = new Array();
                var len = 4096;
                var step = 1 / (this._depthMapSize * this._range);
                var r, g;

                for (var i = 0; i < len; ++i) {
                    r = 2 * (Math.random() - .5);
                    g = 2 * (Math.random() - .5);
                    if (r < 0)
                        r -= step;
else
                        r += step;
                    if (g < 0)
                        g -= step;
else
                        g += step;
                    if (r > 1)
                        r = 1;
else if (r < -1)
                        r = -1;
                    if (g > 1)
                        g = 1;
else if (g < -1)
                        g = -1;
                    vec[i] = (Math.floor((r * .5 + .5) * 0xff) << 16) | (Math.floor((g * .5 + .5) * 0xff) << 8);
                }

                DitheredShadowMapMethod._grainBitmapData.setVector(DitheredShadowMapMethod._grainBitmapData.rect, vec);
                DitheredShadowMapMethod._grainTexture = new away.textures.BitmapTexture(DitheredShadowMapMethod._grainBitmapData);
            };

            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype.dispose = function () {
                if (--DitheredShadowMapMethod._grainUsages == 0) {
                    DitheredShadowMapMethod._grainTexture.dispose();
                    DitheredShadowMapMethod._grainBitmapData.dispose();
                    DitheredShadowMapMethod._grainTexture = null;
                }
            };

            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);
                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                data[index + 9] = (stageGL.width - 1) / 63;
                data[index + 10] = (stageGL.height - 1) / 63;
                data[index + 11] = 2 * this._range / this._depthMapSize;
                stageGL.contextGL.setTextureAt(vo.texturesIndex + 1, DitheredShadowMapMethod._grainTexture.getTextureForStageGL(stageGL));
            };

            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var dataReg = regCache.getFreeFragmentConstant();
                var customDataReg = regCache.getFreeFragmentConstant();

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                return this.getSampleCode(regCache, customDataReg, depthMapRegister, decReg, targetReg);
            };

            /**
            * Get the actual shader code for shadow mapping
            * @param regCache The register cache managing the registers.
            * @param depthMapRegister The texture register containing the depth map.
            * @param decReg The register containing the depth map decoding data.
            * @param targetReg The target register to add the shadow coverage.
            */
            DitheredShadowMapMethod.prototype.getSampleCode = function (regCache, customDataReg, depthMapRegister, decReg, targetReg) {
                var code = "";
                var grainRegister = regCache.getFreeTextureReg();
                var uvReg = regCache.getFreeFragmentVectorTemp();
                var numSamples = this._numSamples;
                regCache.addFragmentTempUsages(uvReg, 1);

                var temp = regCache.getFreeFragmentVectorTemp();

                var projectionReg = this._sharedRegisters.projectionFragment;

                code += "div " + uvReg + ", " + projectionReg + ", " + projectionReg + ".w\n" + "mul " + uvReg + ".xy, " + uvReg + ".xy, " + customDataReg + ".yz\n";

                while (numSamples > 0) {
                    if (numSamples == this._numSamples)
                        code += "tex " + uvReg + ", " + uvReg + ", " + grainRegister + " <2d,nearest,repeat,mipnone>\n";
else
                        code += "tex " + uvReg + ", " + uvReg + ".zwxy, " + grainRegister + " <2d,nearest,repeat,mipnone>\n";

                    // keep grain in uvReg.zw
                    code += "sub " + uvReg + ".zw, " + uvReg + ".xy, fc0.xx\n" + "mul " + uvReg + ".zw, " + uvReg + ".zw, " + customDataReg + ".w\n";

                    if (numSamples == this._numSamples) {
                        // first sample
                        code += "add " + uvReg + ".xy, " + uvReg + ".zw, " + this._pDepthMapCoordReg + ".xy\n" + "tex " + temp + ", " + uvReg + ", " + depthMapRegister + " <2d,nearest,clamp,mipnone>\n" + "dp4 " + temp + ".z, " + temp + ", " + decReg + "\n" + "slt " + targetReg + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n";
                    } else
                        code += this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);

                    if (numSamples > 4) {
                        code += "add " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".zw\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 1) {
                        code += "sub " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + uvReg + ".zw\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 5) {
                        code += "sub " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".zw\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 2) {
                        code += "neg " + uvReg + ".w, " + uvReg + ".w\n";

                        code += "add " + uvReg + ".xy, " + uvReg + ".wz, " + this._pDepthMapCoordReg + ".xy\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 6) {
                        code += "add " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".wz\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 3) {
                        code += "sub " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + uvReg + ".wz\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 7) {
                        code += "sub " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".wz\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    numSamples -= 8;
                }

                regCache.removeFragmentTempUsage(uvReg);
                code += "mul " + targetReg + ".w, " + targetReg + ".w, " + customDataReg + ".x\n";
                return code;
            };

            /**
            * Adds the code for another tap to the shader code.
            * @param uvReg The uv register for the tap.
            * @param depthMapRegister The texture register containing the depth map.
            * @param decReg The register containing the depth map decoding data.
            * @param targetReg The target register to add the tap comparison result.
            * @param regCache The register cache managing the registers.
            * @return
            */
            DitheredShadowMapMethod.prototype.addSample = function (uvReg, depthMapRegister, decReg, targetReg, regCache) {
                var temp = regCache.getFreeFragmentVectorTemp();
                return "tex " + temp + ", " + uvReg + ", " + depthMapRegister + " <2d,nearest,clamp,mipnone>\n" + "dp4 " + temp + ".z, " + temp + ", " + decReg + "\n" + "slt " + temp + ".z, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n" + "add " + targetReg + ".w, " + targetReg + ".w, " + temp + ".z\n";
            };

            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype.iActivateForCascade = function (vo, stageGL) {
                var data = vo.fragmentData;
                var index = vo.secondaryFragmentConstantsIndex;
                data[index] = 1 / this._numSamples;
                data[index + 1] = (stageGL.width - 1) / 63;
                data[index + 2] = (stageGL.height - 1) / 63;
                data[index + 3] = 2 * this._range / this._depthMapSize;
                stageGL.contextGL.setTextureAt(vo.texturesIndex + 1, DitheredShadowMapMethod._grainTexture.getTextureForStageGL(stageGL));
            };

            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                this._pDepthMapCoordReg = depthProjection;

                var dataReg = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = dataReg.index * 4;

                return this.getSampleCode(regCache, dataReg, depthTexture, decodeRegister, targetRegister);
            };
            return DitheredShadowMapMethod;
        })(materials.SimpleShadowMapMethodBase);
        materials.DitheredShadowMapMethod = DitheredShadowMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var StageGL = away.base.StageGL;
        var Delegate = away.utils.Delegate;

        var Camera = away.entities.Camera;
        var IRenderable = away.pool.RenderableBase;
        var ShadingMethodEvent = away.events.ShadingMethodEvent;
        var NearDirectionalShadowMapper = away.lights.NearDirectionalShadowMapper;

        // TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work
        /**
        * NearShadowMapMethod provides a shadow map method that restricts the shadowed area near the camera to optimize
        * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.
        *
        * @see away.lights.NearDirectionalShadowMapper
        */
        var NearShadowMapMethod = (function (_super) {
            __extends(NearShadowMapMethod, _super);
            /**
            * Creates a new NearShadowMapMethod object.
            * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: HardShadowMapMethod, SoftShadowMapMethod)
            * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.
            */
            function NearShadowMapMethod(baseMethod, fadeRatio) {
                if (typeof fadeRatio === "undefined") { fadeRatio = .1; }
                _super.call(this, baseMethod.castingLight);

                this._onShaderInvalidatedDelegate = Delegate.create(this, this.onShaderInvalidated);

                this._baseMethod = baseMethod;
                this._fadeRatio = fadeRatio;
                this._nearShadowMapper = this._pCastingLight.shadowMapper;
                if (!this._nearShadowMapper)
                    throw new Error("NearShadowMapMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.");
                this._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            }
            Object.defineProperty(NearShadowMapMethod.prototype, "baseMethod", {
                get: /**
                * The base shadow map method on which this method's shading is based.
                */
                function () {
                    return this._baseMethod;
                },
                set: function (value) {
                    if (this._baseMethod == value)
                        return;
                    this._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    this._baseMethod = value;
                    this._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            NearShadowMapMethod.prototype.iInitConstants = function (vo) {
                _super.prototype.iInitConstants.call(this, vo);
                this._baseMethod.iInitConstants(vo);

                var fragmentData = vo.fragmentData;
                var index = vo.secondaryFragmentConstantsIndex;
                fragmentData[index + 2] = 0;
                fragmentData[index + 3] = 1;
            };

            /**
            * @inheritDoc
            */
            NearShadowMapMethod.prototype.iInitVO = function (vo) {
                this._baseMethod.iInitVO(vo);
                vo.needsProjection = true;
            };

            /**
            * @inheritDoc
            */
            NearShadowMapMethod.prototype.dispose = function () {
                this._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            };

            Object.defineProperty(NearShadowMapMethod.prototype, "alpha", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._baseMethod.alpha;
                },
                set: function (value) {
                    this._baseMethod.alpha = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(NearShadowMapMethod.prototype, "epsilon", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._baseMethod.epsilon;
                },
                set: function (value) {
                    this._baseMethod.epsilon = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(NearShadowMapMethod.prototype, "fadeRatio", {
                get: /**
                * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.
                */
                function () {
                    return this._fadeRatio;
                },
                set: function (value) {
                    this._fadeRatio = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            NearShadowMapMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = this._baseMethod.iGetFragmentCode(vo, regCache, targetReg);
                var dataReg = regCache.getFreeFragmentConstant();
                var temp = regCache.getFreeFragmentSingleTemp();
                vo.secondaryFragmentConstantsIndex = dataReg.index * 4;

                code += "abs " + temp + ", " + this._sharedRegisters.projectionFragment + ".w\n" + "sub " + temp + ", " + temp + ", " + dataReg + ".x\n" + "mul " + temp + ", " + temp + ", " + dataReg + ".y\n" + "sat " + temp + ", " + temp + "\n" + "sub " + temp + ", " + dataReg + ".w," + temp + "\n" + "sub " + targetReg + ".w, " + dataReg + ".w," + targetReg + ".w\n" + "mul " + targetReg + ".w, " + targetReg + ".w, " + temp + "\n" + "sub " + targetReg + ".w, " + dataReg + ".w," + targetReg + ".w\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            NearShadowMapMethod.prototype.iActivate = function (vo, stageGL) {
                this._baseMethod.iActivate(vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            NearShadowMapMethod.prototype.iDeactivate = function (vo, stageGL) {
                this._baseMethod.iDeactivate(vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            NearShadowMapMethod.prototype.iSetRenderState = function (vo, renderable, stageGL, camera) {
                // todo: move this to activate (needs camera)
                var near = camera.projection.near;
                var d = camera.projection.far - near;
                var maxDistance = this._nearShadowMapper.coverageRatio;
                var minDistance = maxDistance * (1 - this._fadeRatio);

                maxDistance = near + maxDistance * d;
                minDistance = near + minDistance * d;

                var fragmentData = vo.fragmentData;
                var index = vo.secondaryFragmentConstantsIndex;
                fragmentData[index] = minDistance;
                fragmentData[index + 1] = 1 / (maxDistance - minDistance);
                this._baseMethod.iSetRenderState(vo, renderable, stageGL, camera);
            };

            /**
            * @inheritDoc
            */
            NearShadowMapMethod.prototype.iGetVertexCode = function (vo, regCache) {
                return this._baseMethod.iGetVertexCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            NearShadowMapMethod.prototype.iReset = function () {
                this._baseMethod.iReset();
            };

            /**
            * @inheritDoc
            */
            NearShadowMapMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._baseMethod.iCleanCompilationData();
            };

            Object.defineProperty(NearShadowMapMethod.prototype, "iSharedRegisters", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    this._sharedRegisters = this._baseMethod.iSharedRegisters = value;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Called when the base method's shader code is invalidated.
            */
            NearShadowMapMethod.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };
            return NearShadowMapMethod;
        })(materials.SimpleShadowMapMethodBase);
        materials.NearShadowMapMethod = NearShadowMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * BasicAmbientMethod provides the default shading method for uniform ambient lighting.
        */
        var BasicAmbientMethod = (function (_super) {
            __extends(BasicAmbientMethod, _super);
            /**
            * Creates a new BasicAmbientMethod object.
            */
            function BasicAmbientMethod() {
                _super.call(this);
                this._useTexture = false;
                this._ambientColor = 0xffffff;
                this._ambientR = 0;
                this._ambientG = 0;
                this._ambientB = 0;
                this._ambient = 1;
                this._iLightAmbientR = 0;
                this._iLightAmbientG = 0;
                this._iLightAmbientB = 0;
            }
            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.iInitVO = function (vo) {
                vo.needsUV = this._useTexture;
            };

            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.iInitConstants = function (vo) {
                vo.fragmentData[vo.fragmentConstantsIndex + 3] = 1;
            };

            Object.defineProperty(BasicAmbientMethod.prototype, "ambient", {
                get: /**
                * The strength of the ambient reflection of the surface.
                */
                function () {
                    return this._ambient;
                },
                set: function (value) {
                    this._ambient = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicAmbientMethod.prototype, "ambientColor", {
                get: /**
                * The colour of the ambient reflection of the surface.
                */
                function () {
                    return this._ambientColor;
                },
                set: function (value) {
                    this._ambientColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicAmbientMethod.prototype, "texture", {
                get: /**
                * The bitmapData to use to define the diffuse reflection color per texel.
                */
                function () {
                    return this._texture;
                },
                set: function (value) {
                    var b = (value != null);

                    if (b != this._useTexture || (value && this._texture && (value.hasMipMaps != this._texture.hasMipMaps || value.format != this._texture.format))) {
                        this.iInvalidateShaderProgram();
                    }
                    this._useTexture = b;
                    this._texture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.copyFrom = function (method) {
                var m = method;
                var b = m;

                var diff = b;

                this.ambient = diff.ambient;
                this.ambientColor = diff.ambientColor;
            };

            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._ambientInputRegister = null;
            };

            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = "";

                if (this._useTexture) {
                    this._ambientInputRegister = regCache.getFreeTextureReg();

                    vo.texturesIndex = this._ambientInputRegister.index;

                    // TODO: AGAL <> GLSL
                    code += this.pGetTex2DSampleCode(vo, targetReg, this._ambientInputRegister, this._texture) + "div " + targetReg + ".xyz, " + targetReg + ".xyz, " + targetReg + ".w\n";
                } else {
                    this._ambientInputRegister = regCache.getFreeFragmentConstant();
                    vo.fragmentConstantsIndex = this._ambientInputRegister.index * 4;

                    code += "mov " + targetReg + ", " + this._ambientInputRegister + "\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.iActivate = function (vo, stageGL) {
                if (this._useTexture) {
                    stageGL.contextGL.setSamplerStateAt(vo.texturesIndex, vo.repeatTextures ? away.gl.ContextGLWrapMode.REPEAT : away.gl.ContextGLWrapMode.CLAMP, vo.useSmoothTextures ? away.gl.ContextGLTextureFilter.LINEAR : away.gl.ContextGLTextureFilter.NEAREST, vo.useMipmapping ? away.gl.ContextGLMipFilter.MIPLINEAR : away.gl.ContextGLMipFilter.MIPNONE);

                    stageGL.contextGL.setTextureAt(vo.texturesIndex, this._texture.getTextureForStageGL(stageGL));
                }
            };

            /**
            * Updates the ambient color data used by the render state.
            */
            BasicAmbientMethod.prototype.updateAmbient = function () {
                this._ambientR = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient * this._iLightAmbientR;
                this._ambientG = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient * this._iLightAmbientG;
                this._ambientB = (this.ambientColor & 0xff) / 0xff * this._ambient * this._iLightAmbientB;
            };

            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.iSetRenderState = function (vo, renderable, stageGL, camera) {
                this.updateAmbient();

                if (!this._useTexture) {
                    var index = vo.fragmentConstantsIndex;
                    var data = vo.fragmentData;
                    data[index] = this._ambientR;
                    data[index + 1] = this._ambientG;
                    data[index + 2] = this._ambientB;
                }
            };
            return BasicAmbientMethod;
        })(materials.ShadingMethodBase);
        materials.BasicAmbientMethod = BasicAmbientMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        //import away3d.base.StageGL;
        //import away3d.materials.compilation.ShaderRegisterCache;
        //import away3d.materials.compilation.ShaderRegisterElement;
        //import away3d.textures.Texture2DBase;
        //use namespace arcane;
        /**
        * BasicDiffuseMethod provides the default shading method for Lambert (dot3) diffuse lighting.
        */
        var BasicDiffuseMethod = (function (_super) {
            __extends(BasicDiffuseMethod, _super);
            /**
            * Creates a new BasicDiffuseMethod object.
            */
            function BasicDiffuseMethod() {
                _super.call(this);
                this._diffuseColor = 0xffffff;
                this._diffuseR = 1;
                this._diffuseG = 1;
                this._diffuseB = 1;
                this._diffuseA = 1;
                this._alphaThreshold = 0;
            }
            Object.defineProperty(BasicDiffuseMethod.prototype, "iUseAmbientTexture", {
                get: /**
                * Set internally if the ambient method uses a texture.
                */
                function () {
                    return this._useAmbientTexture;
                },
                set: function (value) {
                    if (this._useAmbientTexture == value)
                        return;

                    this._useAmbientTexture = value;

                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            BasicDiffuseMethod.prototype.iInitVO = function (vo) {
                vo.needsUV = this._useTexture;
                vo.needsNormals = vo.numLights > 0;
            };

            /**
            * Forces the creation of the texture.
            * @param stageGL The StageGL used by the renderer
            */
            BasicDiffuseMethod.prototype.generateMip = function (stageGL) {
                if (this._useTexture)
                    this._texture.getTextureForStageGL(stageGL);
            };

            Object.defineProperty(BasicDiffuseMethod.prototype, "diffuseAlpha", {
                get: /**
                * The alpha component of the diffuse reflection.
                */
                function () {
                    return this._diffuseA;
                },
                set: function (value) {
                    this._diffuseA = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicDiffuseMethod.prototype, "diffuseColor", {
                get: /**
                * The color of the diffuse reflection when not using a texture.
                */
                function () {
                    return this._diffuseColor;
                },
                set: function (diffuseColor) {
                    this._diffuseColor = diffuseColor;
                    this.updateDiffuse();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicDiffuseMethod.prototype, "texture", {
                get: /**
                * The bitmapData to use to define the diffuse reflection color per texel.
                */
                function () {
                    return this._texture;
                },
                set: function (value) {
                    var b = (value != null);

                    if (b != this._useTexture || (value && this._texture && (value.hasMipMaps != this._texture.hasMipMaps || value.format != this._texture.format))) {
                        this.iInvalidateShaderProgram();
                    }

                    this._useTexture = b;
                    this._texture = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicDiffuseMethod.prototype, "alphaThreshold", {
                get: /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                function () {
                    return this._alphaThreshold;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;
else if (value > 1)
                        value = 1;
                    if (value == this._alphaThreshold)
                        return;

                    if (value == 0 || this._alphaThreshold == 0)
                        this.iInvalidateShaderProgram();

                    this._alphaThreshold = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.dispose = function () {
                this._texture = null;
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.copyFrom = function (method) {
                var m = method;

                var diff = m;

                this.alphaThreshold = diff.alphaThreshold;
                this.texture = diff.texture;
                this.iUseAmbientTexture = diff.iUseAmbientTexture;
                this.diffuseAlpha = diff.diffuseAlpha;
                this.diffuseColor = diff.diffuseColor;
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);

                this._shadowRegister = null;
                this.pTotalLightColorReg = null;
                this._diffuseInputRegister = null;
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                var code = "";

                this._isFirstLight = true;

                if (vo.numLights > 0) {
                    this.pTotalLightColorReg = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(this.pTotalLightColorReg, 1);
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = "";
                var t;

                if (this._isFirstLight) {
                    t = this.pTotalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                //TODO: AGAL <> GLSL
                //*
                code += "dp3 " + t + ".x, " + lightDirReg + ", " + this._sharedRegisters.normalFragment + "\n" + "max " + t + ".w, " + t + ".x, " + this._sharedRegisters.commons + ".y\n";

                if (vo.useLightFallOff) {
                    code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
                }

                if (this._iModulateMethod != null) {
                    if (this._iModulateMethodScope != null) {
                        code += this._iModulateMethod.apply(this._iModulateMethodScope, [vo, t, regCache, this._sharedRegisters]);
                    } else {
                        throw "Modulated methods needs a scope";
                    }
                }

                code += "mul " + t + ", " + t + ".w, " + lightColReg + "\n";

                if (!this._isFirstLight) {
                    code += "add " + this.pTotalLightColorReg + ".xyz, " + this.pTotalLightColorReg + ", " + t + "\n";
                    regCache.removeFragmentTempUsage(t);
                }

                //*/
                this._isFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                var code = "";
                var t;

                if (this._isFirstLight) {
                    t = this.pTotalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                // TODO: AGAL <> GLSL
                code += "tex " + t + ", " + this._sharedRegisters.normalFragment + ", " + cubeMapReg + " <cube,linear,miplinear>\n" + "mul " + t + ".xyz, " + t + ".xyz, " + weightRegister + "\n";

                if (this._iModulateMethod != null) {
                    if (this._iModulateMethodScope != null) {
                        code += this._iModulateMethod.apply(this._iModulateMethodScope, [vo, t, regCache, this._sharedRegisters]);
                    } else {
                        throw "Modulated methods needs a scope";
                    }
                }

                if (!this._isFirstLight) {
                    code += "add " + this.pTotalLightColorReg + ".xyz, " + this.pTotalLightColorReg + ", " + t + "\n";
                    regCache.removeFragmentTempUsage(t);
                }

                this._isFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                var code = "";
                var albedo;
                var cutOffReg;

                if (vo.numLights > 0) {
                    if (this._shadowRegister)
                        code += this.pApplyShadow(vo, regCache);

                    albedo = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(albedo, 1);
                } else {
                    albedo = targetReg;
                }

                if (this._useTexture) {
                    this._diffuseInputRegister = regCache.getFreeTextureReg();

                    vo.texturesIndex = this._diffuseInputRegister.index;

                    code += this.pGetTex2DSampleCode(vo, albedo, this._diffuseInputRegister, this._texture);

                    if (this._alphaThreshold > 0) {
                        //TODO: AGAL <> GLSL
                        cutOffReg = regCache.getFreeFragmentConstant();
                        vo.fragmentConstantsIndex = cutOffReg.index * 4;

                        code += "sub " + albedo + ".w, " + albedo + ".w, " + cutOffReg + ".x\n" + "kil " + albedo + ".w\n" + "add " + albedo + ".w, " + albedo + ".w, " + cutOffReg + ".x\n";
                    }
                } else {
                    //TODO: AGAL <> GLSL
                    this._diffuseInputRegister = regCache.getFreeFragmentConstant();

                    vo.fragmentConstantsIndex = this._diffuseInputRegister.index * 4;

                    code += "mov " + albedo + ", " + this._diffuseInputRegister + "\n";
                }

                if (vo.numLights == 0)
                    return code;

                //TODO: AGAL <> GLSL
                code += "sat " + this.pTotalLightColorReg + ", " + this.pTotalLightColorReg + "\n";

                if (this._useAmbientTexture) {
                    //TODO: AGAL <> GLSL
                    code += "mul " + albedo + ".xyz, " + albedo + ", " + this.pTotalLightColorReg + "\n" + "mul " + this.pTotalLightColorReg + ".xyz, " + targetReg + ", " + this.pTotalLightColorReg + "\n" + "sub " + targetReg + ".xyz, " + targetReg + ", " + this.pTotalLightColorReg + "\n" + "add " + targetReg + ".xyz, " + albedo + ", " + targetReg + "\n";
                } else {
                    //TODO: AGAL <> GLSL
                    code += "add " + targetReg + ".xyz, " + this.pTotalLightColorReg + ", " + targetReg + "\n";

                    if (this._useTexture) {
                        code += "mul " + targetReg + ".xyz, " + albedo + ", " + targetReg + "\n" + "mov " + targetReg + ".w, " + albedo + ".w\n";
                    } else {
                        code += "mul " + targetReg + ".xyz, " + this._diffuseInputRegister + ", " + targetReg + "\n" + "mov " + targetReg + ".w, " + this._diffuseInputRegister + ".w\n";
                    }
                }

                regCache.removeFragmentTempUsage(this.pTotalLightColorReg);
                regCache.removeFragmentTempUsage(albedo);

                return code;
            };

            /**
            * Generate the code that applies the calculated shadow to the diffuse light
            * @param vo The MethodVO object for which the compilation is currently happening.
            * @param regCache The register cache the compiler is currently using for the register management.
            */
            BasicDiffuseMethod.prototype.pApplyShadow = function (vo, regCache) {
                //TODO: AGAL <> GLSL
                return "mul " + this.pTotalLightColorReg + ".xyz, " + this.pTotalLightColorReg + ", " + this._shadowRegister + ".w\n";
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.iActivate = function (vo, stageGL) {
                if (this._useTexture) {
                    stageGL.contextGL.setSamplerStateAt(vo.texturesIndex, vo.repeatTextures ? away.gl.ContextGLWrapMode.REPEAT : away.gl.ContextGLWrapMode.CLAMP, vo.useSmoothTextures ? away.gl.ContextGLTextureFilter.LINEAR : away.gl.ContextGLTextureFilter.NEAREST, vo.useMipmapping ? away.gl.ContextGLMipFilter.MIPLINEAR : away.gl.ContextGLMipFilter.MIPNONE);

                    stageGL.contextGL.setTextureAt(vo.texturesIndex, this._texture.getTextureForStageGL(stageGL));

                    if (this._alphaThreshold > 0)
                        vo.fragmentData[vo.fragmentConstantsIndex] = this._alphaThreshold;
                } else {
                    var index = vo.fragmentConstantsIndex;
                    var data = vo.fragmentData;
                    data[index] = this._diffuseR;
                    data[index + 1] = this._diffuseG;
                    data[index + 2] = this._diffuseB;
                    data[index + 3] = this._diffuseA;
                }
            };

            /**
            * Updates the diffuse color data used by the render state.
            */
            BasicDiffuseMethod.prototype.updateDiffuse = function () {
                this._diffuseR = ((this._diffuseColor >> 16) & 0xff) / 0xff;
                this._diffuseG = ((this._diffuseColor >> 8) & 0xff) / 0xff;
                this._diffuseB = (this._diffuseColor & 0xff) / 0xff;
            };

            Object.defineProperty(BasicDiffuseMethod.prototype, "iShadowRegister", {
                set: /**
                * Set internally by the compiler, so the method knows the register containing the shadow calculation.
                */
                function (value) {
                    this._shadowRegister = value;
                },
                enumerable: true,
                configurable: true
            });

            BasicDiffuseMethod.prototype.setIShadowRegister = function (value) {
                this._shadowRegister = value;
            };
            return BasicDiffuseMethod;
        })(materials.LightingMethodBase);
        materials.BasicDiffuseMethod = BasicDiffuseMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * BasicNormalMethod is the default method for standard tangent-space normal mapping.
        */
        var BasicNormalMethod = (function (_super) {
            __extends(BasicNormalMethod, _super);
            /**
            * Creates a new BasicNormalMethod object.
            */
            function BasicNormalMethod() {
                _super.call(this);
            }
            /**
            * @inheritDoc
            */
            BasicNormalMethod.prototype.iInitVO = function (vo) {
                if (this._texture) {
                    vo.needsUV = true;
                } else {
                    vo.needsUV = false;
                }
                //vo.needsUV = Boolean(_texture);
            };

            Object.defineProperty(BasicNormalMethod.prototype, "iTangentSpace", {
                get: /**
                * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.
                */
                function () {
                    return true;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(BasicNormalMethod.prototype, "iHasOutput", {
                get: /**
                * Indicates if the normal method output is not based on a texture (if not, it will usually always return true)
                * Override if subclasses are different.
                */
                function () {
                    return this._useTexture;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            BasicNormalMethod.prototype.copyFrom = function (method) {
                var s = method;
                var bnm = method;

                this.normalMap = bnm.normalMap;
            };

            Object.defineProperty(BasicNormalMethod.prototype, "normalMap", {
                get: /**
                * The texture containing the normals per pixel.
                */
                function () {
                    return this._texture;
                },
                set: function (value) {
                    this.setNormalMap(value);
                },
                enumerable: true,
                configurable: true
            });


            BasicNormalMethod.prototype.setNormalMap = function (value) {
                var b = (value != null);

                if (b != this._useTexture || (value && this._texture && (value.hasMipMaps != this._texture.hasMipMaps || value.format != this._texture.format))) {
                    this.iInvalidateShaderProgram();
                }
                this._useTexture = b;
                this._texture = value;
            };

            /**
            * @inheritDoc
            */
            BasicNormalMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._pNormalTextureRegister = null;
            };

            /**
            * @inheritDoc
            */
            BasicNormalMethod.prototype.dispose = function () {
                if (this._texture) {
                    this._texture = null;
                }
            };

            /**
            * @inheritDoc
            */
            BasicNormalMethod.prototype.iActivate = function (vo, stageGL) {
                if (vo.texturesIndex >= 0) {
                    stageGL.contextGL.setSamplerStateAt(vo.texturesIndex, vo.repeatTextures ? away.gl.ContextGLWrapMode.REPEAT : away.gl.ContextGLWrapMode.CLAMP, vo.useSmoothTextures ? away.gl.ContextGLTextureFilter.LINEAR : away.gl.ContextGLTextureFilter.NEAREST, vo.useMipmapping ? away.gl.ContextGLMipFilter.MIPLINEAR : away.gl.ContextGLMipFilter.MIPNONE);
                    stageGL.contextGL.setTextureAt(vo.texturesIndex, this._texture.getTextureForStageGL(stageGL));
                }
            };

            /**
            * @inheritDoc
            */
            BasicNormalMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                this._pNormalTextureRegister = regCache.getFreeTextureReg();

                vo.texturesIndex = this._pNormalTextureRegister.index;

                // TODO: AGAL <> GLSL
                return this.pGetTex2DSampleCode(vo, targetReg, this._pNormalTextureRegister, this._texture) + "sub " + targetReg + ".xyz, " + targetReg + ".xyz, " + this._sharedRegisters.commons + ".xxx\n" + "nrm " + targetReg + ".xyz, " + targetReg + "\n";
            };
            return BasicNormalMethod;
        })(materials.ShadingMethodBase);
        materials.BasicNormalMethod = BasicNormalMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.*;
        //import away3d.managers.*;
        //import away3d.materials.compilation.*;
        //import away3d.textures.*;
        //use namespace arcane;
        /**
        * BasicSpecularMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated
        * version of Phong specularity).
        */
        var BasicSpecularMethod = (function (_super) {
            __extends(BasicSpecularMethod, _super);
            /**
            * Creates a new BasicSpecularMethod object.
            */
            function BasicSpecularMethod() {
                _super.call(this);
                this._gloss = 50;
                this._specular = 1;
                this._specularColor = 0xffffff;
                this._iSpecularR = 1;
                this._iSpecularG = 1;
                this._iSpecularB = 1;
            }
            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iInitVO = function (vo) {
                vo.needsUV = this._pUseTexture;
                vo.needsNormals = vo.numLights > 0;
                vo.needsView = vo.numLights > 0;
            };

            Object.defineProperty(BasicSpecularMethod.prototype, "gloss", {
                get: /**
                * The sharpness of the specular highlight.
                */
                function () {
                    return this._gloss;
                },
                set: function (value) {
                    this._gloss = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicSpecularMethod.prototype, "specular", {
                get: /**
                * The overall strength of the specular highlights.
                */
                function () {
                    return this._specular;
                },
                set: function (value) {
                    if (value == this._specular)
                        return;

                    this._specular = value;
                    this.updateSpecular();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicSpecularMethod.prototype, "specularColor", {
                get: /**
                * The colour of the specular reflection of the surface.
                */
                function () {
                    return this._specularColor;
                },
                set: function (value) {
                    if (this._specularColor == value)
                        return;

                    if (this._specularColor == 0 || value == 0)
                        this.iInvalidateShaderProgram();

                    this._specularColor = value;
                    this.updateSpecular();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicSpecularMethod.prototype, "texture", {
                get: /**
                * The bitmapData that encodes the specular highlight strength per texel in the red channel, and the sharpness
                * in the green channel. You can use SpecularBitmapTexture if you want to easily set specular and gloss maps
                * from grayscale images, but prepared images are preferred.
                */
                function () {
                    return this._texture;
                },
                set: function (value) {
                    var b = (value != null);

                    if (b != this._pUseTexture || (value && this._texture && (value.hasMipMaps != this._texture.hasMipMaps || value.format != this._texture.format))) {
                        this.iInvalidateShaderProgram();
                    }
                    this._pUseTexture = b;
                    this._texture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.copyFrom = function (method) {
                var m = method;
                var bsm = method;

                var spec = bsm;
                this.texture = spec.texture;
                this.specular = spec.specular;
                this.specularColor = spec.specularColor;
                this.gloss = spec.gloss;
            };

            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._shadowRegister = null;
                this._pTotalLightColorReg = null;
                this._pSpecularTextureRegister = null;
                this._pSpecularTexData = null;
                this._pSpecularDataRegister = null;
            };

            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                var code = "";

                this._pIsFirstLight = true;

                if (vo.numLights > 0) {
                    this._pSpecularDataRegister = regCache.getFreeFragmentConstant();
                    vo.fragmentConstantsIndex = this._pSpecularDataRegister.index * 4;

                    if (this._pUseTexture) {
                        this._pSpecularTexData = regCache.getFreeFragmentVectorTemp();
                        regCache.addFragmentTempUsages(this._pSpecularTexData, 1);
                        this._pSpecularTextureRegister = regCache.getFreeTextureReg();
                        vo.texturesIndex = this._pSpecularTextureRegister.index;
                        code = this.pGetTex2DSampleCode(vo, this._pSpecularTexData, this._pSpecularTextureRegister, this._texture);
                    } else {
                        this._pSpecularTextureRegister = null;
                    }

                    this._pTotalLightColorReg = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = "";
                var t;

                if (this._pIsFirstLight) {
                    t = this._pTotalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                var viewDirReg = this._sharedRegisters.viewDirFragment;
                var normalReg = this._sharedRegisters.normalFragment;

                // blinn-phong half vector model
                //TODO: AGAL <> GLSL
                code += "add " + t + ", " + lightDirReg + ", " + viewDirReg + "\n" + "nrm " + t + ".xyz, " + t + "\n" + "dp3 " + t + ".w, " + normalReg + ", " + t + "\n" + "sat " + t + ".w, " + t + ".w\n";

                if (this._pUseTexture) {
                    //TODO: AGAL <> GLSL
                    // apply gloss modulation from texture
                    code += "mul " + this._pSpecularTexData + ".w, " + this._pSpecularTexData + ".y, " + this._pSpecularDataRegister + ".w\n" + "pow " + t + ".w, " + t + ".w, " + this._pSpecularTexData + ".w\n";
                } else {
                    //TODO: AGAL <> GLSL
                    code += "pow " + t + ".w, " + t + ".w, " + this._pSpecularDataRegister + ".w\n";
                }

                if (vo.useLightFallOff) {
                    //TODO: AGAL <> GLSL
                    code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
                }

                if (this._iModulateMethod != null) {
                    if (this._iModulateMethodScope != null) {
                        code += this._iModulateMethod.apply(this._iModulateMethodScope, [vo, t, regCache, this._sharedRegisters]);
                    } else {
                        throw "Modulated methods needs a scope";
                    }
                    //code += this._iModulateMethod (vo, t, regCache, this._sharedRegisters);
                }

                //TODO: AGAL <> GLSL
                code += "mul " + t + ".xyz, " + lightColReg + ", " + t + ".w\n";

                if (!this._pIsFirstLight) {
                    //TODO: AGAL <> GLSL
                    code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";

                    regCache.removeFragmentTempUsage(t);
                }

                this._pIsFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                var code = "";
                var t;

                if (this._pIsFirstLight) {
                    t = this._pTotalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                var normalReg = this._sharedRegisters.normalFragment;
                var viewDirReg = this._sharedRegisters.viewDirFragment;

                //TODO: AGAL <> GLSL
                code += "dp3 " + t + ".w, " + normalReg + ", " + viewDirReg + "\n" + "add " + t + ".w, " + t + ".w, " + t + ".w\n" + "mul " + t + ", " + t + ".w, " + normalReg + "\n" + "sub " + t + ", " + t + ", " + viewDirReg + "\n" + "tex " + t + ", " + t + ", " + cubeMapReg + " <cube," + (vo.useSmoothTextures ? "linear" : "nearest") + ",miplinear>\n" + "mul " + t + ".xyz, " + t + ", " + weightRegister + "\n";

                if (this._iModulateMethod != null) {
                    if (this._iModulateMethodScope != null) {
                        code += this._iModulateMethod.apply(this._iModulateMethodScope, [vo, t, regCache, this._sharedRegisters]);
                    } else {
                        throw "Modulated methods needs a scope";
                    }
                    //code += this._iModulateMethod (vo, t, regCache, this._sharedRegisters);
                }

                if (!this._pIsFirstLight) {
                    //TODO: AGAL <> GLSL
                    code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";

                    regCache.removeFragmentTempUsage(t);
                }

                this._pIsFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                var code = "";

                if (vo.numLights == 0)
                    return code;

                if (this._shadowRegister) {
                    //TODO: AGAL <> GLSL
                    code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._shadowRegister + ".w\n";
                }

                if (this._pUseTexture) {
                    // apply strength modulation from texture
                    //TODO: AGAL <> GLSL
                    code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._pSpecularTexData + ".x\n";

                    regCache.removeFragmentTempUsage(this._pSpecularTexData);
                }

                // apply material's specular reflection
                //TODO: AGAL <> GLSL
                code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._pSpecularDataRegister + "\n" + "add " + targetReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n";

                regCache.removeFragmentTempUsage(this._pTotalLightColorReg);

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iActivate = function (vo, stageGL) {
                if (vo.numLights == 0)
                    return;

                if (this._pUseTexture) {
                    stageGL.contextGL.setSamplerStateAt(vo.texturesIndex, vo.repeatTextures ? away.gl.ContextGLWrapMode.REPEAT : away.gl.ContextGLWrapMode.CLAMP, vo.useSmoothTextures ? away.gl.ContextGLTextureFilter.LINEAR : away.gl.ContextGLTextureFilter.NEAREST, vo.useMipmapping ? away.gl.ContextGLMipFilter.MIPLINEAR : away.gl.ContextGLMipFilter.MIPNONE);
                    stageGL.contextGL.setTextureAt(vo.texturesIndex, this._texture.getTextureForStageGL(stageGL));
                }

                var index = vo.fragmentConstantsIndex;
                var data = vo.fragmentData;
                data[index] = this._iSpecularR;
                data[index + 1] = this._iSpecularG;
                data[index + 2] = this._iSpecularB;
                data[index + 3] = this._gloss;
            };

            /**
            * Updates the specular color data used by the render state.
            */
            BasicSpecularMethod.prototype.updateSpecular = function () {
                this._iSpecularR = ((this._specularColor >> 16) & 0xff) / 0xff * this._specular;
                this._iSpecularG = ((this._specularColor >> 8) & 0xff) / 0xff * this._specular;
                this._iSpecularB = (this._specularColor & 0xff) / 0xff * this._specular;
            };

            Object.defineProperty(BasicSpecularMethod.prototype, "iShadowRegister", {
                set: /**
                * Set internally by the compiler, so the method knows the register containing the shadow calculation.
                */
                function (shadowReg) {
                    this._shadowRegister = shadowReg;
                },
                enumerable: true,
                configurable: true
            });

            BasicSpecularMethod.prototype.setIShadowRegister = function (shadowReg) {
                this._shadowRegister = shadowReg;
            };
            return BasicSpecularMethod;
        })(materials.LightingMethodBase);
        materials.BasicSpecularMethod = BasicSpecularMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var Camera = away.entities.Camera;
        var StageGL = away.base.StageGL;
        var ShadingMethodEvent = away.events.ShadingMethodEvent;
        var DirectionalLight = away.lights.DirectionalLight;
        var CascadeShadowMapper = away.lights.CascadeShadowMapper;
        var RenderableBase = away.pool.RenderableBase;

        var Event = away.events.Event;

        /**
        * CascadeShadowMapMethod is a shadow map method to apply cascade shadow mapping on materials.
        * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.
        *
        * @see away.lights.CascadeShadowMapper
        */
        var CascadeShadowMapMethod = (function (_super) {
            __extends(CascadeShadowMapMethod, _super);
            /**
            * Creates a new CascadeShadowMapMethod object.
            *
            * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: HardShadowMapMethod, SoftShadowMapMethod)
            */
            function CascadeShadowMapMethod(shadowMethodBase) {
                var _this = this;
                _super.call(this, shadowMethodBase.castingLight);

                this._baseMethod = shadowMethodBase;
                if (!(this._pCastingLight instanceof DirectionalLight))
                    throw new Error("CascadeShadowMapMethod is only compatible with DirectionalLight");

                this._cascadeShadowMapper = this._pCastingLight.shadowMapper;

                if (!this._cascadeShadowMapper)
                    throw new Error("CascadeShadowMapMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.");

                this._cascadeShadowMapper.addEventListener(Event.CHANGE, function (event) {
                    return _this.onCascadeChange(event);
                });
                this._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, function (event) {
                    return _this.onShaderInvalidated(event);
                });
            }
            Object.defineProperty(CascadeShadowMapMethod.prototype, "baseMethod", {
                get: /**
                * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction
                * with a DirectionalShadowMapper.
                *
                * @see HardShadowMapMethod
                * @see SoftShadowMapMethod
                */
                function () {
                    return this._baseMethod;
                },
                set: function (value) {
                    var _this = this;
                    if (this._baseMethod == value)
                        return;

                    this._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, function (event) {
                        return _this.onShaderInvalidated(event);
                    });
                    this._baseMethod = value;
                    this._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, function (event) {
                        return _this.onShaderInvalidated(event);
                    });
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            CascadeShadowMapMethod.prototype.iInitVO = function (vo) {
                var tempVO = new materials.MethodVO();
                this._baseMethod.iInitVO(tempVO);
                vo.needsGlobalVertexPos = true;
                vo.needsProjection = true;
            };

            Object.defineProperty(CascadeShadowMapMethod.prototype, "iSharedRegisters", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    this.setISharedRegisters(value);
                    this._baseMethod.iSharedRegisters = value;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            CascadeShadowMapMethod.prototype.iInitConstants = function (vo) {
                var fragmentData = vo.fragmentData;
                var vertexData = vo.vertexData;
                var index = vo.fragmentConstantsIndex;
                fragmentData[index] = 1.0;
                fragmentData[index + 1] = 1 / 255.0;
                fragmentData[index + 2] = 1 / 65025.0;
                fragmentData[index + 3] = 1 / 16581375.0;

                fragmentData[index + 6] = .5;
                fragmentData[index + 7] = -.5;

                index = vo.vertexConstantsIndex;
                vertexData[index] = .5;
                vertexData[index + 1] = -.5;
                vertexData[index + 2] = 0;
            };

            /**
            * @inheritDoc
            */
            CascadeShadowMapMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._cascadeProjections = null;
                this._depthMapCoordVaryings = null;
            };

            /**
            * @inheritDoc
            */
            CascadeShadowMapMethod.prototype.iGetVertexCode = function (vo, regCache) {
                var code = "";
                var dataReg = regCache.getFreeVertexConstant();

                this.initProjectionsRegs(regCache);
                vo.vertexConstantsIndex = dataReg.index * 4;

                var temp = regCache.getFreeVertexVectorTemp();

                for (var i = 0; i < this._cascadeShadowMapper.numCascades; ++i) {
                    code += "m44 " + temp + ", " + this._sharedRegisters.globalPositionVertex + ", " + this._cascadeProjections[i] + "\n" + "add " + this._depthMapCoordVaryings[i] + ", " + temp + ", " + dataReg + ".zzwz\n";
                }

                return code;
            };

            /**
            * Creates the registers for the cascades' projection coordinates.
            */
            CascadeShadowMapMethod.prototype.initProjectionsRegs = function (regCache) {
                this._cascadeProjections = new Array(this._cascadeShadowMapper.numCascades);
                this._depthMapCoordVaryings = new Array(this._cascadeShadowMapper.numCascades);

                for (var i = 0; i < this._cascadeShadowMapper.numCascades; ++i) {
                    this._depthMapCoordVaryings[i] = regCache.getFreeVarying();
                    this._cascadeProjections[i] = regCache.getFreeVertexConstant();
                    regCache.getFreeVertexConstant();
                    regCache.getFreeVertexConstant();
                    regCache.getFreeVertexConstant();
                }
            };

            /**
            * @inheritDoc
            */
            CascadeShadowMapMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var numCascades = this._cascadeShadowMapper.numCascades;
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var dataReg = regCache.getFreeFragmentConstant();
                var planeDistanceReg = regCache.getFreeFragmentConstant();
                var planeDistances = Array(planeDistanceReg + ".x", planeDistanceReg + ".y", planeDistanceReg + ".z", planeDistanceReg + ".w");
                var code;

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                var inQuad = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(inQuad, 1);
                var uvCoord = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(uvCoord, 1);

                // assume lowest partition is selected, will be overwritten later otherwise
                code = "mov " + uvCoord + ", " + this._depthMapCoordVaryings[numCascades - 1] + "\n";

                for (var i = numCascades - 2; i >= 0; --i) {
                    var uvProjection = this._depthMapCoordVaryings[i];

                    // calculate if in texturemap (result == 0 or 1, only 1 for a single partition)
                    code += "slt " + inQuad + ".z, " + this._sharedRegisters.projectionFragment + ".z, " + planeDistances[i] + "\n";

                    var temp = regCache.getFreeFragmentVectorTemp();

                    // linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)
                    code += "sub " + temp + ", " + uvProjection + ", " + uvCoord + "\n" + "mul " + temp + ", " + temp + ", " + inQuad + ".z\n" + "add " + uvCoord + ", " + uvCoord + ", " + temp + "\n";
                }

                regCache.removeFragmentTempUsage(inQuad);

                code += "div " + uvCoord + ", " + uvCoord + ", " + uvCoord + ".w\n" + "mul " + uvCoord + ".xy, " + uvCoord + ".xy, " + dataReg + ".zw\n" + "add " + uvCoord + ".xy, " + uvCoord + ".xy, " + dataReg + ".zz\n";

                code += this._baseMethod._iGetCascadeFragmentCode(vo, regCache, decReg, depthMapRegister, uvCoord, targetReg) + "add " + targetReg + ".w, " + targetReg + ".w, " + dataReg + ".y\n";

                regCache.removeFragmentTempUsage(uvCoord);

                return code;
            };

            /**
            * @inheritDoc
            */
            CascadeShadowMapMethod.prototype.iActivate = function (vo, stageGL) {
                stageGL.contextGL.setTextureAt(vo.texturesIndex, this._pCastingLight.shadowMapper.depthMap.getTextureForStageGL(stageGL));

                var vertexData = vo.vertexData;
                var vertexIndex = vo.vertexConstantsIndex;

                vo.vertexData[vo.vertexConstantsIndex + 3] = -1 / (this._cascadeShadowMapper.depth * this._pEpsilon);

                var numCascades = this._cascadeShadowMapper.numCascades;
                vertexIndex += 4;
                for (var k = 0; k < numCascades; ++k) {
                    this._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);
                    vertexIndex += 16;
                }

                var fragmentData = vo.fragmentData;
                var fragmentIndex = vo.fragmentConstantsIndex;
                fragmentData[fragmentIndex + 5] = 1 - this._pAlpha;

                var nearPlaneDistances = this._cascadeShadowMapper._iNearPlaneDistances;

                fragmentIndex += 8;
                for (var i = 0; i < numCascades; ++i)
                    fragmentData[fragmentIndex + i] = nearPlaneDistances[i];

                this._baseMethod.iActivateForCascade(vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            CascadeShadowMapMethod.prototype.iSetRenderState = function (vo, renderable, stageGL, camera) {
            };

            /**
            * Called when the shadow mappers cascade configuration changes.
            */
            CascadeShadowMapMethod.prototype.onCascadeChange = function (event) {
                this.iInvalidateShaderProgram();
            };

            /**
            * Called when the base method's shader code is invalidated.
            */
            CascadeShadowMapMethod.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };
            return CascadeShadowMapMethod;
        })(materials.ShadowMapMethodBase);
        materials.CascadeShadowMapMethod = CascadeShadowMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        //import away3d.base.StageGL;
        //import away3d.materials.compilation.ShaderRegisterCache;
        //import away3d.materials.compilation.ShaderRegisterElement;
        //import flash.geom.ColorTransform;
        //use namespace arcane;
        /**
        * ColorTransformMethod provides a shading method that changes the colour of a material analogous to a
        * ColorTransform object.
        */
        var ColorTransformMethod = (function (_super) {
            __extends(ColorTransformMethod, _super);
            /**
            * Creates a new ColorTransformMethod.
            */
            function ColorTransformMethod() {
                _super.call(this);
            }
            Object.defineProperty(ColorTransformMethod.prototype, "colorTransform", {
                get: /**
                * The ColorTransform object to transform the colour of the material with.
                */
                function () {
                    return this._colorTransform;
                },
                set: function (value) {
                    this._colorTransform = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ColorTransformMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = "";
                var colorMultReg = regCache.getFreeFragmentConstant();
                var colorOffsReg = regCache.getFreeFragmentConstant();

                vo.fragmentConstantsIndex = colorMultReg.index * 4;

                //TODO: AGAL <> GLSL
                code += "mul " + targetReg + ", " + targetReg + ", " + colorMultReg + "\n" + "add " + targetReg + ", " + targetReg + ", " + colorOffsReg + "\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            ColorTransformMethod.prototype.iActivate = function (vo, stageGL) {
                var inv = 1 / 0xff;
                var index = vo.fragmentConstantsIndex;
                var data = vo.fragmentData;

                data[index] = this._colorTransform.redMultiplier;
                data[index + 1] = this._colorTransform.greenMultiplier;
                data[index + 2] = this._colorTransform.blueMultiplier;
                data[index + 3] = this._colorTransform.alphaMultiplier;
                data[index + 4] = this._colorTransform.redOffset * inv;
                data[index + 5] = this._colorTransform.greenOffset * inv;
                data[index + 6] = this._colorTransform.blueOffset * inv;
                data[index + 7] = this._colorTransform.alphaOffset * inv;
            };
            return ColorTransformMethod;
        })(materials.EffectMethodBase);
        materials.ColorTransformMethod = ColorTransformMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * PhongSpecularMethod provides a specular method that provides Phong highlights.
        */
        var PhongSpecularMethod = (function (_super) {
            __extends(PhongSpecularMethod, _super);
            /**
            * Creates a new PhongSpecularMethod object.
            */
            function PhongSpecularMethod() {
                _super.call(this);
            }
            /**
            * @inheritDoc
            */
            PhongSpecularMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = "";
                var t;

                if (this._pIsFirstLight)
                    t = this._pTotalLightColorReg;
else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                var viewDirReg = this._sharedRegisters.viewDirFragment;
                var normalReg = this._sharedRegisters.normalFragment;

                // phong model
                code += "dp3 " + t + ".w, " + lightDirReg + ", " + normalReg + "\n" + "add " + t + ".w, " + t + ".w, " + t + ".w\n" + "mul " + t + ".xyz, " + normalReg + ", " + t + ".w\n" + "sub " + t + ".xyz, " + t + ", " + lightDirReg + "\n" + "add " + t + ".w, " + t + ".w, " + this._sharedRegisters.commons + ".w\n" + "sat " + t + ".w, " + t + ".w\n" + "mul " + t + ".xyz, " + t + ", " + t + ".w\n" + "dp3 " + t + ".w, " + t + ", " + viewDirReg + "\n" + "sat " + t + ".w, " + t + ".w\n";

                if (this._pUseTexture) {
                    // apply gloss modulation from texture
                    code += "mul " + this._pSpecularTexData + ".w, " + this._pSpecularTexData + ".y, " + this._pSpecularDataRegister + ".w\n" + "pow " + t + ".w, " + t + ".w, " + this._pSpecularTexData + ".w\n";
                } else
                    code += "pow " + t + ".w, " + t + ".w, " + this._pSpecularDataRegister + ".w\n";

                if (vo.useLightFallOff)
                    code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";

                if (this._iModulateMethod != null) {
                    if (this._iModulateMethodScope != null) {
                        code += this._iModulateMethod.apply(this._iModulateMethodScope, [vo, t, regCache, this._sharedRegisters]);
                    } else {
                        throw "Modulated methods needs a scope";
                    }
                }

                code += "mul " + t + ".xyz, " + lightColReg + ".xyz, " + t + ".w\n";

                if (!this._pIsFirstLight) {
                    code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
                    regCache.removeFragmentTempUsage(t);
                }

                this._pIsFirstLight = false;

                return code;
            };
            return PhongSpecularMethod;
        })(materials.BasicSpecularMethod);
        materials.PhongSpecularMethod = PhongSpecularMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var StageGL = away.base.StageGL;
        var Texture2DBase = away.textures.Texture2DBase;
        var Delegate = away.utils.Delegate;

        var ShadingMethodEvent = away.events.ShadingMethodEvent;

        /**
        * CompositeDiffuseMethod provides a base class for diffuse methods that wrap a diffuse method to alter the
        * calculated diffuse reflection strength.
        */
        var CompositeDiffuseMethod = (function (_super) {
            __extends(CompositeDiffuseMethod, _super);
            /**
            * Creates a new WrapDiffuseMethod object.
            * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t : ShaderRegisterElement, regCache : ShaderRegisterCache) : string, in which t.w will contain the diffuse strength.
            * @param baseDiffuseMethod The base diffuse method on which this method's shading is based.
            */
            function CompositeDiffuseMethod(scope, modulateMethod, baseDiffuseMethod) {
                if (typeof modulateMethod === "undefined") { modulateMethod = null; }
                if (typeof baseDiffuseMethod === "undefined") { baseDiffuseMethod = null; }
                _super.call(this);

                this._onShaderInvalidatedDelegate = Delegate.create(this, this.onShaderInvalidated);

                if (scope != null && modulateMethod != null)
                    this._pInitCompositeDiffuseMethod(scope, modulateMethod, baseDiffuseMethod);
            }
            CompositeDiffuseMethod.prototype._pInitCompositeDiffuseMethod = function (scope, modulateMethod, baseDiffuseMethod) {
                if (typeof baseDiffuseMethod === "undefined") { baseDiffuseMethod = null; }
                this.pBaseMethod = baseDiffuseMethod || new materials.BasicDiffuseMethod();
                this.pBaseMethod._iModulateMethod = modulateMethod;
                this.pBaseMethod._iModulateMethodScope = scope;
                this.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            };

            Object.defineProperty(CompositeDiffuseMethod.prototype, "baseMethod", {
                get: /**
                * The base diffuse method on which this method's shading is based.
                */
                function () {
                    return this.pBaseMethod;
                },
                set: function (value) {
                    if (this.pBaseMethod == value)
                        return;

                    this.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    this.pBaseMethod = value;
                    this.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iInitVO = function (vo) {
                this.pBaseMethod.iInitVO(vo);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iInitConstants = function (vo) {
                this.pBaseMethod.iInitConstants(vo);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.dispose = function () {
                this.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                this.pBaseMethod.dispose();
            };

            Object.defineProperty(CompositeDiffuseMethod.prototype, "alphaThreshold", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this.pBaseMethod.alphaThreshold;
                },
                set: function (value) {
                    this.pBaseMethod.alphaThreshold = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompositeDiffuseMethod.prototype, "texture", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this.pBaseMethod.texture;
                },
                set: /**
                * @inheritDoc
                */
                function (value) {
                    this.pBaseMethod.texture = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompositeDiffuseMethod.prototype, "diffuseAlpha", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this.pBaseMethod.diffuseAlpha;
                },
                set: /**
                * @inheritDoc
                */
                function (value) {
                    this.pBaseMethod.diffuseAlpha = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompositeDiffuseMethod.prototype, "diffuseColor", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this.pBaseMethod.diffuseColor;
                },
                set: /**
                * @inheritDoc
                */
                function (diffuseColor) {
                    this.pBaseMethod.diffuseColor = diffuseColor;
                },
                enumerable: true,
                configurable: true
            });



            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                return this.pBaseMethod.iGetFragmentPreLightingCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = this.pBaseMethod.iGetFragmentCodePerLight(vo, lightDirReg, lightColReg, regCache);
                this.pTotalLightColorReg = this.pBaseMethod.pTotalLightColorReg;
                return code;
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                var code = this.pBaseMethod.iGetFragmentCodePerProbe(vo, cubeMapReg, weightRegister, regCache);
                this.pTotalLightColorReg = this.pBaseMethod.pTotalLightColorReg;
                return code;
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iActivate = function (vo, stageGL) {
                this.pBaseMethod.iActivate(vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iDeactivate = function (vo, stageGL) {
                this.pBaseMethod.iDeactivate(vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iGetVertexCode = function (vo, regCache) {
                return this.pBaseMethod.iGetVertexCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                return this.pBaseMethod.iGetFragmentPostLightingCode(vo, regCache, targetReg);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iReset = function () {
                this.pBaseMethod.iReset();
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this.pBaseMethod.iCleanCompilationData();
            };

            Object.defineProperty(CompositeDiffuseMethod.prototype, "iSharedRegisters", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    this.pBaseMethod.setISharedRegisters(value);
                    _super.prototype.setISharedRegisters.call(this, value);
                },
                enumerable: true,
                configurable: true
            });

            CompositeDiffuseMethod.prototype.setISharedRegisters = function (value) {
                this.pBaseMethod.setISharedRegisters(value);
                _super.prototype.setISharedRegisters.call(this, value);
            };

            Object.defineProperty(CompositeDiffuseMethod.prototype, "iShadowRegister", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    _super.prototype.setIShadowRegister.call(this, value);
                    this.pBaseMethod.setIShadowRegister(value);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Called when the base method's shader code is invalidated.
            */
            CompositeDiffuseMethod.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };
            return CompositeDiffuseMethod;
        })(materials.BasicDiffuseMethod);
        materials.CompositeDiffuseMethod = CompositeDiffuseMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var StageGL = away.base.StageGL;
        var Texture2DBase = away.textures.Texture2DBase;
        var Delegate = away.utils.Delegate;

        var ShadingMethodEvent = away.events.ShadingMethodEvent;

        /**
        * CompositeSpecularMethod provides a base class for specular methods that wrap a specular method to alter the
        * calculated specular reflection strength.
        */
        var CompositeSpecularMethod = (function (_super) {
            __extends(CompositeSpecularMethod, _super);
            /**
            * Creates a new <code>CompositeSpecularMethod</code> object.
            * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t : ShaderRegisterElement, regCache : ShaderRegisterCache) : string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.
            * @param baseSpecularMethod The base specular method on which this method's shading is based.
            */
            function CompositeSpecularMethod(scope, modulateMethod, baseSpecularMethod) {
                if (typeof baseSpecularMethod === "undefined") { baseSpecularMethod = null; }
                _super.call(this);

                this._onShaderInvalidatedDelegate = Delegate.create(this, this.onShaderInvalidated);

                if (scope != null && modulateMethod != null)
                    this._pInitCompositeSpecularMethod(scope, modulateMethod, baseSpecularMethod);
            }
            CompositeSpecularMethod.prototype._pInitCompositeSpecularMethod = function (scope, modulateMethod, baseSpecularMethod) {
                if (typeof baseSpecularMethod === "undefined") { baseSpecularMethod = null; }
                this._baseMethod = baseSpecularMethod || new materials.BasicSpecularMethod();
                this._baseMethod._iModulateMethod = modulateMethod;
                this._baseMethod._iModulateMethodScope = scope;
                this._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iInitVO = function (vo) {
                this._baseMethod.iInitVO(vo);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iInitConstants = function (vo) {
                this._baseMethod.iInitConstants(vo);
            };

            Object.defineProperty(CompositeSpecularMethod.prototype, "baseMethod", {
                get: /**
                * The base specular method on which this method's shading is based.
                */
                function () {
                    return this._baseMethod;
                },
                set: function (value) {
                    if (this._baseMethod == value)
                        return;

                    this._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    this._baseMethod = value;
                    this._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompositeSpecularMethod.prototype, "gloss", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._baseMethod.gloss;
                },
                set: function (value) {
                    this._baseMethod.gloss = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompositeSpecularMethod.prototype, "specular", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._baseMethod.specular;
                },
                set: function (value) {
                    this._baseMethod.specular = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompositeSpecularMethod.prototype, "passes", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._baseMethod.passes;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.dispose = function () {
                this._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                this._baseMethod.dispose();
            };

            Object.defineProperty(CompositeSpecularMethod.prototype, "texture", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._baseMethod.texture;
                },
                set: function (value) {
                    this._baseMethod.texture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iActivate = function (vo, stageGL) {
                this._baseMethod.iActivate(vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iDeactivate = function (vo, stageGL) {
                this._baseMethod.iDeactivate(vo, stageGL);
            };

            Object.defineProperty(CompositeSpecularMethod.prototype, "iSharedRegisters", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    _super.prototype.setISharedRegisters.call(this, value);
                    this._baseMethod.setISharedRegisters(value);
                },
                enumerable: true,
                configurable: true
            });

            CompositeSpecularMethod.prototype.setISharedRegisters = function (value) {
                _super.prototype.setISharedRegisters.call(this, value);
                this._baseMethod.setISharedRegisters(value);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iGetVertexCode = function (vo, regCache) {
                return this._baseMethod.iGetVertexCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                return this._baseMethod.iGetFragmentPreLightingCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                return this._baseMethod.iGetFragmentCodePerLight(vo, lightDirReg, lightColReg, regCache);
            };

            /**
            * @inheritDoc
            * @return
            */
            CompositeSpecularMethod.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                return this._baseMethod.iGetFragmentCodePerProbe(vo, cubeMapReg, weightRegister, regCache);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                return this._baseMethod.iGetFragmentPostLightingCode(vo, regCache, targetReg);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iReset = function () {
                this._baseMethod.iReset();
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._baseMethod.iCleanCompilationData();
            };

            Object.defineProperty(CompositeSpecularMethod.prototype, "iShadowRegister", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    this.setIShadowRegister(value);
                    this._baseMethod.setIShadowRegister(value);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Called when the base method's shader code is invalidated.
            */
            CompositeSpecularMethod.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };
            return CompositeSpecularMethod;
        })(materials.BasicSpecularMethod);
        materials.CompositeSpecularMethod = CompositeSpecularMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * EnvMapMethod provides a material method to perform reflection mapping using cube maps.
        */
        var EnvMapMethod = (function (_super) {
            __extends(EnvMapMethod, _super);
            /**
            * Creates an EnvMapMethod object.
            * @param envMap The environment map containing the reflected scene.
            * @param alpha The reflectivity of the surface.
            */
            function EnvMapMethod(envMap, alpha) {
                if (typeof alpha === "undefined") { alpha = 1; }
                _super.call(this);
                this._cubeTexture = envMap;
                this._alpha = alpha;
            }
            Object.defineProperty(EnvMapMethod.prototype, "mask", {
                get: /**
                * An optional texture to modulate the reflectivity of the surface.
                */
                function () {
                    return this._mask;
                },
                set: function (value) {
                    if (value != this._mask || (value && this._mask && (value.hasMipMaps != this._mask.hasMipMaps || value.format != this._mask.format)))
                        this.iInvalidateShaderProgram();

                    /*
                    if (Boolean(value) != Boolean(_mask) ||
                    (value && _mask && (value.hasMipMaps != _mask.hasMipMaps || value.format != _mask.format))) {
                    invalidateShaderProgram();
                    }
                    */
                    this._mask = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EnvMapMethod.prototype.iInitVO = function (vo) {
                vo.needsNormals = true;
                vo.needsView = true;
                vo.needsUV = this._mask != null;
            };

            Object.defineProperty(EnvMapMethod.prototype, "envMap", {
                get: /**
                * The cubic environment map containing the reflected scene.
                */
                function () {
                    return this._cubeTexture;
                },
                set: function (value) {
                    this._cubeTexture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EnvMapMethod.prototype.dispose = function () {
            };

            Object.defineProperty(EnvMapMethod.prototype, "alpha", {
                get: /**
                * The reflectivity of the surface.
                */
                function () {
                    return this._alpha;
                },
                set: function (value) {
                    this._alpha = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EnvMapMethod.prototype.iActivate = function (vo, stageGL) {
                var context = stageGL.contextGL;
                vo.fragmentData[vo.fragmentConstantsIndex] = this._alpha;

                context.setTextureAt(vo.texturesIndex, this._cubeTexture.getTextureForStageGL(stageGL));
                if (this._mask) {
                    context.setTextureAt(vo.texturesIndex + 1, this._mask.getTextureForStageGL(stageGL));
                }
            };

            /**
            * @inheritDoc
            */
            EnvMapMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var dataRegister = regCache.getFreeFragmentConstant();
                var temp = regCache.getFreeFragmentVectorTemp();
                var code = "";
                var cubeMapReg = regCache.getFreeTextureReg();

                vo.texturesIndex = cubeMapReg.index;
                vo.fragmentConstantsIndex = dataRegister.index * 4;

                regCache.addFragmentTempUsages(temp, 1);
                var temp2 = regCache.getFreeFragmentVectorTemp();

                // r = I - 2(I.N)*N
                code += "dp3 " + temp + ".w, " + this._sharedRegisters.viewDirFragment + ".xyz, " + this._sharedRegisters.normalFragment + ".xyz		\n" + "add " + temp + ".w, " + temp + ".w, " + temp + ".w											\n" + "mul " + temp + ".xyz, " + this._sharedRegisters.normalFragment + ".xyz, " + temp + ".w						\n" + "sub " + temp + ".xyz, " + temp + ".xyz, " + this._sharedRegisters.viewDirFragment + ".xyz					\n" + this.pGetTexCubeSampleCode(vo, temp, cubeMapReg, this._cubeTexture, temp) + "sub " + temp2 + ".w, " + temp + ".w, fc0.x									\n" + "kil " + temp2 + ".w\n" + "sub " + temp + ", " + temp + ", " + targetReg + "											\n";

                if (this._mask) {
                    var maskReg = regCache.getFreeTextureReg();
                    code += this.pGetTex2DSampleCode(vo, temp2, maskReg, this._mask, this._sharedRegisters.uvVarying) + "mul " + temp + ", " + temp2 + ", " + temp + "\n";
                }
                code += "mul " + temp + ", " + temp + ", " + dataRegister + ".x										\n" + "add " + targetReg + ", " + targetReg + ", " + temp + "										\n";

                regCache.removeFragmentTempUsage(temp);

                return code;
            };
            return EnvMapMethod;
        })(materials.EffectMethodBase);
        materials.EnvMapMethod = EnvMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * FresnelSpecularMethod provides a specular shading method that causes stronger highlights on grazing view angles.
        */
        var FresnelSpecularMethod = (function (_super) {
            __extends(FresnelSpecularMethod, _super);
            /**
            * Creates a new FresnelSpecularMethod object.
            * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
            * @param baseSpecularMethod The specular method to which the fresnel equation. Defaults to BasicSpecularMethod.
            */
            function FresnelSpecularMethod(basedOnSurface, baseSpecularMethod) {
                if (typeof basedOnSurface === "undefined") { basedOnSurface = true; }
                if (typeof baseSpecularMethod === "undefined") { baseSpecularMethod = null; }
                // may want to offer diff speculars
                _super.call(this, null, null);
                this._fresnelPower = 5;
                this._normalReflectance = .028;

                this._pInitCompositeSpecularMethod(this, this.modulateSpecular, baseSpecularMethod);

                this._incidentLight = !basedOnSurface;
            }
            /**
            * @inheritDoc
            */
            FresnelSpecularMethod.prototype.iInitConstants = function (vo) {
                var index = vo.secondaryFragmentConstantsIndex;
                vo.fragmentData[index + 2] = 1;
                vo.fragmentData[index + 3] = 0;
            };

            Object.defineProperty(FresnelSpecularMethod.prototype, "basedOnSurface", {
                get: /**
                * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
                */
                function () {
                    return !this._incidentLight;
                },
                set: function (value) {
                    if (this._incidentLight != value)
                        return;

                    this._incidentLight = !value;

                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(FresnelSpecularMethod.prototype, "fresnelPower", {
                get: /**
                * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.
                */
                function () {
                    return this._fresnelPower;
                },
                set: function (value) {
                    this._fresnelPower = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            FresnelSpecularMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._dataReg = null;
            };

            Object.defineProperty(FresnelSpecularMethod.prototype, "normalReflectance", {
                get: /**
                * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.
                */
                function () {
                    return this._normalReflectance;
                },
                set: function (value) {
                    this._normalReflectance = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            FresnelSpecularMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);
                var fragmentData = vo.fragmentData;

                var index = vo.secondaryFragmentConstantsIndex;
                fragmentData[index] = this._normalReflectance;
                fragmentData[index + 1] = this._fresnelPower;
            };

            /**
            * @inheritDoc
            */
            FresnelSpecularMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                this._dataReg = regCache.getFreeFragmentConstant();

                console.log('FresnelSpecularMethod', 'iGetFragmentPreLightingCode', this._dataReg);

                vo.secondaryFragmentConstantsIndex = this._dataReg.index * 4;
                return _super.prototype.iGetFragmentPreLightingCode.call(this, vo, regCache);
            };

            /**
            * Applies the fresnel effect to the specular strength.
            *
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param target The register containing the specular strength in the "w" component, and the half-vector/reflection vector in "xyz".
            * @param regCache The register cache used for the shader compilation.
            * @param sharedRegisters The shared registers created by the compiler.
            * @return The AGAL fragment code for the method.
            */
            FresnelSpecularMethod.prototype.modulateSpecular = function (vo, target, regCache, sharedRegisters) {
                var code;

                code = "dp3 " + target + ".y, " + sharedRegisters.viewDirFragment + ".xyz, " + (this._incidentLight ? target + ".xyz\n" : sharedRegisters.normalFragment + ".xyz\n") + "sub " + target + ".y, " + this._dataReg + ".z, " + target + ".y\n" + "pow " + target + ".x, " + target + ".y, " + this._dataReg + ".y\n" + "sub " + target + ".y, " + this._dataReg + ".z, " + target + ".y\n" + "mul " + target + ".y, " + this._dataReg + ".x, " + target + ".y\n" + "add " + target + ".y, " + target + ".x, " + target + ".y\n" + "mul " + target + ".w, " + target + ".w, " + target + ".y\n";

                console.log('FresnelSpecularMethod', 'modulateSpecular', code);

                return code;
            };
            return FresnelSpecularMethod;
        })(materials.CompositeSpecularMethod);
        materials.FresnelSpecularMethod = FresnelSpecularMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * SimpleWaterNormalMethod provides a basic normal map method to create water ripples by translating two wave normal maps.
        */
        var SimpleWaterNormalMethod = (function (_super) {
            __extends(SimpleWaterNormalMethod, _super);
            /**
            * Creates a new SimpleWaterNormalMethod object.
            * @param waveMap1 A normal map containing one layer of a wave structure.
            * @param waveMap2 A normal map containing a second layer of a wave structure.
            */
            function SimpleWaterNormalMethod(waveMap1, waveMap2) {
                _super.call(this);
                this._useSecondNormalMap = false;
                this._water1OffsetX = 0;
                this._water1OffsetY = 0;
                this._water2OffsetX = 0;
                this._water2OffsetY = 0;
                this.normalMap = waveMap1;
                this.secondaryNormalMap = waveMap2;
            }
            /**
            * @inheritDoc
            */
            SimpleWaterNormalMethod.prototype.iInitConstants = function (vo) {
                var index = vo.fragmentConstantsIndex;
                vo.fragmentData[index] = .5;
                vo.fragmentData[index + 1] = 0;
                vo.fragmentData[index + 2] = 0;
                vo.fragmentData[index + 3] = 1;
            };

            /**
            * @inheritDoc
            */
            SimpleWaterNormalMethod.prototype.iInitVO = function (vo) {
                _super.prototype.iInitVO.call(this, vo);

                this._useSecondNormalMap = this.normalMap != this.secondaryNormalMap;
            };

            Object.defineProperty(SimpleWaterNormalMethod.prototype, "water1OffsetX", {
                get: /**
                * The translation of the first wave layer along the X-axis.
                */
                function () {
                    return this._water1OffsetX;
                },
                set: function (value) {
                    this._water1OffsetX = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SimpleWaterNormalMethod.prototype, "water1OffsetY", {
                get: /**
                * The translation of the first wave layer along the Y-axis.
                */
                function () {
                    return this._water1OffsetY;
                },
                set: function (value) {
                    this._water1OffsetY = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SimpleWaterNormalMethod.prototype, "water2OffsetX", {
                get: /**
                * The translation of the second wave layer along the X-axis.
                */
                function () {
                    return this._water2OffsetX;
                },
                set: function (value) {
                    this._water2OffsetX = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SimpleWaterNormalMethod.prototype, "water2OffsetY", {
                get: /**
                * The translation of the second wave layer along the Y-axis.
                */
                function () {
                    return this._water2OffsetY;
                },
                set: function (value) {
                    this._water2OffsetY = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SimpleWaterNormalMethod.prototype, "normalMap", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    if (!value) {
                        return;
                    }
                    this.setNormalMap(value);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SimpleWaterNormalMethod.prototype, "secondaryNormalMap", {
                get: /**
                * A second normal map that will be combined with the first to create a wave-like animation pattern.
                */
                function () {
                    return this._texture2;
                },
                set: function (value) {
                    this._texture2 = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SimpleWaterNormalMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._normalTextureRegister2 = null;
            };

            /**
            * @inheritDoc
            */
            SimpleWaterNormalMethod.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this._texture2 = null;
            };

            /**
            * @inheritDoc
            */
            SimpleWaterNormalMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);

                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;

                data[index + 4] = this._water1OffsetX;
                data[index + 5] = this._water1OffsetY;
                data[index + 6] = this._water2OffsetX;
                data[index + 7] = this._water2OffsetY;

                if (this._useSecondNormalMap)
                    stageGL.contextGL.setTextureAt(vo.texturesIndex + 1, this._texture2.getTextureForStageGL(stageGL));
            };

            /**
            * @inheritDoc
            */
            SimpleWaterNormalMethod.prototype.getFragmentCode = function (vo, regCache, targetReg) {
                var temp = regCache.getFreeFragmentVectorTemp();
                var dataReg = regCache.getFreeFragmentConstant();
                var dataReg2 = regCache.getFreeFragmentConstant();
                this._pNormalTextureRegister = regCache.getFreeTextureReg();
                this._normalTextureRegister2 = this._useSecondNormalMap ? regCache.getFreeTextureReg() : this._pNormalTextureRegister;
                vo.texturesIndex = this._pNormalTextureRegister.index;

                vo.fragmentConstantsIndex = dataReg.index * 4;
                return "add " + temp + ", " + this._sharedRegisters.uvVarying + ", " + dataReg2 + ".xyxy\n" + this.pGetTex2DSampleCode(vo, targetReg, this._pNormalTextureRegister, this.normalMap, temp) + "add " + temp + ", " + this._sharedRegisters.uvVarying + ", " + dataReg2 + ".zwzw\n" + this.pGetTex2DSampleCode(vo, temp, this._normalTextureRegister2, this._texture2, temp) + "add " + targetReg + ", " + targetReg + ", " + temp + "		\n" + "mul " + targetReg + ", " + targetReg + ", " + dataReg + ".x	\n" + "sub " + targetReg + ".xyz, " + targetReg + ".xyz, " + this._sharedRegisters.commons + ".xxx	\n" + "nrm " + targetReg + ".xyz, " + targetReg + ".xyz							\n";
            };
            return SimpleWaterNormalMethod;
        })(materials.BasicNormalMethod);
        materials.SimpleWaterNormalMethod = SimpleWaterNormalMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * LightPickerBase provides an abstract base clase for light picker classes. These classes are responsible for
        * feeding materials with relevant lights. Usually, StaticLightPicker can be used, but LightPickerBase can be
        * extended to provide more application-specific dynamic selection of lights.
        *
        * @see StaticLightPicker
        */
        var LightPickerBase = (function (_super) {
            __extends(LightPickerBase, _super);
            /**
            * Creates a new LightPickerBase object.
            */
            function LightPickerBase() {
                _super.call(this);
                this._pNumPointLights = 0;
                this._pNumDirectionalLights = 0;
                this._pNumCastingPointLights = 0;
                this._pNumCastingDirectionalLights = 0;
                this._pNumLightProbes = 0;
            }
            /**
            * Disposes resources used by the light picker.
            */
            LightPickerBase.prototype.dispose = function () {
            };

            Object.defineProperty(LightPickerBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.LIGHT_PICKER;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numDirectionalLights", {
                get: /**
                * The maximum amount of directional lights that will be provided.
                */
                function () {
                    return this._pNumDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numPointLights", {
                get: /**
                * The maximum amount of point lights that will be provided.
                */
                function () {
                    return this._pNumPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numCastingDirectionalLights", {
                get: /**
                * The maximum amount of directional lights that cast shadows.
                */
                function () {
                    return this._pNumCastingDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numCastingPointLights", {
                get: /**
                * The amount of point lights that cast shadows.
                */
                function () {
                    return this._pNumCastingPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numLightProbes", {
                get: /**
                * The maximum amount of light probes that will be provided.
                */
                function () {
                    return this._pNumLightProbes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "pointLights", {
                get: /**
                * The collected point lights to be used for shading.
                */
                function () {
                    return this._pPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "directionalLights", {
                get: /**
                * The collected directional lights to be used for shading.
                */
                function () {
                    return this._pDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "castingPointLights", {
                get: /**
                * The collected point lights that cast shadows to be used for shading.
                */
                function () {
                    return this._pCastingPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "castingDirectionalLights", {
                get: /**
                * The collected directional lights that cast shadows to be used for shading.
                */
                function () {
                    return this._pCastingDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "lightProbes", {
                get: /**
                * The collected light probes to be used for shading.
                */
                function () {
                    return this._pLightProbes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "lightProbeWeights", {
                get: /**
                * The weights for each light probe, defining their influence on the object.
                */
                function () {
                    return this._pLightProbeWeights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "allPickedLights", {
                get: /**
                * A collection of all the collected lights.
                */
                function () {
                    return this._pAllPickedLights;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates set of lights for a given renderable and EntityCollector. Always call super.collectLights() after custom overridden code.
            */
            LightPickerBase.prototype.collectLights = function (renderable, entityCollector) {
                this.updateProbeWeights(renderable);
            };

            /**
            * Updates the weights for the light probes, based on the renderable's position relative to them.
            * @param renderable The renderble for which to calculate the light probes' influence.
            */
            LightPickerBase.prototype.updateProbeWeights = function (renderable) {
                // todo: this will cause the same calculations to occur per SubMesh. See if this can be improved.
                var objectPos = renderable.sourceEntity.scenePosition;
                var lightPos;

                var rx = objectPos.x, ry = objectPos.y, rz = objectPos.z;
                var dx, dy, dz;
                var w, total = 0;
                var i;

                for (i = 0; i < this._pNumLightProbes; ++i) {
                    lightPos = this._pLightProbes[i].scenePosition;
                    dx = rx - lightPos.x;
                    dy = ry - lightPos.y;
                    dz = rz - lightPos.z;

                    // weight is inversely proportional to square of distance
                    w = dx * dx + dy * dy + dz * dz;

                    // just... huge if at the same spot
                    w = w > .00001 ? 1 / w : 50000000;
                    this._pLightProbeWeights[i] = w;
                    total += w;
                }

                // normalize
                total = 1 / total;

                for (i = 0; i < this._pNumLightProbes; ++i) {
                    this._pLightProbeWeights[i] *= total;
                }
            };
            return LightPickerBase;
        })(away.library.NamedAssetBase);
        materials.LightPickerBase = LightPickerBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var Delegate = away.utils.Delegate;

        var LightEvent = away.events.LightEvent;
        var DirectionalLight = away.lights.DirectionalLight;
        var LightBase = away.lights.LightBase;
        var LightProbe = away.lights.LightProbe;
        var PointLight = away.lights.PointLight;

        /**
        * StaticLightPicker is a light picker that provides a static set of lights. The lights can be reassigned, but
        * if the configuration changes (number of directional lights, point lights, etc), a material recompilation may
        * occur.
        */
        var StaticLightPicker = (function (_super) {
            __extends(StaticLightPicker, _super);
            /**
            * Creates a new StaticLightPicker object.
            * @param lights The lights to be used for shading.
            */
            function StaticLightPicker(lights) {
                _super.call(this);

                this._onCastShadowChangeDelegate = Delegate.create(this, this.onCastShadowChange);

                this.lights = lights;
            }
            Object.defineProperty(StaticLightPicker.prototype, "lights", {
                get: /**
                * The lights used for shading.
                */
                function () {
                    return this._lights;
                },
                set: function (value) {
                    var numPointLights = 0;
                    var numDirectionalLights = 0;
                    var numCastingPointLights = 0;
                    var numCastingDirectionalLights = 0;
                    var numLightProbes = 0;
                    var light;

                    if (this._lights)
                        this.clearListeners();

                    this._lights = value;
                    this._pAllPickedLights = value;
                    this._pPointLights = new Array();
                    this._pCastingPointLights = new Array();
                    this._pDirectionalLights = new Array();
                    this._pCastingDirectionalLights = new Array();
                    this._pLightProbes = new Array();

                    var len = value.length;

                    for (var i = 0; i < len; ++i) {
                        light = value[i];
                        light.addEventListener(LightEvent.CASTS_SHADOW_CHANGE, this._onCastShadowChangeDelegate);

                        if (light instanceof PointLight) {
                            if (light.castsShadows)
                                this._pCastingPointLights[numCastingPointLights++] = light;
else
                                this._pPointLights[numPointLights++] = light;
                        } else if (light instanceof DirectionalLight) {
                            if (light.castsShadows)
                                this._pCastingDirectionalLights[numCastingDirectionalLights++] = light;
else
                                this._pDirectionalLights[numDirectionalLights++] = light;
                        } else if (light instanceof LightProbe) {
                            this._pLightProbes[numLightProbes++] = light;
                        }
                    }

                    if (this._pNumDirectionalLights == numDirectionalLights && this._pNumPointLights == numPointLights && this._pNumLightProbes == numLightProbes && this._pNumCastingPointLights == numCastingPointLights && this._pNumCastingDirectionalLights == numCastingDirectionalLights) {
                        return;
                    }

                    this._pNumDirectionalLights = numDirectionalLights;
                    this._pNumCastingDirectionalLights = numCastingDirectionalLights;
                    this._pNumPointLights = numPointLights;
                    this._pNumCastingPointLights = numCastingPointLights;
                    this._pNumLightProbes = numLightProbes;

                    // MUST HAVE MULTIPLE OF 4 ELEMENTS!
                    this._pLightProbeWeights = new Array(Math.ceil(numLightProbes / 4) * 4);

                    // notify material lights have changed
                    this.dispatchEvent(new away.events.Event(away.events.Event.CHANGE));
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Remove configuration change listeners on the lights.
            */
            StaticLightPicker.prototype.clearListeners = function () {
                var len = this._lights.length;
                for (var i = 0; i < len; ++i)
                    this._lights[i].removeEventListener(away.events.LightEvent.CASTS_SHADOW_CHANGE, this._onCastShadowChangeDelegate);
            };

            /**
            * Notifies the material of a configuration change.
            */
            StaticLightPicker.prototype.onCastShadowChange = function (event) {
                // TODO: Assign to special caster collections, just append it to the lights in SinglePass
                // But keep seperated in multipass
                var light = event.target;

                if (light instanceof PointLight) {
                    var pl = light;
                    this.updatePointCasting(pl);
                } else if (light instanceof DirectionalLight) {
                    var dl = light;
                    this.updateDirectionalCasting(dl);
                }

                this.dispatchEvent(new away.events.Event(away.events.Event.CHANGE));
            };

            /**
            * Called when a directional light's shadow casting configuration changes.
            */
            StaticLightPicker.prototype.updateDirectionalCasting = function (light) {
                var dl = light;

                if (light.castsShadows) {
                    --this._pNumDirectionalLights;
                    ++this._pNumCastingDirectionalLights;

                    this._pDirectionalLights.splice(this._pDirectionalLights.indexOf(dl), 1);
                    this._pCastingDirectionalLights.push(light);
                } else {
                    ++this._pNumDirectionalLights;
                    --this._pNumCastingDirectionalLights;

                    this._pCastingDirectionalLights.splice(this._pCastingDirectionalLights.indexOf(dl), 1);
                    this._pDirectionalLights.push(light);
                }
            };

            /**
            * Called when a point light's shadow casting configuration changes.
            */
            StaticLightPicker.prototype.updatePointCasting = function (light) {
                var pl = light;

                if (light.castsShadows) {
                    --this._pNumPointLights;
                    ++this._pNumCastingPointLights;
                    this._pPointLights.splice(this._pPointLights.indexOf(pl), 1);
                    this._pCastingPointLights.push(light);
                } else {
                    ++this._pNumPointLights;
                    --this._pNumCastingPointLights;

                    this._pCastingPointLights.splice(this._pCastingPointLights.indexOf(pl), 1);
                    this._pPointLights.push(light);
                }
            };
            return StaticLightPicker;
        })(materials.LightPickerBase);
        materials.StaticLightPicker = StaticLightPicker;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * ShaderRegister Cache provides the usage management system for all registers during shading compilation.
        */
        var ShaderRegisterCache = (function () {
            /**
            * Create a new ShaderRegisterCache object.
            *
            * @param profile The compatibility profile used by the renderer.
            */
            function ShaderRegisterCache(profile) {
                this._numUsedVertexConstants = 0;
                this._numUsedFragmentConstants = 0;
                this._numUsedStreams = 0;
                this._numUsedTextures = 0;
                this._numUsedVaryings = 0;
                this._profile = profile;
            }
            /**
            * Resets all registers.
            */
            ShaderRegisterCache.prototype.reset = function () {
                //TODO: AGAL <> GLSL Conversion
                this._fragmentTempCache = new materials.RegisterPool("ft", 8, false);
                this._vertexTempCache = new materials.RegisterPool("vt", 8, false);
                this._varyingCache = new materials.RegisterPool("v", 8);
                this._textureCache = new materials.RegisterPool("fs", 8);
                this._vertexAttributesCache = new materials.RegisterPool("va", 8);
                this._fragmentConstantsCache = new materials.RegisterPool("fc", 28);
                this._vertexConstantsCache = new materials.RegisterPool("vc", 128);
                this._fragmentOutputRegister = new materials.ShaderRegisterElement("oc", -1);
                this._vertexOutputRegister = new materials.ShaderRegisterElement("op", -1);
                this._numUsedVertexConstants = 0;
                this._numUsedStreams = 0;
                this._numUsedTextures = 0;
                this._numUsedVaryings = 0;
                this._numUsedFragmentConstants = 0;

                var i;

                for (i = 0; i < this._vertexAttributesOffset; ++i)
                    this.getFreeVertexAttribute();

                for (i = 0; i < this._vertexConstantOffset; ++i)
                    this.getFreeVertexConstant();

                for (i = 0; i < this._varyingsOffset; ++i)
                    this.getFreeVarying();

                for (i = 0; i < this._fragmentConstantOffset; ++i)
                    this.getFreeFragmentConstant();
            };

            /**
            * Disposes all resources used.
            */
            ShaderRegisterCache.prototype.dispose = function () {
                this._fragmentTempCache.dispose();
                this._vertexTempCache.dispose();
                this._varyingCache.dispose();
                this._fragmentConstantsCache.dispose();
                this._vertexAttributesCache.dispose();

                this._fragmentTempCache = null;
                this._vertexTempCache = null;
                this._varyingCache = null;
                this._fragmentConstantsCache = null;
                this._vertexAttributesCache = null;
                this._fragmentOutputRegister = null;
                this._vertexOutputRegister = null;
            };

            /**
            * Marks a fragment temporary register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
            * has been called usageCount times again.
            * @param register The register to mark as used.
            * @param usageCount The amount of usages to add.
            */
            ShaderRegisterCache.prototype.addFragmentTempUsages = function (register, usageCount) {
                this._fragmentTempCache.addUsage(register, usageCount);
            };

            /**
            * Removes a usage from a fragment temporary register. When usages reach 0, the register is freed again.
            * @param register The register for which to remove a usage.
            */
            ShaderRegisterCache.prototype.removeFragmentTempUsage = function (register) {
                this._fragmentTempCache.removeUsage(register);
            };

            /**
            * Marks a vertex temporary register as used, so it cannot be retrieved. The register won't be able to be used
            * until removeUsage has been called usageCount times again.
            * @param register The register to mark as used.
            * @param usageCount The amount of usages to add.
            */
            ShaderRegisterCache.prototype.addVertexTempUsages = function (register, usageCount) {
                this._vertexTempCache.addUsage(register, usageCount);
            };

            /**
            * Removes a usage from a vertex temporary register. When usages reach 0, the register is freed again.
            * @param register The register for which to remove a usage.
            */
            ShaderRegisterCache.prototype.removeVertexTempUsage = function (register) {
                this._vertexTempCache.removeUsage(register);
            };

            /**
            * Retrieve an entire fragment temporary register that's still available. The register won't be able to be used until removeUsage
            * has been called usageCount times again.
            */
            ShaderRegisterCache.prototype.getFreeFragmentVectorTemp = function () {
                return this._fragmentTempCache.requestFreeVectorReg();
            };

            /**
            * Retrieve a single component from a fragment temporary register that's still available.
            */
            ShaderRegisterCache.prototype.getFreeFragmentSingleTemp = function () {
                return this._fragmentTempCache.requestFreeRegComponent();
            };

            /**
            * Retrieve an available varying register
            */
            ShaderRegisterCache.prototype.getFreeVarying = function () {
                ++this._numUsedVaryings;
                return this._varyingCache.requestFreeVectorReg();
            };

            /**
            * Retrieve an available fragment constant register
            */
            ShaderRegisterCache.prototype.getFreeFragmentConstant = function () {
                ++this._numUsedFragmentConstants;
                return this._fragmentConstantsCache.requestFreeVectorReg();
            };

            /**
            * Retrieve an available vertex constant register
            */
            ShaderRegisterCache.prototype.getFreeVertexConstant = function () {
                ++this._numUsedVertexConstants;
                return this._vertexConstantsCache.requestFreeVectorReg();
            };

            /**
            * Retrieve an entire vertex temporary register that's still available.
            */
            ShaderRegisterCache.prototype.getFreeVertexVectorTemp = function () {
                return this._vertexTempCache.requestFreeVectorReg();
            };

            /**
            * Retrieve a single component from a vertex temporary register that's still available.
            */
            ShaderRegisterCache.prototype.getFreeVertexSingleTemp = function () {
                return this._vertexTempCache.requestFreeRegComponent();
            };

            /**
            * Retrieve an available vertex attribute register
            */
            ShaderRegisterCache.prototype.getFreeVertexAttribute = function () {
                ++this._numUsedStreams;
                return this._vertexAttributesCache.requestFreeVectorReg();
            };

            /**
            * Retrieve an available texture register
            */
            ShaderRegisterCache.prototype.getFreeTextureReg = function () {
                ++this._numUsedTextures;
                return this._textureCache.requestFreeVectorReg();
            };

            Object.defineProperty(ShaderRegisterCache.prototype, "vertexConstantOffset", {
                get: /**
                * Indicates the start index from which to retrieve vertex constants.
                */
                function () {
                    return this._vertexConstantOffset;
                },
                set: function (vertexConstantOffset) {
                    this._vertexConstantOffset = vertexConstantOffset;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderRegisterCache.prototype, "vertexAttributesOffset", {
                get: /**
                * Indicates the start index from which to retrieve vertex attributes.
                */
                function () {
                    return this._vertexAttributesOffset;
                },
                set: function (value) {
                    this._vertexAttributesOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderRegisterCache.prototype, "varyingsOffset", {
                get: /**
                * Indicates the start index from which to retrieve varying registers.
                */
                function () {
                    return this._varyingsOffset;
                },
                set: function (value) {
                    this._varyingsOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderRegisterCache.prototype, "fragmentConstantOffset", {
                get: /**
                * Indicates the start index from which to retrieve fragment constants.
                */
                function () {
                    return this._fragmentConstantOffset;
                },
                set: function (value) {
                    this._fragmentConstantOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderRegisterCache.prototype, "fragmentOutputRegister", {
                get: /**
                * The fragment output register.
                */
                function () {
                    return this._fragmentOutputRegister;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVertexConstants", {
                get: /**
                * The amount of used vertex constant registers.
                */
                function () {
                    return this._numUsedVertexConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedFragmentConstants", {
                get: /**
                * The amount of used fragment constant registers.
                */
                function () {
                    return this._numUsedFragmentConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedStreams", {
                get: /**
                * The amount of used vertex streams.
                */
                function () {
                    return this._numUsedStreams;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedTextures", {
                get: /**
                * The amount of used texture slots.
                */
                function () {
                    return this._numUsedTextures;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVaryings", {
                get: /**
                * The amount of used varying registers.
                */
                function () {
                    return this._numUsedVaryings;
                },
                enumerable: true,
                configurable: true
            });
            return ShaderRegisterCache;
        })();
        materials.ShaderRegisterCache = ShaderRegisterCache;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * A single register element (an entire register or a single register's component) used by the RegisterPool.
        */
        var ShaderRegisterElement = (function () {
            /**
            * Creates a new ShaderRegisterElement object.
            * @param regName The name of the register.
            * @param index The index of the register.
            * @param component The register's component, if not the entire register is represented.
            */
            function ShaderRegisterElement(regName, index, component) {
                if (typeof component === "undefined") { component = -1; }
                this._component = component;
                this._regName = regName;
                this._index = index;

                this._toStr = this._regName;

                if (this._index >= 0) {
                    this._toStr += this._index;
                }

                if (component > -1) {
                    this._toStr += "." + ShaderRegisterElement.COMPONENTS[component];
                }
            }
            /**
            * Converts the register or the components AGAL string representation.
            */
            ShaderRegisterElement.prototype.toString = function () {
                return this._toStr;
            };

            Object.defineProperty(ShaderRegisterElement.prototype, "regName", {
                get: /**
                * The register's name.
                */
                function () {
                    return this._regName;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterElement.prototype, "index", {
                get: /**
                * The register's index.
                */
                function () {
                    return this._index;
                },
                enumerable: true,
                configurable: true
            });
            ShaderRegisterElement.COMPONENTS = ["x", "y", "z", "w"];
            return ShaderRegisterElement;
        })();
        materials.ShaderRegisterElement = ShaderRegisterElement;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * ShaderRegisterData contains the "named" registers, generated by the compiler and to be passed on to the methods.
        */
        var ShaderRegisterData = (function () {
            function ShaderRegisterData() {
            }
            return ShaderRegisterData;
        })();
        materials.ShaderRegisterData = ShaderRegisterData;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.materials.LightSources;
        //import away3d.materials.methods.MethodVO;
        /**
        * MethodDependencyCounter keeps track of the number of dependencies for "named registers" used across methods.
        * Named registers are that are not necessarily limited to a single method. They are created by the compiler and
        * passed on to methods. The compiler uses the results to reserve usages through RegisterPool, which can be removed
        * each time a method has been compiled into the shader.
        *
        * @see RegisterPool.addUsage
        */
        var MethodDependencyCounter = (function () {
            /**
            * Creates a new MethodDependencyCounter object.
            */
            function MethodDependencyCounter() {
                this._usesGlobalPosFragment = false;
            }
            /**
            * Clears dependency counts for all registers. Called when recompiling a pass.
            */
            MethodDependencyCounter.prototype.reset = function () {
                this._projectionDependencies = 0;
                this._normalDependencies = 0;
                this._viewDirDependencies = 0;
                this._uvDependencies = 0;
                this._secondaryUVDependencies = 0;
                this._globalPosDependencies = 0;
                this._tangentDependencies = 0;
                this._usesGlobalPosFragment = false;
            };

            /**
            * Sets the amount of lights that have a position associated with them.
            * @param numPointLights The amount of point lights.
            * @param lightSourceMask The light source types used by the material.
            */
            MethodDependencyCounter.prototype.setPositionedLights = function (numPointLights, lightSourceMask) {
                this._numPointLights = numPointLights;
                this._lightSourceMask = lightSourceMask;
            };

            /**
            * Increases dependency counters for the named registers listed as required by the given MethodVO.
            * @param methodVO the MethodVO object for which to include dependencies.
            */
            MethodDependencyCounter.prototype.includeMethodVO = function (methodVO) {
                if (methodVO.needsProjection) {
                    ++this._projectionDependencies;
                }

                if (methodVO.needsGlobalVertexPos) {
                    ++this._globalPosDependencies;

                    if (methodVO.needsGlobalFragmentPos) {
                        this._usesGlobalPosFragment = true;
                    }
                } else if (methodVO.needsGlobalFragmentPos) {
                    ++this._globalPosDependencies;
                    this._usesGlobalPosFragment = true;
                }

                if (methodVO.needsNormals) {
                    ++this._normalDependencies;
                }

                if (methodVO.needsTangents) {
                    ++this._tangentDependencies;
                }

                if (methodVO.needsView) {
                    ++this._viewDirDependencies;
                }

                if (methodVO.needsUV) {
                    ++this._uvDependencies;
                }

                if (methodVO.needsSecondaryUV) {
                    ++this._secondaryUVDependencies;
                }
            };

            Object.defineProperty(MethodDependencyCounter.prototype, "tangentDependencies", {
                get: /**
                * The amount of tangent vector dependencies (fragment shader).
                */
                function () {
                    return this._tangentDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "usesGlobalPosFragment", {
                get: /**
                * Indicates whether there are any dependencies on the world-space position vector.
                */
                function () {
                    return this._usesGlobalPosFragment;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "projectionDependencies", {
                get: /**
                * The amount of dependencies on the projected position.
                */
                function () {
                    return this._projectionDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "normalDependencies", {
                get: /**
                * The amount of dependencies on the normal vector.
                */
                function () {
                    return this._normalDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "viewDirDependencies", {
                get: /**
                * The amount of dependencies on the view direction.
                */
                function () {
                    return this._viewDirDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "uvDependencies", {
                get: /**
                * The amount of dependencies on the primary UV coordinates.
                */
                function () {
                    return this._uvDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "secondaryUVDependencies", {
                get: /**
                * The amount of dependencies on the secondary UV coordinates.
                */
                function () {
                    return this._secondaryUVDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "globalPosDependencies", {
                get: /**
                * The amount of dependencies on the global position. This can be 0 while hasGlobalPosDependencies is true when
                * the global position is used as a temporary value (fe to calculate the view direction)
                */
                function () {
                    return this._globalPosDependencies;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Adds any external world space dependencies, used to force world space calculations.
            */
            MethodDependencyCounter.prototype.addWorldSpaceDependencies = function (fragmentLights) {
                if (this._viewDirDependencies > 0) {
                    ++this._globalPosDependencies;
                }

                if (this._numPointLights > 0 && (this._lightSourceMask & materials.LightSources.LIGHTS)) {
                    ++this._globalPosDependencies;

                    if (fragmentLights) {
                        this._usesGlobalPosFragment = true;
                    }
                }
            };
            return MethodDependencyCounter;
        })();
        materials.MethodDependencyCounter = MethodDependencyCounter;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import flash.utils.Dictionary;
        /**
        * RegisterPool is used by the shader compilation process to keep track of which registers of a certain type are
        * currently used and should not be allowed to be written to. Either entire registers can be requested and locked,
        * or single components (x, y, z, w) of a single register.
        * It is used by ShaderRegisterCache to track usages of individual register types.
        *
        * @see away3d.materials.compilation.ShaderRegisterCache
        */
        var RegisterPool = (function () {
            /**
            * Creates a new RegisterPool object.
            * @param regName The base name of the register type ("ft" for fragment temporaries, "vc" for vertex constants, etc)
            * @param regCount The amount of available registers of this type.
            * @param persistent Whether or not registers, once reserved, can be freed again. For example, temporaries are not persistent, but constants are.
            */
            function RegisterPool(regName, regCount, persistent) {
                if (typeof persistent === "undefined") { persistent = true; }
                this._regName = regName;
                this._regCount = regCount;
                this._persistent = persistent;
                this.initRegisters(regName, regCount);
            }
            /**
            * Retrieve an entire vector register that's still available.
            */
            RegisterPool.prototype.requestFreeVectorReg = function () {
                for (var i = 0; i < this._regCount; ++i) {
                    if (!this.isRegisterUsed(i)) {
                        if (this._persistent)
                            this._usedVectorCount[i]++;

                        return this._vectorRegisters[i];
                    }
                }

                throw new Error("Register overflow!");
            };

            /**
            * Retrieve a single vector component that's still available.
            */
            RegisterPool.prototype.requestFreeRegComponent = function () {
                for (var i = 0; i < this._regCount; ++i) {
                    if (this._usedVectorCount[i] > 0)
                        continue;

                    for (var j = 0; j < 4; ++j) {
                        if (this._usedSingleCount[j][i] == 0) {
                            if (this._persistent) {
                                this._usedSingleCount[j][i]++;
                            }

                            return this._registerComponents[j][i];
                        }
                    }
                }

                throw new Error("Register overflow!");
            };

            /**
            * Marks a register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
            * has been called usageCount times again.
            * @param register The register to mark as used.
            * @param usageCount The amount of usages to add.
            */
            RegisterPool.prototype.addUsage = function (register, usageCount) {
                if (register._component > -1) {
                    this._usedSingleCount[register._component][register.index] += usageCount;
                } else {
                    this._usedVectorCount[register.index] += usageCount;
                }
            };

            /**
            * Removes a usage from a register. When usages reach 0, the register is freed again.
            * @param register The register for which to remove a usage.
            */
            RegisterPool.prototype.removeUsage = function (register) {
                if (register._component > -1) {
                    if (--this._usedSingleCount[register._component][register.index] < 0) {
                        throw new Error("More usages removed than exist!");
                    }
                } else {
                    if (--this._usedVectorCount[register.index] < 0) {
                        throw new Error("More usages removed than exist!");
                    }
                }
            };

            /**
            * Disposes any resources used by the current RegisterPool object.
            */
            RegisterPool.prototype.dispose = function () {
                this._vectorRegisters = null;
                this._registerComponents = null;
                this._usedSingleCount = null;
                this._usedVectorCount = null;
            };

            /**
            * Indicates whether or not any registers are in use.
            */
            RegisterPool.prototype.hasRegisteredRegs = function () {
                for (var i = 0; i < this._regCount; ++i) {
                    if (this.isRegisterUsed(i))
                        return true;
                }

                return false;
            };

            /**
            * Initializes all registers.
            */
            RegisterPool.prototype.initRegisters = function (regName, regCount) {
                var hash = RegisterPool._initPool(regName, regCount);

                this._vectorRegisters = RegisterPool._regPool[hash];
                this._registerComponents = RegisterPool._regCompsPool[hash];

                this._usedVectorCount = this._initArray(Array(regCount), 0);

                this._usedSingleCount = new Array(4);
                this._usedSingleCount[0] = this._initArray(new Array(regCount), 0);
                this._usedSingleCount[1] = this._initArray(new Array(regCount), 0);
                this._usedSingleCount[2] = this._initArray(new Array(regCount), 0);
                this._usedSingleCount[3] = this._initArray(new Array(regCount), 0);
                //console.log( 'this._usedVectorCount: ' , this._usedVectorCount );
                //console.log( 'this._usedSingleCount: ' , this._usedSingleCount );
            };

            RegisterPool._initPool = function (regName, regCount) {
                var hash = regName + regCount;

                if (RegisterPool._regPool[hash] != undefined) {
                    return hash;
                }

                var vectorRegisters = new Array(regCount);
                RegisterPool._regPool[hash] = vectorRegisters;

                var registerComponents = [
                    [],
                    [],
                    [],
                    []
                ];
                RegisterPool._regCompsPool[hash] = registerComponents;

                for (var i = 0; i < regCount; ++i) {
                    vectorRegisters[i] = new materials.ShaderRegisterElement(regName, i);

                    for (var j = 0; j < 4; ++j) {
                        registerComponents[j][i] = new materials.ShaderRegisterElement(regName, i, j);
                    }
                }

                //console.log ( 'RegisterPool._regCompsPool[hash] : ' , RegisterPool._regCompsPool[hash]  );
                //console.log ( 'RegisterPool._regPool[hash] : ' , RegisterPool._regPool[hash]  );
                return hash;
            };

            /**
            * Check if the temp register is either used for single or vector use
            */
            RegisterPool.prototype.isRegisterUsed = function (index) {
                if (this._usedVectorCount[index] > 0) {
                    return true;
                }

                for (var i = 0; i < 4; ++i) {
                    if (this._usedSingleCount[i][index] > 0) {
                        return true;
                    }
                }

                return false;
            };

            RegisterPool.prototype._initArray = function (a, val) {
                var l = a.length;

                for (var c = 0; c < l; c++) {
                    a[c] = val;
                }

                return a;
            };
            RegisterPool._regPool = new Object();
            RegisterPool._regCompsPool = new Object();
            return RegisterPool;
        })();
        materials.RegisterPool = RegisterPool;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * ShaderCompiler is an abstract base class for shader compilers that use modular shader methods to assemble a
        * material. Concrete subclasses are used by the default materials.
        *
        * @see away3d.materials.methods.ShadingMethodBase
        */
        var ShaderCompiler = (function () {
            /**
            * Creates a new ShaderCompiler object.
            * @param profile The compatibility profile of the renderer.
            */
            function ShaderCompiler(profile) {
                this._preserveAlpha = true;
                this._pVertexCode = '';
                this._pFragmentCode = '';
                this._commonsDataIndex = -1;
                this._uvBufferIndex = -1;
                this._uvTransformIndex = -1;
                this._secondaryUVBufferIndex = -1;
                this._pNormalBufferIndex = -1;
                this._pTangentBufferIndex = -1;
                this._pLightFragmentConstantIndex = -1;
                this._sceneMatrixIndex = -1;
                this._pSceneNormalMatrixIndex = -1;
                this._pCameraPositionIndex = -1;
                this._pProbeWeightsIndex = -1;
                this._pSharedRegisters = new materials.ShaderRegisterData();
                this._pDependencyCounter = new materials.MethodDependencyCounter();
                this._pProfile = profile;
                this.initRegisterCache(profile);
            }
            Object.defineProperty(ShaderCompiler.prototype, "enableLightFallOff", {
                get: /**
                * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
                * compatibility for constrained mode.
                */
                function () {
                    return this._pEnableLightFallOff;
                },
                set: function (value) {
                    this._pEnableLightFallOff = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "needUVAnimation", {
                get: /**
                * Indicates whether the compiled code needs UV animation.
                */
                function () {
                    return this._needUVAnimation;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "UVTarget", {
                get: /**
                * The target register to place the animated UV coordinate.
                */
                function () {
                    return this._UVTarget;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "UVSource", {
                get: /**
                * The souce register providing the UV coordinate to animate.
                */
                function () {
                    return this._UVSource;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "forceSeperateMVP", {
                get: /**
                * Indicates whether the screen projection should be calculated by forcing a separate scene matrix and
                * view-projection matrix. This is used to prevent rounding errors when using multiple passes with different
                * projection code.
                */
                function () {
                    return this._forceSeperateMVP;
                },
                set: function (value) {
                    this._forceSeperateMVP = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Initialized the register cache.
            * @param profile The compatibility profile of the renderer.
            */
            ShaderCompiler.prototype.initRegisterCache = function (profile) {
                this._pRegisterCache = new materials.ShaderRegisterCache(profile);
                this._pRegisterCache.vertexAttributesOffset = 1;
                this._pRegisterCache.reset();
            };

            Object.defineProperty(ShaderCompiler.prototype, "animateUVs", {
                get: /**
                * Indicate whether UV coordinates need to be animated using the renderable's transformUV matrix.
                */
                function () {
                    return this._animateUVs;
                },
                set: function (value) {
                    this._animateUVs = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "alphaPremultiplied", {
                get: /**
                * Indicates whether visible textures (or other pixels) used by this material have
                * already been premultiplied.
                */
                function () {
                    return this._pAlphaPremultiplied;
                },
                set: function (value) {
                    this._pAlphaPremultiplied = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "preserveAlpha", {
                get: /**
                * Indicates whether the output alpha value should remain unchanged compared to the material's original alpha.
                */
                function () {
                    return this._preserveAlpha;
                },
                set: function (value) {
                    this._preserveAlpha = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Sets the default texture sampling properties.
            * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.
            * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to true.
            * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to true.
            */
            ShaderCompiler.prototype.setTextureSampling = function (smooth, repeat, mipmap) {
                this._smooth = smooth;
                this._repeat = repeat;
                this._mipmap = mipmap;
            };

            /**
            * Sets the constant buffers allocated by the material. This allows setting constant data during compilation.
            * @param vertexConstantData The vertex constant data buffer.
            * @param fragmentConstantData The fragment constant data buffer.
            */
            ShaderCompiler.prototype.setConstantDataBuffers = function (vertexConstantData, fragmentConstantData) {
                this._vertexConstantData = vertexConstantData;
                this._fragmentConstantData = fragmentConstantData;
            };

            Object.defineProperty(ShaderCompiler.prototype, "methodSetup", {
                get: /**
                * The shader method setup object containing the method configuration and their value objects for the material being compiled.
                */
                function () {
                    return this._pMethodSetup;
                },
                set: function (value) {
                    this._pMethodSetup = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Compiles the code after all setup on the compiler has finished.
            */
            ShaderCompiler.prototype.compile = function () {
                this.pInitRegisterIndices();
                this.pInitLightData();

                this._pAnimatableAttributes = new Array("va0");
                this._pAnimationTargetRegisters = new Array("vt0");
                this._pVertexCode = "";
                this._pFragmentCode = "";

                this._pSharedRegisters.localPosition = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.localPosition, 1);

                this.createCommons();
                this.pCalculateDependencies();
                this.updateMethodRegisters();

                for (var i = 0; i < 4; ++i)
                    this._pRegisterCache.getFreeVertexConstant();

                this.pCreateNormalRegisters();

                if (this._pDependencyCounter.globalPosDependencies > 0 || this._forceSeperateMVP)
                    this.pCompileGlobalPositionCode();

                this.compileProjectionCode();
                this.pCompileMethodsCode();
                this.compileFragmentOutput();
                this._fragmentPostLightCode = this.fragmentCode;
            };

            /**
            * Creates the registers to contain the normal data.
            */
            ShaderCompiler.prototype.pCreateNormalRegisters = function () {
            };

            /**
            * Compile the code for the methods.
            */
            ShaderCompiler.prototype.pCompileMethodsCode = function () {
                if (this._pDependencyCounter.uvDependencies > 0)
                    this.compileUVCode();

                if (this._pDependencyCounter.secondaryUVDependencies > 0)
                    this.compileSecondaryUVCode();

                if (this._pDependencyCounter.normalDependencies > 0)
                    this.pCompileNormalCode();

                if (this._pDependencyCounter.viewDirDependencies > 0)
                    this.pCompileViewDirCode();

                this.pCompileLightingCode();
                this._fragmentLightCode = this._pFragmentCode;
                this._pFragmentCode = "";
                this.pCompileMethods();
            };

            /**
            * Compile the lighting code.
            */
            ShaderCompiler.prototype.pCompileLightingCode = function () {
            };

            /**
            * Calculate the view direction.
            */
            ShaderCompiler.prototype.pCompileViewDirCode = function () {
            };

            /**
            * Calculate the normal.
            */
            ShaderCompiler.prototype.pCompileNormalCode = function () {
            };

            /**
            * Calculate the (possibly animated) UV coordinates.
            */
            ShaderCompiler.prototype.compileUVCode = function () {
                var uvAttributeReg = this._pRegisterCache.getFreeVertexAttribute();
                this._uvBufferIndex = uvAttributeReg.index;

                var varying = this._pRegisterCache.getFreeVarying();

                this._pSharedRegisters.uvVarying = varying;

                if (this.animateUVs) {
                    // a, b, 0, tx
                    // c, d, 0, ty
                    var uvTransform1 = this._pRegisterCache.getFreeVertexConstant();
                    var uvTransform2 = this._pRegisterCache.getFreeVertexConstant();
                    this._uvTransformIndex = uvTransform1.index * 4;

                    // TODO: AGAL <> GLSL
                    this._pVertexCode += "dp4 " + varying + ".x, " + uvAttributeReg + ", " + uvTransform1 + "\n" + "dp4 " + varying + ".y, " + uvAttributeReg + ", " + uvTransform2 + "\n" + "mov " + varying + ".zw, " + uvAttributeReg + ".zw \n";
                } else {
                    this._uvTransformIndex = -1;
                    this._needUVAnimation = true;
                    this._UVTarget = varying.toString();
                    this._UVSource = uvAttributeReg.toString();
                }
            };

            /**
            * Provide the secondary UV coordinates.
            */
            ShaderCompiler.prototype.compileSecondaryUVCode = function () {
                // TODO: AGAL <> GLSL
                var uvAttributeReg = this._pRegisterCache.getFreeVertexAttribute();
                this._secondaryUVBufferIndex = uvAttributeReg.index;
                this._pSharedRegisters.secondaryUVVarying = this._pRegisterCache.getFreeVarying();
                this._pVertexCode += "mov " + this._pSharedRegisters.secondaryUVVarying + ", " + uvAttributeReg + "\n";
            };

            /**
            * Compile the world-space position.
            */
            ShaderCompiler.prototype.pCompileGlobalPositionCode = function () {
                // TODO: AGAL <> GLSL
                this._pSharedRegisters.globalPositionVertex = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.globalPositionVertex, this._pDependencyCounter.globalPosDependencies);
                var positionMatrixReg = this._pRegisterCache.getFreeVertexConstant();
                this._pRegisterCache.getFreeVertexConstant();
                this._pRegisterCache.getFreeVertexConstant();
                this._pRegisterCache.getFreeVertexConstant();
                this._sceneMatrixIndex = positionMatrixReg.index * 4;

                this._pVertexCode += "m44 " + this._pSharedRegisters.globalPositionVertex + ", " + this._pSharedRegisters.localPosition + ", " + positionMatrixReg + "\n";

                if (this._pDependencyCounter.usesGlobalPosFragment) {
                    this._pSharedRegisters.globalPositionVarying = this._pRegisterCache.getFreeVarying();
                    this._pVertexCode += "mov " + this._pSharedRegisters.globalPositionVarying + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
                }
            };

            /**
            * Get the projection coordinates.
            */
            ShaderCompiler.prototype.compileProjectionCode = function () {
                var pos = (this._pDependencyCounter.globalPosDependencies > 0 || this._forceSeperateMVP) ? this._pSharedRegisters.globalPositionVertex.toString() : this._pAnimationTargetRegisters[0];
                var code;

                if (this._pDependencyCounter.projectionDependencies > 0) {
                    this._pSharedRegisters.projectionFragment = this._pRegisterCache.getFreeVarying();

                    code = "m44 vt5, " + pos + ", vc0		\n" + "mov " + this._pSharedRegisters.projectionFragment + ", vt5\n" + "mov op, vt5\n";
                } else {
                    code = "m44 op, " + pos + ", vc0		\n";
                }

                this._pVertexCode += code;
            };

            /**
            * Assign the final output colour the the output register.
            */
            ShaderCompiler.prototype.compileFragmentOutput = function () {
                // TODO: AGAL <> GLSL
                this._pFragmentCode += "mov " + this._pRegisterCache.fragmentOutputRegister + ", " + this._pSharedRegisters.shadedTarget + "\n";
                this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.shadedTarget);
            };

            /**
            * Reset all the indices to "unused".
            */
            ShaderCompiler.prototype.pInitRegisterIndices = function () {
                this._commonsDataIndex = -1;
                this._pCameraPositionIndex = -1;
                this._uvBufferIndex = -1;
                this._uvTransformIndex = -1;
                this._secondaryUVBufferIndex = -1;
                this._pNormalBufferIndex = -1;
                this._pTangentBufferIndex = -1;
                this._pLightFragmentConstantIndex = -1;
                this._sceneMatrixIndex = -1;
                this._pSceneNormalMatrixIndex = -1;
                this._pProbeWeightsIndex = -1;
            };

            /**
            * Prepares the setup for the light code.
            */
            ShaderCompiler.prototype.pInitLightData = function () {
                this._pNumLights = this._pNumPointLights + this._pNumDirectionalLights;
                this._pNumProbeRegisters = Math.ceil(this._pNumLightProbes / 4);

                if (this._pMethodSetup._iSpecularMethod) {
                    this._combinedLightSources = this._specularLightSources | this._diffuseLightSources;
                } else {
                    this._combinedLightSources = this._diffuseLightSources;
                }

                this._usingSpecularMethod = Boolean(this._pMethodSetup._iSpecularMethod && (this.pUsesLightsForSpecular() || this.pUsesProbesForSpecular()));
            };

            /**
            * Create the commonly shared constant register.
            */
            ShaderCompiler.prototype.createCommons = function () {
                this._pSharedRegisters.commons = this._pRegisterCache.getFreeFragmentConstant();
                this._commonsDataIndex = this._pSharedRegisters.commons.index * 4;
            };

            /**
            * Figure out which named registers are required, and how often.
            */
            ShaderCompiler.prototype.pCalculateDependencies = function () {
                this._pDependencyCounter.reset();

                var methods = this._pMethodSetup._iMethods;
                var len;

                this.setupAndCountMethodDependencies(this._pMethodSetup._iDiffuseMethod, this._pMethodSetup._iDiffuseMethodVO);

                if (this._pMethodSetup._iShadowMethod)
                    this.setupAndCountMethodDependencies(this._pMethodSetup._iShadowMethod, this._pMethodSetup._iShadowMethodVO);

                this.setupAndCountMethodDependencies(this._pMethodSetup._iAmbientMethod, this._pMethodSetup._iAmbientMethodVO);

                if (this._usingSpecularMethod)
                    this.setupAndCountMethodDependencies(this._pMethodSetup._iSpecularMethod, this._pMethodSetup._iSpecularMethodVO);

                if (this._pMethodSetup._iColorTransformMethod)
                    this.setupAndCountMethodDependencies(this._pMethodSetup._iColorTransformMethod, this._pMethodSetup._iColorTransformMethodVO);

                len = methods.length;

                for (var i = 0; i < len; ++i)
                    this.setupAndCountMethodDependencies(methods[i].method, methods[i].data);

                if (this.usesNormals)
                    this.setupAndCountMethodDependencies(this._pMethodSetup._iNormalMethod, this._pMethodSetup._iNormalMethodVO);

                // todo: add spotlights to count check
                this._pDependencyCounter.setPositionedLights(this._pNumPointLights, this._combinedLightSources);
            };

            /**
            * Counts the dependencies for a given method.
            * @param method The method to count the dependencies for.
            * @param methodVO The method's data for this material.
            */
            ShaderCompiler.prototype.setupAndCountMethodDependencies = function (method, methodVO) {
                this.setupMethod(method, methodVO);
                this._pDependencyCounter.includeMethodVO(methodVO);
            };

            /**
            * Assigns all prerequisite data for the methods, so we can calculate dependencies for them.
            */
            ShaderCompiler.prototype.setupMethod = function (method, methodVO) {
                method.iReset();
                methodVO.reset();

                methodVO.vertexData = this._vertexConstantData;
                methodVO.fragmentData = this._fragmentConstantData;
                methodVO.useSmoothTextures = this._smooth;
                methodVO.repeatTextures = this._repeat;
                methodVO.useMipmapping = this._mipmap;
                methodVO.useLightFallOff = this._pEnableLightFallOff && this._pProfile != "baselineConstrained";
                methodVO.numLights = this._pNumLights + this._pNumLightProbes;

                method.iInitVO(methodVO);
            };

            Object.defineProperty(ShaderCompiler.prototype, "commonsDataIndex", {
                get: /**
                * The index for the common data register.
                */
                function () {
                    return this._commonsDataIndex;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Assigns the shared register data to all methods.
            */
            ShaderCompiler.prototype.updateMethodRegisters = function () {
                this._pMethodSetup._iNormalMethod.iSharedRegisters = this._pSharedRegisters;
                this._pMethodSetup._iDiffuseMethod.iSharedRegisters = this._pSharedRegisters;

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iSharedRegisters = this._pSharedRegisters;

                this._pMethodSetup._iAmbientMethod.iSharedRegisters = this._pSharedRegisters;

                if (this._pMethodSetup._iSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iSharedRegisters = this._pSharedRegisters;

                if (this._pMethodSetup._iColorTransformMethod)
                    this._pMethodSetup._iColorTransformMethod.iSharedRegisters = this._pSharedRegisters;

                var methods = this._pMethodSetup._iMethods;

                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    methods[i].method.iSharedRegisters = this._pSharedRegisters;
                }
            };

            Object.defineProperty(ShaderCompiler.prototype, "numUsedVertexConstants", {
                get: /**
                * The amount of vertex constants used by the material. Any animation code to be added can append its vertex
                * constant data after this.
                */
                function () {
                    return this._pRegisterCache.numUsedVertexConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numUsedFragmentConstants", {
                get: /**
                * The amount of fragment constants used by the material. Any animation code to be added can append its vertex
                * constant data after this.
                */
                function () {
                    return this._pRegisterCache.numUsedFragmentConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numUsedStreams", {
                get: /**
                * The amount of vertex attribute streams used by the material. Any animation code to be added can add its
                * streams after this. Also used to automatically disable attribute slots on pass deactivation.
                */
                function () {
                    return this._pRegisterCache.numUsedStreams;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numUsedTextures", {
                get: /**
                * The amount of textures used by the material. Used to automatically disable texture slots on pass deactivation.
                */
                function () {
                    return this._pRegisterCache.numUsedTextures;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numUsedVaryings", {
                get: /**
                * Number of used varyings. Any animation code to be added can add its used varyings after this.
                */
                function () {
                    return this._pRegisterCache.numUsedVaryings;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Indicates whether lights are used for specular reflections.
            */
            ShaderCompiler.prototype.pUsesLightsForSpecular = function () {
                return this._pNumLights > 0 && (this._specularLightSources & materials.LightSources.LIGHTS) != 0;
            };

            /**
            * Indicates whether lights are used for diffuse reflections.
            */
            ShaderCompiler.prototype.pUsesLightsForDiffuse = function () {
                return this._pNumLights > 0 && (this._diffuseLightSources & materials.LightSources.LIGHTS) != 0;
            };

            /**
            * Disposes all resources used by the compiler.
            */
            ShaderCompiler.prototype.dispose = function () {
                this.cleanUpMethods();
                this._pRegisterCache.dispose();
                this._pRegisterCache = null;
                this._pSharedRegisters = null;
            };

            /**
            * Clean up method's compilation data after compilation finished.
            */
            ShaderCompiler.prototype.cleanUpMethods = function () {
                if (this._pMethodSetup._iNormalMethod)
                    this._pMethodSetup._iNormalMethod.iCleanCompilationData();

                if (this._pMethodSetup._iDiffuseMethod)
                    this._pMethodSetup._iDiffuseMethod.iCleanCompilationData();

                if (this._pMethodSetup._iAmbientMethod)
                    this._pMethodSetup._iAmbientMethod.iCleanCompilationData();

                if (this._pMethodSetup._iSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iCleanCompilationData();

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iCleanCompilationData();

                if (this._pMethodSetup._iColorTransformMethod)
                    this._pMethodSetup._iColorTransformMethod.iCleanCompilationData();

                var methods = this._pMethodSetup._iMethods;

                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    methods[i].method.iCleanCompilationData();
                }
            };

            Object.defineProperty(ShaderCompiler.prototype, "specularLightSources", {
                get: /**
                * Define which light source types to use for specular reflections. This allows choosing between regular lights
                * and/or light probes for specular reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._specularLightSources;
                },
                set: function (value) {
                    this._specularLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "diffuseLightSources", {
                get: /**
                * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
                * and/or light probes for diffuse reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._diffuseLightSources;
                },
                set: function (value) {
                    this._diffuseLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Indicates whether light probes are being used for specular reflections.
            */
            ShaderCompiler.prototype.pUsesProbesForSpecular = function () {
                return this._pNumLightProbes > 0 && (this._specularLightSources & materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether light probes are being used for diffuse reflections.
            */
            ShaderCompiler.prototype.pUsesProbesForDiffuse = function () {
                return this._pNumLightProbes > 0 && (this._diffuseLightSources & materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether any light probes are used.
            */
            ShaderCompiler.prototype.pUsesProbes = function () {
                return this._pNumLightProbes > 0 && ((this._diffuseLightSources | this._specularLightSources) & materials.LightSources.PROBES) != 0;
            };

            Object.defineProperty(ShaderCompiler.prototype, "uvBufferIndex", {
                get: /**
                * The index for the UV vertex attribute stream.
                */
                function () {
                    return this._uvBufferIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "uvTransformIndex", {
                get: /**
                * The index for the UV transformation matrix vertex constant.
                */
                function () {
                    return this._uvTransformIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "secondaryUVBufferIndex", {
                get: /**
                * The index for the secondary UV vertex attribute stream.
                */
                function () {
                    return this._secondaryUVBufferIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "normalBufferIndex", {
                get: /**
                * The index for the vertex normal attribute stream.
                */
                function () {
                    return this._pNormalBufferIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "tangentBufferIndex", {
                get: /**
                * The index for the vertex tangent attribute stream.
                */
                function () {
                    return this._pTangentBufferIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "lightFragmentConstantIndex", {
                get: /**
                * The first index for the fragment constants containing the light data.
                */
                function () {
                    return this._pLightFragmentConstantIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "cameraPositionIndex", {
                get: /**
                * The index of the vertex constant containing the camera position.
                */
                function () {
                    return this._pCameraPositionIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "sceneMatrixIndex", {
                get: /**
                * The index of the vertex constant containing the scene matrix.
                */
                function () {
                    return this._sceneMatrixIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "sceneNormalMatrixIndex", {
                get: /**
                * The index of the vertex constant containing the uniform scene matrix (the inverse transpose).
                */
                function () {
                    return this._pSceneNormalMatrixIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "probeWeightsIndex", {
                get: /**
                * The index of the fragment constant containing the weights for the light probes.
                */
                function () {
                    return this._pProbeWeightsIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "vertexCode", {
                get: /**
                * The generated vertex code.
                */
                function () {
                    return this._pVertexCode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "fragmentCode", {
                get: /**
                * The generated fragment code.
                */
                function () {
                    return this._pFragmentCode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "fragmentLightCode", {
                get: /**
                * The code containing the lighting calculations.
                */
                function () {
                    return this._fragmentLightCode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "fragmentPostLightCode", {
                get: /**
                * The code containing the post-lighting calculations.
                */
                function () {
                    return this._fragmentPostLightCode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "shadedTarget", {
                get: /**
                * The register name containing the final shaded colour.
                */
                function () {
                    return this._pSharedRegisters.shadedTarget.toString();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numPointLights", {
                get: /**
                * The amount of point lights that need to be supported.
                */
                function () {
                    return this._pNumPointLights;
                },
                set: function (numPointLights) {
                    this._pNumPointLights = numPointLights;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "numDirectionalLights", {
                get: /**
                * The amount of directional lights that need to be supported.
                */
                function () {
                    return this._pNumDirectionalLights;
                },
                set: function (value) {
                    this._pNumDirectionalLights = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "numLightProbes", {
                get: /**
                * The amount of light probes that need to be supported.
                */
                function () {
                    return this._pNumLightProbes;
                },
                set: function (value) {
                    this._pNumLightProbes = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "usingSpecularMethod", {
                get: /**
                * Indicates whether the specular method is used.
                */
                function () {
                    return this._usingSpecularMethod;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "animatableAttributes", {
                get: /**
                * The attributes that need to be animated by animators.
                */
                function () {
                    return this._pAnimatableAttributes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "animationTargetRegisters", {
                get: /**
                * The target registers for animated properties, written to by the animators.
                */
                function () {
                    return this._pAnimationTargetRegisters;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "usesNormals", {
                get: /**
                * Indicates whether the compiled shader uses normals.
                */
                function () {
                    return this._pDependencyCounter.normalDependencies > 0 && this._pMethodSetup._iNormalMethod.iHasOutput;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Indicates whether the compiled shader uses lights.
            */
            ShaderCompiler.prototype.pUsesLights = function () {
                return this._pNumLights > 0 && (this._combinedLightSources & materials.LightSources.LIGHTS) != 0;
            };

            /**
            * Compiles the code for the methods.
            */
            ShaderCompiler.prototype.pCompileMethods = function () {
                var methods = this._pMethodSetup._iMethods;

                var numMethods = methods.length;
                var method;
                var data;
                var alphaReg;

                if (this._preserveAlpha) {
                    alphaReg = this._pRegisterCache.getFreeFragmentSingleTemp();
                    this._pRegisterCache.addFragmentTempUsages(alphaReg, 1);
                    this._pFragmentCode += "mov " + alphaReg + ", " + this._pSharedRegisters.shadedTarget + ".w\n";
                }

                for (var i = 0; i < numMethods; ++i) {
                    method = methods[i].method;
                    data = methods[i].data;

                    this._pVertexCode += method.iGetVertexCode(data, this._pRegisterCache);

                    if (data.needsGlobalVertexPos || data.needsGlobalFragmentPos)
                        this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);

                    this._pFragmentCode += method.iGetFragmentCode(data, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                    if (data.needsNormals)
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);

                    if (data.needsView)
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._preserveAlpha) {
                    this._pFragmentCode += "mov " + this._pSharedRegisters.shadedTarget + ".w, " + alphaReg + "\n";

                    this._pRegisterCache.removeFragmentTempUsage(alphaReg);
                }

                if (this._pMethodSetup._iColorTransformMethod) {
                    this._pVertexCode += this._pMethodSetup._iColorTransformMethod.iGetVertexCode(this._pMethodSetup._iColorTransformMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iColorTransformMethod.iGetFragmentCode(this._pMethodSetup._iColorTransformMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);
                }
            };

            Object.defineProperty(ShaderCompiler.prototype, "lightProbeDiffuseIndices", {
                get: /**
                * Indices for the light probe diffuse textures.
                */
                function () {
                    return this._pLightProbeDiffuseIndices;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "lightProbeSpecularIndices", {
                get: /**
                * Indices for the light probe specular textures.
                */
                function () {
                    return this._pLightProbeSpecularIndices;
                },
                enumerable: true,
                configurable: true
            });
            return ShaderCompiler;
        })();
        materials.ShaderCompiler = ShaderCompiler;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        /**
        * SuperShaderCompiler is a compiler that generates shaders that perform both lighting and "effects" through methods.
        * This is used by the single-pass materials.
        */
        var SuperShaderCompiler = (function (_super) {
            __extends(SuperShaderCompiler, _super);
            /**
            * Creates a new SuperShaderCompiler object.
            * @param profile The compatibility profile used by the renderer.
            */
            function SuperShaderCompiler(profile) {
                _super.call(this, profile);
            }
            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pInitLightData = function () {
                _super.prototype.pInitLightData.call(this);

                this._pointLightRegisters = new Array(this._pNumPointLights * 3);
                this._dirLightRegisters = new Array(this._pNumDirectionalLights * 3);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCalculateDependencies = function () {
                _super.prototype.pCalculateDependencies.call(this);
                this._pDependencyCounter.addWorldSpaceDependencies(true);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCompileNormalCode = function () {
                var normalMatrix = new Array(3);

                this._pSharedRegisters.normalFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.normalFragment, this._pDependencyCounter.normalDependencies);

                if (this._pMethodSetup._iNormalMethod.iHasOutput && !this._pMethodSetup._iNormalMethod.iTangentSpace) {
                    this._pVertexCode += this._pMethodSetup._iNormalMethod.iGetVertexCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iNormalMethod.iGetFragmentCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache, this._pSharedRegisters.normalFragment);

                    return;
                }

                this._pSharedRegisters.normalVarying = this._pRegisterCache.getFreeVarying();

                normalMatrix[0] = this._pRegisterCache.getFreeVertexConstant();
                normalMatrix[1] = this._pRegisterCache.getFreeVertexConstant();
                normalMatrix[2] = this._pRegisterCache.getFreeVertexConstant();

                this._pRegisterCache.getFreeVertexConstant();
                this._pSceneNormalMatrixIndex = normalMatrix[0].index * 4;

                if (this._pMethodSetup._iNormalMethod.iHasOutput) {
                    // tangent stream required
                    this.compileTangentVertexCode(normalMatrix);
                    this.compileTangentNormalMapFragmentCode();
                } else {
                    // TODO: AGAL <> GLSL
                    //*
                    this._pVertexCode += "m33 " + this._pSharedRegisters.normalVarying + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" + "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.animatedNormal + ".w	\n";

                    this._pFragmentCode += "nrm " + this._pSharedRegisters.normalFragment + ".xyz, " + this._pSharedRegisters.normalVarying + "\n" + "mov " + this._pSharedRegisters.normalFragment + ".w, " + this._pSharedRegisters.normalVarying + ".w		\n";

                    if (this._pDependencyCounter.tangentDependencies > 0) {
                        this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
                        this._pTangentBufferIndex = this._pSharedRegisters.tangentInput.index;
                        this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();

                        this._pVertexCode += "mov " + this._pSharedRegisters.tangentVarying + ", " + this._pSharedRegisters.tangentInput + "\n";
                    }
                    //*/
                }

                this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.animatedNormal);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCreateNormalRegisters = function () {
                if (this._pDependencyCounter.normalDependencies > 0) {
                    this._pSharedRegisters.normalInput = this._pRegisterCache.getFreeVertexAttribute();
                    this._pNormalBufferIndex = this._pSharedRegisters.normalInput.index;
                    this._pSharedRegisters.animatedNormal = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedNormal, 1);
                    this._pAnimatableAttributes.push(this._pSharedRegisters.normalInput.toString());
                    this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedNormal.toString());
                }

                if (this._pMethodSetup._iNormalMethod.iHasOutput) {
                    this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
                    this._pTangentBufferIndex = this._pSharedRegisters.tangentInput.index;

                    this._pSharedRegisters.animatedTangent = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedTangent, 1);

                    this._pAnimatableAttributes.push(this._pSharedRegisters.tangentInput.toString());
                    this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedTangent.toString());
                }
            };

            /**
            * Compiles the vertex shader code for tangent-space normal maps.
            * @param matrix The register containing the scene transformation matrix for normals.
            */
            SuperShaderCompiler.prototype.compileTangentVertexCode = function (matrix) {
                this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();
                this._pSharedRegisters.bitangentVarying = this._pRegisterCache.getFreeVarying();
                var temp = this._pRegisterCache.getFreeVertexVectorTemp();

                //TODO: AGAL <> GLSL
                this._pVertexCode += "m33 " + temp + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + matrix[0] + "\n" + "nrm " + this._pSharedRegisters.animatedNormal + ".xyz, " + temp + "\n";

                this._pVertexCode += "m33 " + temp + ".xyz, " + this._pSharedRegisters.animatedTangent + ", " + matrix[0] + "\n" + "nrm " + this._pSharedRegisters.animatedTangent + ".xyz, " + temp + "\n";

                this._pVertexCode += "mov " + this._pSharedRegisters.tangentVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".x  \n" + "mov " + this._pSharedRegisters.tangentVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".x  \n" + "mov " + this._pSharedRegisters.tangentVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" + "mov " + this._pSharedRegisters.bitangentVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".y  \n" + "mov " + this._pSharedRegisters.bitangentVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".y  \n" + "mov " + this._pSharedRegisters.bitangentVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" + "mov " + this._pSharedRegisters.normalVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".z  \n" + "mov " + this._pSharedRegisters.normalVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".z  \n" + "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" + "crs " + temp + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + this._pSharedRegisters.tangentVarying + ".y, " + temp + ".x    \n" + "mov " + this._pSharedRegisters.bitangentVarying + ".y, " + temp + ".y  \n" + "mov " + this._pSharedRegisters.normalVarying + ".y, " + temp + ".z    \n";

                this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.animatedTangent);
            };

            /**
            * Compiles the fragment shader code for tangent-space normal maps.
            */
            SuperShaderCompiler.prototype.compileTangentNormalMapFragmentCode = function () {
                var t;
                var b;
                var n;

                t = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(t, 1);
                b = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(b, 1);
                n = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(n, 1);

                //TODO: AGAL <> GLSL
                this._pFragmentCode += "nrm " + t + ".xyz, " + this._pSharedRegisters.tangentVarying + "\n" + "mov " + t + ".w, " + this._pSharedRegisters.tangentVarying + ".w	\n" + "nrm " + b + ".xyz, " + this._pSharedRegisters.bitangentVarying + "\n" + "nrm " + n + ".xyz, " + this._pSharedRegisters.normalVarying + "\n";

                var temp = this._pRegisterCache.getFreeFragmentVectorTemp();

                this._pRegisterCache.addFragmentTempUsages(temp, 1);

                //TODO: AGAL <> GLSL
                this._pFragmentCode += this._pMethodSetup._iNormalMethod.iGetFragmentCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache, temp) + "m33 " + this._pSharedRegisters.normalFragment + ".xyz, " + temp + ", " + t + "	\n" + "mov " + this._pSharedRegisters.normalFragment + ".w,   " + this._pSharedRegisters.normalVarying + ".w			\n";

                this._pRegisterCache.removeFragmentTempUsage(temp);

                if (this._pMethodSetup._iNormalMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._pMethodSetup._iNormalMethodVO.needsGlobalVertexPos || this._pMethodSetup._iNormalMethodVO.needsGlobalFragmentPos) {
                    this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
                }

                this._pRegisterCache.removeFragmentTempUsage(b);
                this._pRegisterCache.removeFragmentTempUsage(t);
                this._pRegisterCache.removeFragmentTempUsage(n);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCompileViewDirCode = function () {
                var cameraPositionReg = this._pRegisterCache.getFreeVertexConstant();

                this._pSharedRegisters.viewDirVarying = this._pRegisterCache.getFreeVarying();
                this._pSharedRegisters.viewDirFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.viewDirFragment, this._pDependencyCounter.viewDirDependencies);

                this._pCameraPositionIndex = cameraPositionReg.index * 4;

                //TODO: AGAL <> GLSL
                this._pVertexCode += "sub " + this._pSharedRegisters.viewDirVarying + ", " + cameraPositionReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
                this._pFragmentCode += "nrm " + this._pSharedRegisters.viewDirFragment + ".xyz, " + this._pSharedRegisters.viewDirVarying + "\n" + "mov " + this._pSharedRegisters.viewDirFragment + ".w,   " + this._pSharedRegisters.viewDirVarying + ".w 		\n";

                this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCompileLightingCode = function () {
                var shadowReg;

                this._pSharedRegisters.shadedTarget = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.shadedTarget, 1);

                this._pVertexCode += this._pMethodSetup._iDiffuseMethod.iGetVertexCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentPreLightingCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache);

                if (this._usingSpecularMethod) {
                    this._pVertexCode += this._pMethodSetup._iSpecularMethod.iGetVertexCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentPreLightingCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache);
                }

                if (this.pUsesLights()) {
                    this.initLightRegisters();
                    this.compileDirectionalLightCode();
                    this.compilePointLightCode();
                }

                if (this.pUsesProbes()) {
                    this.compileLightProbeCode();
                }

                // only need to create and reserve _shadedTargetReg here, no earlier?
                this._pVertexCode += this._pMethodSetup._iAmbientMethod.iGetVertexCode(this._pMethodSetup._iAmbientMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iAmbientMethod.iGetFragmentCode(this._pMethodSetup._iAmbientMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                if (this._pMethodSetup._iAmbientMethodVO.needsNormals) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                }

                if (this._pMethodSetup._iAmbientMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._pMethodSetup._iShadowMethod) {
                    this._pVertexCode += this._pMethodSetup._iShadowMethod.iGetVertexCode(this._pMethodSetup._iShadowMethodVO, this._pRegisterCache);

                    if (this._pDependencyCounter.normalDependencies == 0) {
                        shadowReg = this._pRegisterCache.getFreeFragmentVectorTemp();
                        this._pRegisterCache.addFragmentTempUsages(shadowReg, 1);
                    } else {
                        shadowReg = this._pSharedRegisters.normalFragment;
                    }

                    this._pMethodSetup._iDiffuseMethod.iShadowRegister = shadowReg;
                    this._pFragmentCode += this._pMethodSetup._iShadowMethod.iGetFragmentCode(this._pMethodSetup._iShadowMethodVO, this._pRegisterCache, shadowReg);
                }

                this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentPostLightingCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                if (this._pAlphaPremultiplied) {
                    //TODO: AGAL <> GLSL
                    this._pFragmentCode += "add " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.commons + ".z\n" + "div " + this._pSharedRegisters.shadedTarget + ".xyz, " + this._pSharedRegisters.shadedTarget + ", " + this._pSharedRegisters.shadedTarget + ".w\n" + "sub " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.commons + ".z\n" + "sat " + this._pSharedRegisters.shadedTarget + ".xyz, " + this._pSharedRegisters.shadedTarget + "\n";
                }

                if (this._pMethodSetup._iDiffuseMethodVO.needsNormals) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                }

                if (this._pMethodSetup._iDiffuseMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._usingSpecularMethod) {
                    this._pMethodSetup._iSpecularMethod.iShadowRegister = shadowReg;
                    this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentPostLightingCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                    if (this._pMethodSetup._iSpecularMethodVO.needsNormals) {
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                    }

                    if (this._pMethodSetup._iSpecularMethodVO.needsView) {
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                    }
                }
            };

            /**
            * Initializes the registers containing the lighting data.
            */
            SuperShaderCompiler.prototype.initLightRegisters = function () {
                // init these first so we're sure they're in sequence
                var i, len;

                len = this._dirLightRegisters.length;

                for (i = 0; i < len; ++i) {
                    this._dirLightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = this._dirLightRegisters[i].index * 4;
                    }
                }

                len = this._pointLightRegisters.length;

                for (i = 0; i < len; ++i) {
                    this._pointLightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = this._pointLightRegisters[i].index * 4;
                    }
                }
            };

            SuperShaderCompiler.prototype.compileDirectionalLightCode = function () {
                var diffuseColorReg;
                var specularColorReg;
                var lightDirReg;
                var regIndex = 0;
                var addSpec = this._usingSpecularMethod && this.pUsesLightsForSpecular();
                var addDiff = this.pUsesLightsForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                for (var i = 0; i < this._pNumDirectionalLights; ++i) {
                    lightDirReg = this._dirLightRegisters[regIndex++];

                    diffuseColorReg = this._dirLightRegisters[regIndex++];

                    specularColorReg = this._dirLightRegisters[regIndex++];

                    if (addDiff) {
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerLight(this._pMethodSetup._iDiffuseMethodVO, lightDirReg, diffuseColorReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerLight(this._pMethodSetup._iSpecularMethodVO, lightDirReg, specularColorReg, this._pRegisterCache);
                    }
                }
            };

            SuperShaderCompiler.prototype.compilePointLightCode = function () {
                var diffuseColorReg;
                var specularColorReg;
                var lightPosReg;
                var lightDirReg;
                var regIndex = 0;
                var addSpec = this._usingSpecularMethod && this.pUsesLightsForSpecular();

                var addDiff = this.pUsesLightsForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                for (var i = 0; i < this._pNumPointLights; ++i) {
                    lightPosReg = this._pointLightRegisters[regIndex++];
                    diffuseColorReg = this._pointLightRegisters[regIndex++];
                    specularColorReg = this._pointLightRegisters[regIndex++];
                    lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();
                    this._pRegisterCache.addFragmentTempUsages(lightDirReg, 1);

                    // calculate attenuation
                    this._pFragmentCode += "sub " + lightDirReg + ", " + lightPosReg + ", " + this._pSharedRegisters.globalPositionVarying + "\n" + "dp3 " + lightDirReg + ".w, " + lightDirReg + ", " + lightDirReg + "\n" + "sub " + lightDirReg + ".w, " + lightDirReg + ".w, " + diffuseColorReg + ".w\n" + "mul " + lightDirReg + ".w, " + lightDirReg + ".w, " + specularColorReg + ".w\n" + "sat " + lightDirReg + ".w, " + lightDirReg + ".w\n" + "sub " + lightDirReg + ".w, " + lightPosReg + ".w, " + lightDirReg + ".w\n" + "nrm " + lightDirReg + ".xyz, " + lightDirReg + "\n";

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = lightPosReg.index * 4;
                    }

                    if (addDiff) {
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerLight(this._pMethodSetup._iDiffuseMethodVO, lightDirReg, diffuseColorReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerLight(this._pMethodSetup._iSpecularMethodVO, lightDirReg, specularColorReg, this._pRegisterCache);
                    }

                    this._pRegisterCache.removeFragmentTempUsage(lightDirReg);
                }
            };

            SuperShaderCompiler.prototype.compileLightProbeCode = function () {
                var weightReg;
                var weightComponents = [".x", ".y", ".z", ".w"];
                var weightRegisters = new Array();
                var i;
                var texReg;
                var addSpec = this._usingSpecularMethod && this.pUsesProbesForSpecular();
                var addDiff = this.pUsesProbesForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                if (addDiff) {
                    this._pLightProbeDiffuseIndices = new Array();
                }

                if (addSpec) {
                    this._pLightProbeSpecularIndices = new Array();
                }

                for (i = 0; i < this._pNumProbeRegisters; ++i) {
                    weightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();
                    if (i == 0) {
                        this._pProbeWeightsIndex = weightRegisters[i].index * 4;
                    }
                }

                for (i = 0; i < this._pNumLightProbes; ++i) {
                    weightReg = weightRegisters[Math.floor(i / 4)].toString() + weightComponents[i % 4];

                    if (addDiff) {
                        texReg = this._pRegisterCache.getFreeTextureReg();
                        this._pLightProbeDiffuseIndices[i] = texReg.index;
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerProbe(this._pMethodSetup._iDiffuseMethodVO, texReg, weightReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        texReg = this._pRegisterCache.getFreeTextureReg();
                        this._pLightProbeSpecularIndices[i] = texReg.index;
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerProbe(this._pMethodSetup._iSpecularMethodVO, texReg, weightReg, this._pRegisterCache);
                    }
                }
            };
            return SuperShaderCompiler;
        })(materials.ShaderCompiler);
        materials.SuperShaderCompiler = SuperShaderCompiler;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    (function (materials) {
        /**
        * Enumeration class for defining which lighting types affect the specific material
        * lighting component (diffuse and specular). This can be useful if, for example, you
        * want to use light probes for diffuse global lighting, but want specular reflections from
        * traditional light sources without those affecting the diffuse light.
        *
        * @see away3d.materials.ColorMaterial.diffuseLightSources
        * @see away3d.materials.ColorMaterial.specularLightSources
        * @see away3d.materials.TextureMaterial.diffuseLightSources
        * @see away3d.materials.TextureMaterial.specularLightSources
        */
        var LightSources = (function () {
            function LightSources() {
            }
            LightSources.LIGHTS = 0x01;

            LightSources.PROBES = 0x02;

            LightSources.ALL = 0x03;
            return LightSources;
        })();
        materials.LightSources = LightSources;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        var BlendMode = away.base.BlendMode;
        var ContextGL = away.gl.ContextGL;
        var ContextGLCompareMode = away.gl.ContextGLCompareMode;
        var Event = away.events.Event;
        var Matrix3D = away.geom.Matrix3D;
        var AssetType = away.library.AssetType;
        var Delegate = away.utils.Delegate;

        
        
        var Camera = away.entities.Camera;
        var StageGL = away.base.StageGL;
        var DepthMapPass = away.materials.DepthMapPass;
        var DistanceMapPass = away.materials.DistanceMapPass;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var RenderableBase = away.pool.RenderableBase;
        

        /**
        * MaterialBase forms an abstract base class for any material.
        * A material consists of several passes, each of which constitutes at least one render call. Several passes could
        * be used for special effects (render lighting for many lights in several passes, render an outline in a separate
        * pass) or to provide additional render-to-texture passes (rendering diffuse light to texture for texture-space
        * subsurface scattering, or rendering a depth map for specialized self-shadowing).
        *
        * Away3D provides default materials trough SinglePassMaterialBase and MultiPassMaterialBase, which use modular
        * methods to build the shader code. MaterialBase can be extended to build specific and high-performant custom
        * shaders, or entire new material frameworks.
        */
        var MaterialBase = (function (_super) {
            __extends(MaterialBase, _super);
            /**
            * Creates a new MaterialBase object.
            */
            function MaterialBase() {
                _super.call(this);
                /**
                * An id for this material used to sort the renderables by shader program, which reduces Program state changes.
                *
                * @private
                */
                this._iMaterialId = 0;
                /**
                * An id for this material used to sort the renderables by shader program, which reduces Program state changes.
                *
                * @private
                */
                this._iRenderOrderId = 0;
                this._bothSides = false;
                this._pBlendMode = BlendMode.NORMAL;
                this._numPasses = 0;
                this._pMipmap = true;
                this._smooth = true;
                this._repeat = false;
                this._pDepthCompareMode = ContextGLCompareMode.LESS_EQUAL;

                this._iMaterialId = Number(this.id);

                this._owners = new Array();
                this._passes = new Array();
                this._pDepthPass = new DepthMapPass();
                this._pDistancePass = new DistanceMapPass();

                this._onPassChangeDelegate = Delegate.create(this, this.onPassChange);
                this._onDepthPassChangeDelegate = Delegate.create(this, this.onDepthPassChange);
                this._onDistancePassChangeDelegate = Delegate.create(this, this.onDistancePassChange);

                this._pDepthPass.addEventListener(Event.CHANGE, this._onDepthPassChangeDelegate);
                this._pDistancePass.addEventListener(Event.CHANGE, this._onDistancePassChangeDelegate);

                this.alphaPremultiplied = false;
            }
            Object.defineProperty(MaterialBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return AssetType.MATERIAL;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialBase.prototype, "lightPicker", {
                get: /**
                * The light picker used by the material to provide lights to the material if it supports lighting.
                *
                * @see LightPickerBase
                * @see StaticLightPicker
                */
                function () {
                    return this._pLightPicker;
                },
                set: function (value) {
                    this.setLightPicker(value);
                },
                enumerable: true,
                configurable: true
            });


            MaterialBase.prototype.setLightPicker = function (value) {
                if (value != this._pLightPicker) {
                    this._pLightPicker = value;
                    var len = this._passes.length;

                    for (var i = 0; i < len; ++i)
                        this._passes[i].lightPicker = this._pLightPicker;
                }
            };

            Object.defineProperty(MaterialBase.prototype, "mipmap", {
                get: /**
                * Indicates whether or not any used textures should use mipmapping. Defaults to true.
                */
                function () {
                    return this._pMipmap;
                },
                set: function (value) {
                    this.setMipMap(value);
                },
                enumerable: true,
                configurable: true
            });


            MaterialBase.prototype.setMipMap = function (value) {
                this._pMipmap = value;

                for (var i = 0; i < this._numPasses; ++i)
                    this._passes[i].mipmap = value;
            };

            Object.defineProperty(MaterialBase.prototype, "smooth", {
                get: /**
                * Indicates whether or not any used textures should use smoothing.
                */
                function () {
                    return this._smooth;
                },
                set: function (value) {
                    this._smooth = value;

                    for (var i = 0; i < this._numPasses; ++i)
                        this._passes[i].smooth = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialBase.prototype, "depthCompareMode", {
                get: /**
                * The depth compare mode used to render the renderables using this material.
                *
                * @see away.gl.ContextGLCompareMode
                */
                function () {
                    return this._pDepthCompareMode;
                },
                set: function (value) {
                    this.setDepthCompareMode(value);
                },
                enumerable: true,
                configurable: true
            });


            MaterialBase.prototype.setDepthCompareMode = function (value) {
                this._pDepthCompareMode = value;
            };

            Object.defineProperty(MaterialBase.prototype, "repeat", {
                get: /**
                * Indicates whether or not any used textures should be tiled. If set to false, texture samples are clamped to
                * the texture's borders when the uv coordinates are outside the [0, 1] interval.
                */
                function () {
                    return this._repeat;
                },
                set: function (value) {
                    this._repeat = value;

                    for (var i = 0; i < this._numPasses; ++i)
                        this._passes[i].repeat = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Cleans up resources owned by the material, including passes. Textures are not owned by the material since they
            * could be used by other materials and will not be disposed.
            */
            MaterialBase.prototype.dispose = function () {
                var i;

                for (i = 0; i < this._numPasses; ++i)
                    this._passes[i].dispose();

                this._pDepthPass.dispose();
                this._pDistancePass.dispose();

                this._pDepthPass.removeEventListener(Event.CHANGE, this._onDepthPassChangeDelegate);
                this._pDistancePass.removeEventListener(Event.CHANGE, this._onDistancePassChangeDelegate);
            };

            Object.defineProperty(MaterialBase.prototype, "bothSides", {
                get: /**
                * Defines whether or not the material should cull triangles facing away from the camera.
                */
                function () {
                    return this._bothSides;
                },
                set: function (value) {
                    this._bothSides = value;

                    for (var i = 0; i < this._numPasses; ++i)
                        this._passes[i].bothSides = value;

                    this._pDepthPass.bothSides = value;
                    this._pDistancePass.bothSides = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialBase.prototype, "blendMode", {
                get: /**
                * The blend mode to use when drawing this renderable. The following blend modes are supported:
                * <ul>
                * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
                * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
                * <li>BlendMode.MULTIPLY</li>
                * <li>BlendMode.ADD</li>
                * <li>BlendMode.ALPHA</li>
                * </ul>
                */
                function () {
                    return this.getBlendMode();
                },
                set: function (value) {
                    this.setBlendMode(value);
                },
                enumerable: true,
                configurable: true
            });

            MaterialBase.prototype.getBlendMode = function () {
                return this._pBlendMode;
            };


            MaterialBase.prototype.setBlendMode = function (value) {
                this._pBlendMode = value;
            };

            Object.defineProperty(MaterialBase.prototype, "alphaPremultiplied", {
                get: /**
                * Indicates whether visible textures (or other pixels) used by this material have
                * already been premultiplied. Toggle this if you are seeing black halos around your
                * blended alpha edges.
                */
                function () {
                    return this._alphaPremultiplied;
                },
                set: function (value) {
                    this._alphaPremultiplied = value;

                    for (var i = 0; i < this._numPasses; ++i)
                        this._passes[i].alphaPremultiplied = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialBase.prototype, "requiresBlending", {
                get: /**
                * Indicates whether or not the material requires alpha blending during rendering.
                */
                function () {
                    return this.getRequiresBlending();
                },
                enumerable: true,
                configurable: true
            });

            MaterialBase.prototype.getRequiresBlending = function () {
                return this._pBlendMode != away.base.BlendMode.NORMAL;
            };

            Object.defineProperty(MaterialBase.prototype, "_iNumPasses", {
                get: /**
                * The amount of passes used by the material.
                *
                * @private
                */
                function () {
                    return this._numPasses;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Indicates that the depth pass uses transparency testing to discard pixels.
            *
            * @private
            */
            MaterialBase.prototype.iHasDepthAlphaThreshold = function () {
                return this._pDepthPass.alphaThreshold > 0;
            };

            /**
            * Sets the render state for the depth pass that is independent of the rendered object. Used when rendering
            * depth or distances (fe: shadow maps, depth pre-pass).
            *
            * @param stageGL The StageGL used for rendering.
            * @param camera The camera from which the scene is viewed.
            * @param distanceBased Whether or not the depth pass or distance pass should be activated. The distance pass
            * is required for shadow cube maps.
            *
            * @internal
            */
            MaterialBase.prototype.iActivateForDepth = function (stageGL, camera, distanceBased) {
                if (typeof distanceBased === "undefined") { distanceBased = false; }
                this._distanceBasedDepthRender = distanceBased;

                if (distanceBased)
                    this._pDistancePass.iActivate(stageGL, camera);
else
                    this._pDepthPass.iActivate(stageGL, camera);
            };

            /**
            * Clears the render state for the depth pass.
            *
            * @param stageGL The StageGL used for rendering.
            *
            * @internal
            */
            MaterialBase.prototype.iDeactivateForDepth = function (stageGL) {
                if (this._distanceBasedDepthRender)
                    this._pDistancePass.iDeactivate(stageGL);
else
                    this._pDepthPass.iDeactivate(stageGL);
            };

            /**
            * Renders a renderable using the depth pass.
            *
            * @param renderable The RenderableBase instance that needs to be rendered.
            * @param stageGL The StageGL used for rendering.
            * @param camera The camera from which the scene is viewed.
            * @param viewProjection The view-projection matrix used to project to the screen. This is not the same as
            * camera.viewProjection as it includes the scaling factors when rendering to textures.
            *
            * @internal
            */
            MaterialBase.prototype.iRenderDepth = function (renderable, stageGL, camera, viewProjection) {
                if (this._distanceBasedDepthRender) {
                    if (renderable.materialOwner.animator)
                        this._pDistancePass.iUpdateAnimationState(renderable, stageGL, camera);

                    this._pDistancePass.iRender(renderable, stageGL, camera, viewProjection);
                } else {
                    if (renderable.materialOwner.animator)
                        this._pDepthPass.iUpdateAnimationState(renderable, stageGL, camera);

                    this._pDepthPass.iRender(renderable, stageGL, camera, viewProjection);
                }
            };

            //*/
            /**
            * Indicates whether or not the pass with the given index renders to texture or not.
            * @param index The index of the pass.
            * @return True if the pass renders to texture, false otherwise.
            *
            * @internal
            */
            MaterialBase.prototype.iPassRendersToTexture = function (index) {
                return this._passes[index].renderToTexture;
            };

            /**
            * Sets the render state for a pass that is independent of the rendered object. This needs to be called before
            * calling renderPass. Before activating a pass, the previously used pass needs to be deactivated.
            * @param index The index of the pass to activate.
            * @param stageGL The StageGL object which is currently used for rendering.
            * @param camera The camera from which the scene is viewed.
            * @private
            */
            MaterialBase.prototype.iActivatePass = function (index, stageGL, camera) {
                this._passes[index].iActivate(stageGL, camera);
            };

            /**
            * Clears the render state for a pass. This needs to be called before activating another pass.
            * @param index The index of the pass to deactivate.
            * @param stageGL The StageGL used for rendering
            *
            * @internal
            */
            MaterialBase.prototype.iDeactivatePass = function (index, stageGL) {
                this._passes[index].iDeactivate(stageGL);
            };

            /**
            * Renders the current pass. Before calling renderPass, activatePass needs to be called with the same index.
            * @param index The index of the pass used to render the renderable.
            * @param renderable The RenderableBase object to draw.
            * @param stageGL The StageGL object used for rendering.
            * @param entityCollector The EntityCollector object that contains the visible scene data.
            * @param viewProjection The view-projection matrix used to project to the screen. This is not the same as
            * camera.viewProjection as it includes the scaling factors when rendering to textures.
            *
            * @internal
            */
            MaterialBase.prototype.iRenderPass = function (index, renderable, stageGL, entityCollector, viewProjection) {
                if (this._pLightPicker)
                    this._pLightPicker.collectLights(renderable, entityCollector);

                var pass = this._passes[index];

                if (renderable.materialOwner.animator)
                    pass.iUpdateAnimationState(renderable, stageGL, entityCollector.camera);

                pass.iRender(renderable, stageGL, entityCollector.camera, viewProjection);
            };

            //
            // MATERIAL MANAGEMENT
            //
            /**
            * Mark an IMaterialOwner as owner of this material.
            * Assures we're not using the same material across renderables with different animations, since the
            * Programs depend on animation. This method needs to be called when a material is assigned.
            *
            * @param owner The IMaterialOwner that had this material assigned
            *
            * @internal
            */
            MaterialBase.prototype.iAddOwner = function (owner) {
                this._owners.push(owner);

                var animationSet;
                var animator = owner.animator;

                if (animator)
                    animationSet = animator.animationSet;

                if (owner.animator) {
                    if (this._animationSet && animationSet != this._animationSet) {
                        throw new Error("A Material instance cannot be shared across renderables with different animator libraries");
                    } else {
                        if (this._animationSet != animationSet) {
                            this._animationSet = animationSet;

                            for (var i = 0; i < this._numPasses; ++i)
                                this._passes[i].animationSet = this._animationSet;

                            this._pDepthPass.animationSet = this._animationSet;
                            this._pDistancePass.animationSet = this._animationSet;

                            this.iInvalidatePasses(null);
                        }
                    }
                }
            };

            /**
            * Removes an IMaterialOwner as owner.
            * @param owner
            *
            * @internal
            */
            MaterialBase.prototype.iRemoveOwner = function (owner) {
                this._owners.splice(this._owners.indexOf(owner), 1);

                if (this._owners.length == 0) {
                    this._animationSet = null;

                    for (var i = 0; i < this._numPasses; ++i)
                        this._passes[i].animationSet = this._animationSet;

                    this._pDepthPass.animationSet = this._animationSet;
                    this._pDistancePass.animationSet = this._animationSet;
                    this.iInvalidatePasses(null);
                }
            };

            Object.defineProperty(MaterialBase.prototype, "iOwners", {
                get: /**
                * A list of the IMaterialOwners that use this material
                *
                * @private
                */
                function () {
                    return this._owners;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Performs any processing that needs to occur before any of its passes are used.
            *
            * @private
            */
            MaterialBase.prototype.iUpdateMaterial = function (context) {
                //throw new away.errors.AbstractMethodError();
            };

            /**
            * Deactivates the last pass of the material.
            *
            * @private
            */
            MaterialBase.prototype.iDeactivate = function (stageGL) {
                this._passes[this._numPasses - 1].iDeactivate(stageGL);
            };

            /**
            * Marks the shader programs for all passes as invalid, so they will be recompiled before the next use.
            * @param triggerPass The pass triggering the invalidation, if any. This is passed to prevent invalidating the
            * triggering pass, which would result in an infinite loop.
            *
            * @private
            */
            MaterialBase.prototype.iInvalidatePasses = function (triggerPass) {
                var owner;
                var animator;

                var l;
                var c;

                this._pDepthPass.iInvalidateShaderProgram();
                this._pDistancePass.iInvalidateShaderProgram();

                if (this._animationSet) {
                    this._animationSet.resetGPUCompatibility();

                    l = this._owners.length;

                    for (c = 0; c < l; c++) {
                        owner = this._owners[c];
                        animator = owner.animator;

                        if (animator) {
                            animator.testGPUCompatibility(this._pDepthPass);
                            animator.testGPUCompatibility(this._pDistancePass);
                        }
                    }
                }

                for (var i = 0; i < this._numPasses; ++i) {
                    if (this._passes[i] != triggerPass)
                        this._passes[i].iInvalidateShaderProgram(false);

                    if (this._animationSet) {
                        l = this._owners.length;

                        for (c = 0; c < l; c++) {
                            owner = this._owners[c];
                            animator = owner.animator;

                            if (animator)
                                animator.testGPUCompatibility(this._passes[i]);
                        }
                    }
                }
            };

            /**
            * Removes a pass from the material.
            * @param pass The pass to be removed.
            */
            MaterialBase.prototype.pRemovePass = function (pass) {
                this._passes.splice(this._passes.indexOf(pass), 1);
                --this._numPasses;
            };

            /**
            * Removes all passes from the material
            */
            MaterialBase.prototype.pClearPasses = function () {
                for (var i = 0; i < this._numPasses; ++i)
                    this._passes[i].removeEventListener(Event.CHANGE, this._onPassChangeDelegate);

                this._passes.length = 0;
                this._numPasses = 0;
            };

            /**
            * Adds a pass to the material
            * @param pass
            */
            MaterialBase.prototype.pAddPass = function (pass) {
                this._passes[this._numPasses++] = pass;

                pass.animationSet = this._animationSet;
                pass.alphaPremultiplied = this._alphaPremultiplied;
                pass.mipmap = this._pMipmap;
                pass.smooth = this._smooth;
                pass.repeat = this._repeat;
                pass.lightPicker = this._pLightPicker;
                pass.bothSides = this._bothSides;
                pass.addEventListener(Event.CHANGE, this._onPassChangeDelegate);

                this.iInvalidatePasses(null);
            };

            /**
            * Listener for when a pass's shader code changes. It recalculates the render order id.
            */
            MaterialBase.prototype.onPassChange = function (event) {
                var mult = 1;
                var ids;
                var len;

                this._iRenderOrderId = 0;

                for (var i = 0; i < this._numPasses; ++i) {
                    ids = this._passes[i]._iProgramids;
                    len = ids.length;

                    for (var j = 0; j < len; ++j) {
                        if (ids[j] != -1) {
                            this._iRenderOrderId += mult * ids[j];
                            j = len;
                        }
                    }

                    mult *= 1000;
                }
            };

            /**
            * Listener for when the distance pass's shader code changes. It recalculates the depth pass id.
            */
            MaterialBase.prototype.onDistancePassChange = function (event) {
                var ids = this._pDistancePass._iProgramids;
                var len = ids.length;

                this._iDepthPassId = 0;

                for (var j = 0; j < len; ++j) {
                    if (ids[j] != -1) {
                        this._iDepthPassId += ids[j];
                        j = len;
                    }
                }
            };

            /**
            * Listener for when the depth pass's shader code changes. It recalculates the depth pass id.
            */
            MaterialBase.prototype.onDepthPassChange = function (event) {
                var ids = this._pDepthPass._iProgramids;
                var len = ids.length;

                this._iDepthPassId = 0;

                for (var j = 0; j < len; ++j) {
                    if (ids[j] != -1) {
                        this._iDepthPassId += ids[j];
                        j = len;
                    }
                }
            };
            return MaterialBase;
        })(away.library.NamedAssetBase);
        materials.MaterialBase = MaterialBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * SinglePassMaterialBase forms an abstract base class for the default single-pass materials provided by Away3D,
        * using material methods to define their appearance.
        */
        var SinglePassMaterialBase = (function (_super) {
            __extends(SinglePassMaterialBase, _super);
            /**
            * Creates a new SinglePassMaterialBase object.
            */
            function SinglePassMaterialBase() {
                _super.call(this);
                this._alphaBlending = false;

                this.pAddPass(this._pScreenPass = new materials.SuperShaderPass(this));
            }
            Object.defineProperty(SinglePassMaterialBase.prototype, "enableLightFallOff", {
                get: /**
                * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
                * compatibility for constrained mode.
                */
                function () {
                    return this._pScreenPass.enableLightFallOff;
                },
                set: function (value) {
                    this._pScreenPass.enableLightFallOff = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "alphaThreshold", {
                get: /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                function () {
                    return this._pScreenPass.diffuseMethod.alphaThreshold;
                },
                set: function (value) {
                    this._pScreenPass.diffuseMethod.alphaThreshold = value;

                    this._pDepthPass.alphaThreshold = value;
                    this._pDistancePass.alphaThreshold = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "blendMode", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    _super.prototype.setBlendMode.call(this, value);
                    this._pScreenPass.setBlendMode((this._pBlendMode == away.base.BlendMode.NORMAL) && this.requiresBlending ? away.base.BlendMode.LAYER : this._pBlendMode);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SinglePassMaterialBase.prototype, "depthCompareMode", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    this._pDepthCompareMode = value;
                    this._pScreenPass.depthCompareMode = value;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SinglePassMaterialBase.prototype.iActivateForDepth = function (stageGL, camera, distanceBased) {
                if (typeof distanceBased === "undefined") { distanceBased = false; }
                if (distanceBased) {
                    this._pDistancePass.alphaMask = this._pScreenPass.diffuseMethod.texture;
                } else {
                    this._pDepthPass.alphaMask = this._pScreenPass.diffuseMethod.texture;
                }

                _super.prototype.iActivateForDepth.call(this, stageGL, camera, distanceBased);
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "specularLightSources", {
                get: /**
                * Define which light source types to use for specular reflections. This allows choosing between regular lights
                * and/or light probes for specular reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._pScreenPass.specularLightSources;
                },
                set: function (value) {
                    this._pScreenPass.specularLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "diffuseLightSources", {
                get: /**
                * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
                * and/or light probes for diffuse reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._pScreenPass.diffuseLightSources;
                },
                set: function (value) {
                    this._pScreenPass.diffuseLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "requiresBlending", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this.getRequiresBlending();
                },
                enumerable: true,
                configurable: true
            });

            SinglePassMaterialBase.prototype.getRequiresBlending = function () {
                var ct = this._pScreenPass.colorTransform;

                if (ct) {
                    return (this._pBlendMode != away.base.BlendMode.NORMAL) || this._alphaBlending || (ct.alphaMultiplier < 1);
                }
                return (this._pBlendMode != away.base.BlendMode.NORMAL) || this._alphaBlending;
                //return super.getRequiresBlending() || this._alphaBlending || ( this._pScreenPass.colorTransform && this._pScreenPass.colorTransform.alphaMultiplier < 1);
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "colorTransform", {
                get: /**
                * The ColorTransform object to transform the colour of the material with. Defaults to null.
                */
                function () {
                    return this._pScreenPass.colorTransform;
                },
                set: function (value) {
                    this.setColorTransform(value);
                },
                enumerable: true,
                configurable: true
            });


            SinglePassMaterialBase.prototype.setColorTransform = function (value) {
                this._pScreenPass.colorTransform = value;
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "ambientMethod", {
                get: /**
                * The method that provides the ambient lighting contribution. Defaults to BasicAmbientMethod.
                */
                function () {
                    return this._pScreenPass.ambientMethod;
                },
                set: function (value) {
                    this._pScreenPass.ambientMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "shadowMethod", {
                get: /**
                * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
                */
                function () {
                    return this._pScreenPass.shadowMethod;
                },
                set: function (value) {
                    this._pScreenPass.shadowMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "diffuseMethod", {
                get: /**
                * The method that provides the diffuse lighting contribution. Defaults to BasicDiffuseMethod.
                */
                function () {
                    return this._pScreenPass.diffuseMethod;
                },
                set: function (value) {
                    this._pScreenPass.diffuseMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "normalMethod", {
                get: /**
                * The method used to generate the per-pixel normals. Defaults to BasicNormalMethod.
                */
                function () {
                    return this._pScreenPass.normalMethod;
                },
                set: function (value) {
                    this._pScreenPass.normalMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "specularMethod", {
                get: /**
                * The method that provides the specular lighting contribution. Defaults to BasicSpecularMethod.
                */
                function () {
                    return this._pScreenPass.specularMethod;
                },
                set: function (value) {
                    this._pScreenPass.specularMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
            * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
            * methods added prior.
            */
            SinglePassMaterialBase.prototype.addMethod = function (method) {
                this._pScreenPass.addMethod(method);
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "numMethods", {
                get: /**
                * The number of "effect" methods added to the material.
                */
                function () {
                    return this._pScreenPass.numMethods;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Queries whether a given effect method was added to the material.
            *
            * @param method The method to be queried.
            * @return true if the method was added to the material, false otherwise.
            */
            SinglePassMaterialBase.prototype.hasMethod = function (method) {
                return this._pScreenPass.hasMethod(method);
            };

            /**
            * Returns the method added at the given index.
            * @param index The index of the method to retrieve.
            * @return The method at the given index.
            */
            SinglePassMaterialBase.prototype.getMethodAt = function (index) {
                return this._pScreenPass.getMethodAt(index);
            };

            /**
            * Adds an effect method at the specified index amongst the methods already added to the material. Effect
            * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
            * etc. The method will be applied to the result of the methods with a lower index.
            */
            SinglePassMaterialBase.prototype.addMethodAt = function (method, index) {
                this._pScreenPass.addMethodAt(method, index);
            };

            /**
            * Removes an effect method from the material.
            * @param method The method to be removed.
            */
            SinglePassMaterialBase.prototype.removeMethod = function (method) {
                this._pScreenPass.removeMethod(method);
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "mipmap", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    if (this._pMipmap == value)
                        return;

                    this.setMipMap(value);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SinglePassMaterialBase.prototype, "normalMap", {
                get: /**
                * The normal map to modulate the direction of the surface for each texel. The default normal method expects
                * tangent-space normal maps, but others could expect object-space maps.
                */
                function () {
                    return this._pScreenPass.normalMap;
                },
                set: function (value) {
                    this._pScreenPass.normalMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "specularMap", {
                get: /**
                * A specular map that defines the strength of specular reflections for each texel in the red channel,
                * and the gloss factor in the green channel. You can use SpecularBitmapTexture if you want to easily set
                * specular and gloss maps from grayscale images, but correctly authored images are preferred.
                */
                function () {
                    return this._pScreenPass.specularMethod.texture;
                },
                set: function (value) {
                    if (this._pScreenPass.specularMethod) {
                        this._pScreenPass.specularMethod.texture = value;
                    } else {
                        throw new away.errors.Error("No specular method was set to assign the specularGlossMap to");
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "gloss", {
                get: /**
                * The glossiness of the material (sharpness of the specular highlight).
                */
                function () {
                    return this._pScreenPass.specularMethod ? this._pScreenPass.specularMethod.gloss : 0;
                },
                set: function (value) {
                    if (this._pScreenPass.specularMethod)
                        this._pScreenPass.specularMethod.gloss = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "ambient", {
                get: /**
                * The strength of the ambient reflection.
                */
                function () {
                    return this._pScreenPass.ambientMethod.ambient;
                },
                set: function (value) {
                    this._pScreenPass.ambientMethod.ambient = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "specular", {
                get: /**
                * The overall strength of the specular reflection.
                */
                function () {
                    return this._pScreenPass.specularMethod ? this._pScreenPass.specularMethod.specular : 0;
                },
                set: function (value) {
                    if (this._pScreenPass.specularMethod)
                        this._pScreenPass.specularMethod.specular = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "ambientColor", {
                get: /**
                * The colour of the ambient reflection.
                */
                function () {
                    return this._pScreenPass.ambientMethod.ambientColor;
                },
                set: function (value) {
                    this._pScreenPass.ambientMethod.ambientColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "specularColor", {
                get: /**
                * The colour of the specular reflection.
                */
                function () {
                    return this._pScreenPass.specularMethod.specularColor;
                },
                set: function (value) {
                    this._pScreenPass.specularMethod.specularColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "alphaBlending", {
                get: /**
                * Indicates whether or not the material has transparency. If binary transparency is sufficient, for
                * example when using textures of foliage, consider using alphaThreshold instead.
                */
                function () {
                    return this._alphaBlending;
                },
                set: function (value) {
                    this._alphaBlending = value;
                    this._pScreenPass.setBlendMode(this.getBlendMode() == away.base.BlendMode.NORMAL && this.requiresBlending ? away.base.BlendMode.LAYER : this.getBlendMode());
                    this._pScreenPass.preserveAlpha = this.requiresBlending;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SinglePassMaterialBase.prototype.iUpdateMaterial = function (context) {
                if (this._pScreenPass._iPassesDirty) {
                    this.pClearPasses();

                    if (this._pScreenPass._iPasses) {
                        var len = this._pScreenPass._iPasses.length;

                        for (var i = 0; i < len; ++i) {
                            this.pAddPass(this._pScreenPass._iPasses[i]);
                        }
                    }

                    this.pAddPass(this._pScreenPass);
                    this._pScreenPass._iPassesDirty = false;
                }
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "lightPicker", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    _super.prototype.setLightPicker.call(this, value);
                    this._pScreenPass.lightPicker = value;
                },
                enumerable: true,
                configurable: true
            });
            return SinglePassMaterialBase;
        })(materials.MaterialBase);
        materials.SinglePassMaterialBase = SinglePassMaterialBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        var Delegate = away.utils.Delegate;

        var Camera = away.entities.Camera;
        var StageGL = away.base.StageGL;

        /**
        * MultiPassMaterialBase forms an abstract base class for the default multi-pass materials provided by Away3D,
        * using material methods to define their appearance.
        */
        var MultiPassMaterialBase = (function (_super) {
            __extends(MultiPassMaterialBase, _super);
            /**
            * Creates a new MultiPassMaterialBase object.
            */
            function MultiPassMaterialBase() {
                _super.call(this);
                this._alphaThreshold = 0;
                this._specularLightSources = 0x01;
                this._diffuseLightSources = 0x03;
                this._ambientMethod = new materials.BasicAmbientMethod();
                this._diffuseMethod = new materials.BasicDiffuseMethod();
                this._normalMethod = new materials.BasicNormalMethod();
                this._specularMethod = new materials.BasicSpecularMethod();
                this._screenPassesInvalid = true;
                this._enableLightFallOff = true;

                this._onLightChangeDelegate = Delegate.create(this, this.onLightsChange);
            }
            Object.defineProperty(MultiPassMaterialBase.prototype, "enableLightFallOff", {
                get: /**
                * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
                * compatibility for constrained mode.
                */
                function () {
                    return this._enableLightFallOff;
                },
                set: function (value) {
                    if (this._enableLightFallOff != value)
                        this.pInvalidateScreenPasses();

                    this._enableLightFallOff = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "alphaThreshold", {
                get: /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                function () {
                    return this._alphaThreshold;
                },
                set: function (value) {
                    this._alphaThreshold = value;
                    this._diffuseMethod.alphaThreshold = value;
                    this._pDepthPass.alphaThreshold = value;
                    this._pDistancePass.alphaThreshold = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "depthCompareMode", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    _super.prototype.setDepthCompareMode.call(this, value);
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "blendMode", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    _super.prototype.setBlendMode.call(this, value);
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            MultiPassMaterialBase.prototype.iActivateForDepth = function (stageGL, camera, distanceBased) {
                if (typeof distanceBased === "undefined") { distanceBased = false; }
                if (distanceBased)
                    this._pDistancePass.alphaMask = this._diffuseMethod.texture;
else
                    this._pDepthPass.alphaMask = this._diffuseMethod.texture;

                _super.prototype.iActivateForDepth.call(this, stageGL, camera, distanceBased);
            };

            Object.defineProperty(MultiPassMaterialBase.prototype, "specularLightSources", {
                get: /**
                * Define which light source types to use for specular reflections. This allows choosing between regular lights
                * and/or light probes for specular reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._specularLightSources;
                },
                set: function (value) {
                    this._specularLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "diffuseLightSources", {
                get: /**
                * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
                * and/or light probes for diffuse reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._diffuseLightSources;
                },
                set: function (value) {
                    this._diffuseLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "lightPicker", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    if (this._pLightPicker)
                        this._pLightPicker.removeEventListener(away.events.Event.CHANGE, this._onLightChangeDelegate);

                    _super.prototype.setLightPicker.call(this, value);

                    if (this._pLightPicker)
                        this._pLightPicker.addEventListener(away.events.Event.CHANGE, this._onLightChangeDelegate);

                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "requiresBlending", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "ambientMethod", {
                get: /**
                * The method that provides the ambient lighting contribution. Defaults to BasicAmbientMethod.
                */
                function () {
                    return this._ambientMethod;
                },
                set: function (value) {
                    value.copyFrom(this._ambientMethod);
                    this._ambientMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "shadowMethod", {
                get: /**
                * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
                */
                function () {
                    return this._shadowMethod;
                },
                set: function (value) {
                    if (value && this._shadowMethod)
                        value.copyFrom(this._shadowMethod);

                    this._shadowMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "diffuseMethod", {
                get: /**
                * The method that provides the diffuse lighting contribution. Defaults to BasicDiffuseMethod.
                */
                function () {
                    return this._diffuseMethod;
                },
                set: function (value) {
                    value.copyFrom(this._diffuseMethod);
                    this._diffuseMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "specularMethod", {
                get: /**
                * The method that provides the specular lighting contribution. Defaults to BasicSpecularMethod.
                */
                function () {
                    return this._specularMethod;
                },
                set: function (value) {
                    if (value && this._specularMethod)
                        value.copyFrom(this._specularMethod);

                    this._specularMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "normalMethod", {
                get: /**
                * The method used to generate the per-pixel normals. Defaults to BasicNormalMethod.
                */
                function () {
                    return this._normalMethod;
                },
                set: function (value) {
                    value.copyFrom(this._normalMethod);
                    this._normalMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
            * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
            * methods added prior.
            */
            MultiPassMaterialBase.prototype.addMethod = function (method) {
                if (this._pEffectsPass == null)
                    this._pEffectsPass = new materials.SuperShaderPass(this);

                this._pEffectsPass.addMethod(method);
                this.pInvalidateScreenPasses();
            };

            Object.defineProperty(MultiPassMaterialBase.prototype, "numMethods", {
                get: /**
                * The number of "effect" methods added to the material.
                */
                function () {
                    return this._pEffectsPass ? this._pEffectsPass.numMethods : 0;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Queries whether a given effect method was added to the material.
            *
            * @param method The method to be queried.
            * @return true if the method was added to the material, false otherwise.
            */
            MultiPassMaterialBase.prototype.hasMethod = function (method) {
                return this._pEffectsPass ? this._pEffectsPass.hasMethod(method) : false;
            };

            /**
            * Returns the method added at the given index.
            * @param index The index of the method to retrieve.
            * @return The method at the given index.
            */
            MultiPassMaterialBase.prototype.getMethodAt = function (index) {
                return this._pEffectsPass.getMethodAt(index);
            };

            /**
            * Adds an effect method at the specified index amongst the methods already added to the material. Effect
            * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
            * etc. The method will be applied to the result of the methods with a lower index.
            */
            MultiPassMaterialBase.prototype.addMethodAt = function (method, index) {
                if (this._pEffectsPass == null)
                    this._pEffectsPass = new materials.SuperShaderPass(this);

                this._pEffectsPass.addMethodAt(method, index);
                this.pInvalidateScreenPasses();
            };

            /**
            * Removes an effect method from the material.
            * @param method The method to be removed.
            */
            MultiPassMaterialBase.prototype.removeMethod = function (method) {
                if (this._pEffectsPass)
                    return;

                this._pEffectsPass.removeMethod(method);

                if (this._pEffectsPass.numMethods == 0)
                    this.pInvalidateScreenPasses();
            };

            Object.defineProperty(MultiPassMaterialBase.prototype, "mipmap", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    if (this._pMipmap == value)
                        return;

                    _super.prototype.setMipMap.call(this, value);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "normalMap", {
                get: /**
                * The normal map to modulate the direction of the surface for each texel. The default normal method expects
                * tangent-space normal maps, but others could expect object-space maps.
                */
                function () {
                    return this._normalMethod.normalMap;
                },
                set: function (value) {
                    this._normalMethod.normalMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "specularMap", {
                get: /**
                * A specular map that defines the strength of specular reflections for each texel in the red channel,
                * and the gloss factor in the green channel. You can use SpecularBitmapTexture if you want to easily set
                * specular and gloss maps from grayscale images, but correctly authored images are preferred.
                */
                function () {
                    return this._specularMethod.texture;
                },
                set: function (value) {
                    if (this._specularMethod)
                        this._specularMethod.texture = value;
else
                        throw new Error("No specular method was set to assign the specularGlossMap to");
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "gloss", {
                get: /**
                * The glossiness of the material (sharpness of the specular highlight).
                */
                function () {
                    return this._specularMethod ? this._specularMethod.gloss : 0;
                },
                set: function (value) {
                    if (this._specularMethod)
                        this._specularMethod.gloss = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "ambient", {
                get: /**
                * The strength of the ambient reflection.
                */
                function () {
                    return this._ambientMethod.ambient;
                },
                set: function (value) {
                    this._ambientMethod.ambient = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "specular", {
                get: /**
                * The overall strength of the specular reflection.
                */
                function () {
                    return this._specularMethod ? this._specularMethod.specular : 0;
                },
                set: function (value) {
                    if (this._specularMethod)
                        this._specularMethod.specular = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "ambientColor", {
                get: /**
                * The colour of the ambient reflection.
                */
                function () {
                    return this._ambientMethod.ambientColor;
                },
                set: function (value) {
                    this._ambientMethod.ambientColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "specularColor", {
                get: /**
                * The colour of the specular reflection.
                */
                function () {
                    return this._specularMethod.specularColor;
                },
                set: function (value) {
                    this._specularMethod.specularColor = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            MultiPassMaterialBase.prototype.iUpdateMaterial = function (context) {
                var passesInvalid;

                if (this._screenPassesInvalid) {
                    this.pUpdateScreenPasses();
                    passesInvalid = true;
                }

                if (passesInvalid || this.isAnyScreenPassInvalid()) {
                    this.pClearPasses();

                    this.addChildPassesFor(this._casterLightPass);

                    if (this._nonCasterLightPasses) {
                        for (var i = 0; i < this._nonCasterLightPasses.length; ++i)
                            this.addChildPassesFor(this._nonCasterLightPasses[i]);
                    }

                    this.addChildPassesFor(this._pEffectsPass);

                    this.addScreenPass(this._casterLightPass);

                    if (this._nonCasterLightPasses) {
                        for (i = 0; i < this._nonCasterLightPasses.length; ++i) {
                            this.addScreenPass(this._nonCasterLightPasses[i]);
                        }
                    }

                    this.addScreenPass(this._pEffectsPass);
                }
            };

            /**
            * Adds a compiled pass that renders to the screen.
            * @param pass The pass to be added.
            */
            MultiPassMaterialBase.prototype.addScreenPass = function (pass) {
                if (pass) {
                    this.pAddPass(pass);
                    pass._iPassesDirty = false;
                }
            };

            /**
            * Tests if any pass that renders to the screen is invalid. This would trigger a new setup of the multiple passes.
            * @return
            */
            MultiPassMaterialBase.prototype.isAnyScreenPassInvalid = function () {
                if ((this._casterLightPass && this._casterLightPass._iPassesDirty) || (this._pEffectsPass && this._pEffectsPass._iPassesDirty))
                    return true;

                if (this._nonCasterLightPasses) {
                    for (var i = 0; i < this._nonCasterLightPasses.length; ++i) {
                        if (this._nonCasterLightPasses[i]._iPassesDirty)
                            return true;
                    }
                }

                return false;
            };

            /**
            * Adds any additional passes on which the given pass is dependent.
            * @param pass The pass that my need additional passes.
            */
            MultiPassMaterialBase.prototype.addChildPassesFor = function (pass) {
                if (!pass)
                    return;

                if (pass._iPasses) {
                    var len = pass._iPasses.length;

                    for (var i = 0; i < len; ++i) {
                        this.pAddPass(pass._iPasses[i]);
                    }
                }
            };

            /**
            * @inheritDoc
            */
            MultiPassMaterialBase.prototype.iActivatePass = function (index, stageGL, camera) {
                if (index == 0)
                    stageGL.contextGL.setBlendFactors(away.gl.ContextGLBlendFactor.ONE, away.gl.ContextGLBlendFactor.ZERO);

                _super.prototype.iActivatePass.call(this, index, stageGL, camera);
            };

            /**
            * @inheritDoc
            */
            MultiPassMaterialBase.prototype.iDeactivate = function (stageGL) {
                _super.prototype.iDeactivate.call(this, stageGL);

                stageGL.contextGL.setBlendFactors(away.gl.ContextGLBlendFactor.ONE, away.gl.ContextGLBlendFactor.ZERO);
            };

            /**
            * Updates screen passes when they were found to be invalid.
            */
            MultiPassMaterialBase.prototype.pUpdateScreenPasses = function () {
                this.initPasses();
                this.setBlendAndCompareModes();

                this._screenPassesInvalid = false;
            };

            /**
            * Initializes all the passes and their dependent passes.
            */
            MultiPassMaterialBase.prototype.initPasses = function () {
                if (this.numLights == 0 || this.numMethods > 0)
                    this.initEffectsPass();
else if (this._pEffectsPass && this.numMethods == 0)
                    this.removeEffectsPass();

                if (this._shadowMethod)
                    this.initCasterLightPass();
else
                    this.removeCasterLightPass();

                if (this.numNonCasters > 0)
                    this.initNonCasterLightPasses();
else
                    this.removeNonCasterLightPasses();
            };

            /**
            * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.
            */
            MultiPassMaterialBase.prototype.setBlendAndCompareModes = function () {
                var forceSeparateMVP = (this._casterLightPass || this._pEffectsPass);

                if (this._casterLightPass) {
                    this._casterLightPass.setBlendMode(away.base.BlendMode.NORMAL);
                    this._casterLightPass.depthCompareMode = this._pDepthCompareMode;
                    this._casterLightPass.forceSeparateMVP = forceSeparateMVP;
                }

                if (this._nonCasterLightPasses) {
                    var firstAdditiveIndex = 0;

                    if (!this._casterLightPass) {
                        this._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;
                        this._nonCasterLightPasses[0].setBlendMode(away.base.BlendMode.NORMAL);
                        this._nonCasterLightPasses[0].depthCompareMode = this._pDepthCompareMode;
                        firstAdditiveIndex = 1;
                    }

                    for (var i = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {
                        this._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;
                        this._nonCasterLightPasses[i].setBlendMode(away.base.BlendMode.ADD);
                        this._nonCasterLightPasses[i].depthCompareMode = away.gl.ContextGLCompareMode.LESS_EQUAL;
                    }
                }

                if (this._casterLightPass || this._nonCasterLightPasses) {
                    if (this._pEffectsPass) {
                        this._pEffectsPass.iIgnoreLights = true;
                        this._pEffectsPass.depthCompareMode = away.gl.ContextGLCompareMode.LESS_EQUAL;
                        this._pEffectsPass.setBlendMode(away.base.BlendMode.LAYER);
                        this._pEffectsPass.forceSeparateMVP = forceSeparateMVP;
                    }
                } else if (this._pEffectsPass) {
                    // effects pass is the only pass, so it should just blend normally
                    this._pEffectsPass.iIgnoreLights = false;
                    this._pEffectsPass.depthCompareMode = this._pDepthCompareMode;

                    this.depthCompareMode;

                    this._pEffectsPass.setBlendMode(away.base.BlendMode.NORMAL);
                    this._pEffectsPass.forceSeparateMVP = false;
                }
            };

            MultiPassMaterialBase.prototype.initCasterLightPass = function () {
                if (this._casterLightPass == null)
                    this._casterLightPass = new materials.ShadowCasterPass(this);

                this._casterLightPass.diffuseMethod = null;
                this._casterLightPass.ambientMethod = null;
                this._casterLightPass.normalMethod = null;
                this._casterLightPass.specularMethod = null;
                this._casterLightPass.shadowMethod = null;
                this._casterLightPass.enableLightFallOff = this._enableLightFallOff;
                this._casterLightPass.lightPicker = new materials.StaticLightPicker([this._shadowMethod.castingLight]);
                this._casterLightPass.shadowMethod = this._shadowMethod;
                this._casterLightPass.diffuseMethod = this._diffuseMethod;
                this._casterLightPass.ambientMethod = this._ambientMethod;
                this._casterLightPass.normalMethod = this._normalMethod;
                this._casterLightPass.specularMethod = this._specularMethod;
                this._casterLightPass.diffuseLightSources = this._diffuseLightSources;
                this._casterLightPass.specularLightSources = this._specularLightSources;
            };

            MultiPassMaterialBase.prototype.removeCasterLightPass = function () {
                if (!this._casterLightPass)
                    return;

                this._casterLightPass.dispose();
                this.pRemovePass(this._casterLightPass);
                this._casterLightPass = null;
            };

            MultiPassMaterialBase.prototype.initNonCasterLightPasses = function () {
                this.removeNonCasterLightPasses();
                var pass;
                var numDirLights = this._pLightPicker.numDirectionalLights;
                var numPointLights = this._pLightPicker.numPointLights;
                var numLightProbes = this._pLightPicker.numLightProbes;
                var dirLightOffset = 0;
                var pointLightOffset = 0;
                var probeOffset = 0;

                if (!this._casterLightPass) {
                    numDirLights += this._pLightPicker.numCastingDirectionalLights;
                    numPointLights += this._pLightPicker.numCastingPointLights;
                }

                this._nonCasterLightPasses = new Array();

                while (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {
                    pass = new materials.LightingPass(this);
                    pass.enableLightFallOff = this._enableLightFallOff;
                    pass.includeCasters = this._shadowMethod == null;
                    pass.directionalLightsOffset = dirLightOffset;
                    pass.pointLightsOffset = pointLightOffset;
                    pass.lightProbesOffset = probeOffset;
                    pass.diffuseMethod = null;
                    pass.ambientMethod = null;
                    pass.normalMethod = null;
                    pass.specularMethod = null;
                    pass.lightPicker = this._pLightPicker;
                    pass.diffuseMethod = this._diffuseMethod;
                    pass.ambientMethod = this._ambientMethod;
                    pass.normalMethod = this._normalMethod;
                    pass.specularMethod = this._specularMethod;
                    pass.diffuseLightSources = this._diffuseLightSources;
                    pass.specularLightSources = this._specularLightSources;
                    this._nonCasterLightPasses.push(pass);

                    dirLightOffset += pass.iNumDirectionalLights;
                    pointLightOffset += pass.iNumPointLights;
                    probeOffset += pass.iNumLightProbes;
                }
            };

            MultiPassMaterialBase.prototype.removeNonCasterLightPasses = function () {
                if (!this._nonCasterLightPasses)
                    return;

                for (var i = 0; i < this._nonCasterLightPasses.length; ++i) {
                    this.pRemovePass(this._nonCasterLightPasses[i]);
                    this._nonCasterLightPasses[i].dispose();
                }
                this._nonCasterLightPasses = null;
            };

            MultiPassMaterialBase.prototype.removeEffectsPass = function () {
                if (this._pEffectsPass.diffuseMethod != this._diffuseMethod)
                    this._pEffectsPass.diffuseMethod.dispose();

                this.pRemovePass(this._pEffectsPass);
                this._pEffectsPass.dispose();
                this._pEffectsPass = null;
            };

            MultiPassMaterialBase.prototype.initEffectsPass = function () {
                if (this._pEffectsPass == null)
                    this._pEffectsPass = new materials.SuperShaderPass(this);

                this._pEffectsPass.enableLightFallOff = this._enableLightFallOff;
                if (this.numLights == 0) {
                    this._pEffectsPass.diffuseMethod = null;
                    this._pEffectsPass.diffuseMethod = this._diffuseMethod;
                } else {
                    this._pEffectsPass.diffuseMethod = null;
                    this._pEffectsPass.diffuseMethod = new materials.BasicDiffuseMethod();
                    this._pEffectsPass.diffuseMethod.diffuseColor = 0x000000;
                    this._pEffectsPass.diffuseMethod.diffuseAlpha = 0;
                }

                this._pEffectsPass.preserveAlpha = false;
                this._pEffectsPass.normalMethod = null;
                this._pEffectsPass.normalMethod = this._normalMethod;

                return this._pEffectsPass;
            };

            Object.defineProperty(MultiPassMaterialBase.prototype, "numLights", {
                get: /**
                * The maximum total number of lights provided by the light picker.
                */
                function () {
                    return this._pLightPicker ? this._pLightPicker.numLightProbes + this._pLightPicker.numDirectionalLights + this._pLightPicker.numPointLights + this._pLightPicker.numCastingDirectionalLights + this._pLightPicker.numCastingPointLights : 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "numNonCasters", {
                get: /**
                * The amount of lights that don't cast shadows.
                */
                function () {
                    return this._pLightPicker ? this._pLightPicker.numLightProbes + this._pLightPicker.numDirectionalLights + this._pLightPicker.numPointLights : 0;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Flags that the screen passes have become invalid.
            */
            MultiPassMaterialBase.prototype.pInvalidateScreenPasses = function () {
                this._screenPassesInvalid = true;
            };

            /**
            * Called when the light picker's configuration changed.
            */
            MultiPassMaterialBase.prototype.onLightsChange = function (event) {
                this.pInvalidateScreenPasses();
            };
            return MultiPassMaterialBase;
        })(materials.MaterialBase);
        materials.MultiPassMaterialBase = MultiPassMaterialBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * TextureMultiPassMaterial is a multi-pass material that uses a texture to define the surface's diffuse reflection colour (albedo).
        */
        var TextureMultiPassMaterial = (function (_super) {
            __extends(TextureMultiPassMaterial, _super);
            /**
            * Creates a new TextureMultiPassMaterial.
            * @param texture The texture used for the material's albedo color.
            * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.
            * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to true.
            * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to true.
            */
            function TextureMultiPassMaterial(texture, smooth, repeat, mipmap) {
                if (typeof texture === "undefined") { texture = null; }
                if (typeof smooth === "undefined") { smooth = true; }
                if (typeof repeat === "undefined") { repeat = false; }
                if (typeof mipmap === "undefined") { mipmap = true; }
                _super.call(this);
                this._animateUVs = false;
                this.texture = texture;
                this.smooth = smooth;
                this.repeat = repeat;
                this.mipmap = mipmap;
            }
            Object.defineProperty(TextureMultiPassMaterial.prototype, "animateUVs", {
                get: /**
                * Specifies whether or not the UV coordinates should be animated using a transformation matrix.
                */
                function () {
                    return this._animateUVs;
                },
                set: function (value) {
                    this._animateUVs = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMultiPassMaterial.prototype, "texture", {
                get: /**
                * The texture object to use for the albedo colour.
                */
                function () {
                    return this.diffuseMethod.texture;
                },
                set: function (value) {
                    this.diffuseMethod.texture = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMultiPassMaterial.prototype, "ambientTexture", {
                get: /**
                * The texture object to use for the ambient colour.
                */
                function () {
                    return this.ambientMethod.texture;
                },
                set: function (value) {
                    this.ambientMethod.texture = value;
                    this.diffuseMethod.iUseAmbientTexture = (value != null);
                },
                enumerable: true,
                configurable: true
            });


            TextureMultiPassMaterial.prototype.pUpdateScreenPasses = function () {
                _super.prototype.pUpdateScreenPasses.call(this);

                if (this._pEffectsPass)
                    this._pEffectsPass.animateUVs = this._animateUVs;
            };
            return TextureMultiPassMaterial;
        })(materials.MultiPassMaterialBase);
        materials.TextureMultiPassMaterial = TextureMultiPassMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * ColorMultiPassMaterial is a multi-pass material that uses a flat color as the surface's diffuse reflection value.
        */
        var ColorMultiPassMaterial = (function (_super) {
            __extends(ColorMultiPassMaterial, _super);
            /**
            * Creates a new ColorMultiPassMaterial object.
            *
            * @param color The material's diffuse surface color.
            */
            function ColorMultiPassMaterial(color) {
                if (typeof color === "undefined") { color = 0xcccccc; }
                _super.call(this);
                this.color = color;
            }
            Object.defineProperty(ColorMultiPassMaterial.prototype, "color", {
                get: /**
                * The diffuse reflectivity color of the surface.
                */
                function () {
                    return this.diffuseMethod.diffuseColor;
                },
                set: function (value) {
                    this.diffuseMethod.diffuseColor = value;
                },
                enumerable: true,
                configurable: true
            });

            return ColorMultiPassMaterial;
        })(materials.MultiPassMaterialBase);
        materials.ColorMultiPassMaterial = ColorMultiPassMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        //import away3d.*;
        //import away3d.textures.*;
        //import flash.display.*;
        //import flash.geom.*;
        //use namespace arcane;
        /**
        * TextureMaterial is a single-pass material that uses a texture to define the surface's diffuse reflection colour (albedo).
        */
        var TextureMaterial = (function (_super) {
            __extends(TextureMaterial, _super);
            /**
            * Creates a new TextureMaterial.
            * @param texture The texture used for the material's albedo color.
            * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.
            * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to true.
            * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to true.
            */
            function TextureMaterial(texture, smooth, repeat, mipmap) {
                if (typeof texture === "undefined") { texture = null; }
                if (typeof smooth === "undefined") { smooth = true; }
                if (typeof repeat === "undefined") { repeat = false; }
                if (typeof mipmap === "undefined") { mipmap = false; }
                _super.call(this);

                this.texture = texture;

                this.smooth = smooth;
                this.repeat = repeat;
                this.mipmap = mipmap;
            }
            Object.defineProperty(TextureMaterial.prototype, "animateUVs", {
                get: /**
                * Specifies whether or not the UV coordinates should be animated using IRenderable's uvTransform matrix.
                *
                * @see IRenderable.uvTransform
                */
                function () {
                    return this._pScreenPass.animateUVs;
                },
                set: function (value) {
                    this._pScreenPass.animateUVs = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMaterial.prototype, "alpha", {
                get: /**
                * The alpha of the surface.
                */
                function () {
                    return this._pScreenPass.colorTransform ? this._pScreenPass.colorTransform.alphaMultiplier : 1;
                },
                set: function (value) {
                    if (value > 1)
                        value = 1;
else if (value < 0)
                        value = 0;

                    if (this.colorTransform == null) {
                        //colorTransform ||= new ColorTransform();
                        this.colorTransform = new away.geom.ColorTransform();
                    }

                    this.colorTransform.alphaMultiplier = value;

                    this._pScreenPass.preserveAlpha = this.getRequiresBlending();

                    this._pScreenPass.setBlendMode(this.getBlendMode() == away.base.BlendMode.NORMAL && this.getRequiresBlending() ? away.base.BlendMode.LAYER : this.getBlendMode());
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMaterial.prototype, "texture", {
                get: /**
                * The texture object to use for the albedo colour.
                */
                function () {
                    return this._pScreenPass.diffuseMethod.texture;
                },
                set: function (value) {
                    this._pScreenPass.diffuseMethod.texture = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMaterial.prototype, "ambientTexture", {
                get: /**
                * The texture object to use for the ambient colour.
                */
                function () {
                    return this._pScreenPass.ambientMethod.texture;
                },
                set: function (value) {
                    this._pScreenPass.ambientMethod.texture = value;
                    this._pScreenPass.diffuseMethod.iUseAmbientTexture = !(value == null);
                },
                enumerable: true,
                configurable: true
            });

            return TextureMaterial;
        })(materials.SinglePassMaterialBase);
        materials.TextureMaterial = TextureMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * ColorMaterial is a single-pass material that uses a flat color as the surface's diffuse reflection value.
        */
        var ColorMaterial = (function (_super) {
            __extends(ColorMaterial, _super);
            /**
            * Creates a new ColorMaterial object.
            * @param color The material's diffuse surface color.
            * @param alpha The material's surface alpha.
            */
            function ColorMaterial(color, alpha) {
                if (typeof color === "undefined") { color = 0xcccccc; }
                if (typeof alpha === "undefined") { alpha = 1; }
                _super.call(this);
                this._diffuseAlpha = 1;

                this.color = color;
                this.alpha = alpha;
            }
            Object.defineProperty(ColorMaterial.prototype, "alpha", {
                get: /**
                * The alpha of the surface.
                */
                function () {
                    return this._pScreenPass.diffuseMethod.diffuseAlpha;
                },
                set: function (value) {
                    if (value > 1) {
                        value = 1;
                    } else if (value < 0) {
                        value = 0;
                    }

                    this._pScreenPass.diffuseMethod.diffuseAlpha = this._diffuseAlpha = value;
                    this._pScreenPass.preserveAlpha = this.requiresBlending;
                    this._pScreenPass.setBlendMode(this.getBlendMode() == away.base.BlendMode.NORMAL && this.requiresBlending ? away.base.BlendMode.LAYER : this.getBlendMode());
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ColorMaterial.prototype, "color", {
                get: /**
                * The diffuse reflectivity color of the surface.
                */
                function () {
                    return this._pScreenPass.diffuseMethod.diffuseColor;
                },
                set: function (value) {
                    this._pScreenPass.diffuseMethod.diffuseColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ColorMaterial.prototype, "requiresBlending", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this.getRequiresBlending() || this._diffuseAlpha < 1;
                },
                enumerable: true,
                configurable: true
            });
            return ColorMaterial;
        })(materials.SinglePassMaterialBase);
        materials.ColorMaterial = ColorMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        /**
        * LightingShaderCompiler is a ShaderCompiler that generates code for passes performing shading only (no effect passes)
        */
        var LightingShaderCompiler = (function (_super) {
            __extends(LightingShaderCompiler, _super);
            //use namespace arcane;
            /**
            * Create a new LightingShaderCompiler object.
            * @param profile The compatibility profile of the renderer.
            */
            function LightingShaderCompiler(profile) {
                _super.call(this, profile);
            }
            Object.defineProperty(LightingShaderCompiler.prototype, "lightVertexConstantIndex", {
                get: /**
                * The starting index if the vertex constant to which light data needs to be uploaded.
                */
                function () {
                    return this._lightVertexConstantIndex;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pInitRegisterIndices = function () {
                _super.prototype.pInitRegisterIndices.call(this);
                this._lightVertexConstantIndex = -1;
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCreateNormalRegisters = function () {
                if (this.tangentSpace) {
                    this._pSharedRegisters.animatedTangent = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedTangent, 1);
                    this._pSharedRegisters.bitangent = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.bitangent, 1);

                    this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
                    this._pTangentBufferIndex = this._pSharedRegisters.tangentInput.index;

                    this._pAnimatableAttributes.push(this._pSharedRegisters.tangentInput.toString());
                    this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedTangent.toString());
                }

                this._pSharedRegisters.normalInput = this._pRegisterCache.getFreeVertexAttribute();
                this._pNormalBufferIndex = this._pSharedRegisters.normalInput.index;

                this._pSharedRegisters.animatedNormal = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedNormal, 1);

                this._pAnimatableAttributes.push(this._pSharedRegisters.normalInput.toString());
                this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedNormal.toString());
            };

            Object.defineProperty(LightingShaderCompiler.prototype, "tangentSpace", {
                get: /**
                * Indicates whether or not lighting happens in tangent space. This is only the case if no world-space
                * dependencies exist.
                */
                function () {
                    return this._pNumLightProbes == 0 && this._pMethodSetup._iNormalMethod.iHasOutput && this._pMethodSetup._iNormalMethod.iTangentSpace;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pInitLightData = function () {
                _super.prototype.pInitLightData.call(this);

                this._pointLightVertexConstants = new Array(this._pNumPointLights);
                this._pointLightFragmentConstants = new Array(this._pNumPointLights * 2);

                if (this.tangentSpace) {
                    this._dirLightVertexConstants = new Array(this._pNumDirectionalLights);
                    this._dirLightFragmentConstants = new Array(this._pNumDirectionalLights * 2);
                } else {
                    this._dirLightFragmentConstants = new Array(this._pNumDirectionalLights * 3);
                }
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCalculateDependencies = function () {
                _super.prototype.pCalculateDependencies.call(this);

                if (!this.tangentSpace) {
                    this._pDependencyCounter.addWorldSpaceDependencies(false);
                }
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCompileNormalCode = function () {
                this._pSharedRegisters.normalFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.normalFragment, this._pDependencyCounter.normalDependencies);

                if (this._pMethodSetup._iNormalMethod.iHasOutput && !this._pMethodSetup._iNormalMethod.iTangentSpace) {
                    this._pVertexCode += this._pMethodSetup._iNormalMethod.iGetVertexCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iNormalMethod.iGetFragmentCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache, this._pSharedRegisters.normalFragment);

                    return;
                }

                if (this.tangentSpace) {
                    this.compileTangentSpaceNormalMapCode();
                } else {
                    var normalMatrix = new Array(3);
                    normalMatrix[0] = this._pRegisterCache.getFreeVertexConstant();
                    normalMatrix[1] = this._pRegisterCache.getFreeVertexConstant();
                    normalMatrix[2] = this._pRegisterCache.getFreeVertexConstant();

                    this._pRegisterCache.getFreeVertexConstant();

                    this._pSceneNormalMatrixIndex = normalMatrix[0].index * 4;
                    this._pSharedRegisters.normalVarying = this._pRegisterCache.getFreeVarying();

                    // no output, world space is enough
                    this._pVertexCode += "m33 " + this._pSharedRegisters.normalVarying + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" + "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.animatedNormal + ".w	\n";

                    this._pFragmentCode += "nrm " + this._pSharedRegisters.normalFragment + ".xyz, " + this._pSharedRegisters.normalVarying + "\n" + "mov " + this._pSharedRegisters.normalFragment + ".w, " + this._pSharedRegisters.normalVarying + ".w		\n";
                }

                if (this._pDependencyCounter.tangentDependencies > 0) {
                    this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
                    this._pTangentBufferIndex = this._pSharedRegisters.tangentInput.index;
                    this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();
                }
            };

            /**
            * Generates code to retrieve the tangent space normal from the normal map
            */
            LightingShaderCompiler.prototype.compileTangentSpaceNormalMapCode = function () {
                // normalize normal + tangent vector and generate (approximated) bitangent
                this._pVertexCode += "nrm " + this._pSharedRegisters.animatedNormal + ".xyz, " + this._pSharedRegisters.animatedNormal + "\n" + "nrm " + this._pSharedRegisters.animatedTangent + ".xyz, " + this._pSharedRegisters.animatedTangent + "\n";
                this._pVertexCode += "crs " + this._pSharedRegisters.bitangent + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + this._pSharedRegisters.animatedTangent + "\n";

                this._pFragmentCode += this._pMethodSetup._iNormalMethod.iGetFragmentCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache, this._pSharedRegisters.normalFragment);

                if (this._pMethodSetup._iNormalMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._pMethodSetup._iNormalMethodVO.needsGlobalFragmentPos || this._pMethodSetup._iNormalMethodVO.needsGlobalVertexPos) {
                    this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
                }
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCompileViewDirCode = function () {
                var cameraPositionReg = this._pRegisterCache.getFreeVertexConstant();
                this._pSharedRegisters.viewDirVarying = this._pRegisterCache.getFreeVarying();
                this._pSharedRegisters.viewDirFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.viewDirFragment, this._pDependencyCounter.viewDirDependencies);

                this._pCameraPositionIndex = cameraPositionReg.index * 4;

                if (this.tangentSpace) {
                    var temp = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pVertexCode += "sub " + temp + ", " + cameraPositionReg + ", " + this._pSharedRegisters.localPosition + "\n" + "m33 " + this._pSharedRegisters.viewDirVarying + ".xyz, " + temp + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + this._pSharedRegisters.viewDirVarying + ".w, " + this._pSharedRegisters.localPosition + ".w\n";
                } else {
                    this._pVertexCode += "sub " + this._pSharedRegisters.viewDirVarying + ", " + cameraPositionReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
                    this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
                }

                this._pFragmentCode += "nrm " + this._pSharedRegisters.viewDirFragment + ".xyz, " + this._pSharedRegisters.viewDirVarying + "\n" + "mov " + this._pSharedRegisters.viewDirFragment + ".w,   " + this._pSharedRegisters.viewDirVarying + ".w 		\n";
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCompileLightingCode = function () {
                if (this._pMethodSetup._iShadowMethod)
                    this.compileShadowCode();

                this._pMethodSetup._iDiffuseMethod.iShadowRegister = this._shadowRegister;

                this._pSharedRegisters.shadedTarget = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.shadedTarget, 1);

                this._pVertexCode += this._pMethodSetup._iDiffuseMethod.iGetVertexCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentPreLightingCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache);

                if (this._usingSpecularMethod) {
                    this._pVertexCode += this._pMethodSetup._iSpecularMethod.iGetVertexCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentPreLightingCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache);
                }

                if (this.pUsesLights()) {
                    this.initLightRegisters();
                    this.compileDirectionalLightCode();
                    this.compilePointLightCode();
                }

                if (this.pUsesProbes())
                    this.compileLightProbeCode();

                // only need to create and reserve _shadedTargetReg here, no earlier?
                this._pVertexCode += this._pMethodSetup._iAmbientMethod.iGetVertexCode(this._pMethodSetup._iAmbientMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iAmbientMethod.iGetFragmentCode(this._pMethodSetup._iAmbientMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                if (this._pMethodSetup._iAmbientMethodVO.needsNormals) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                }

                if (this._pMethodSetup._iAmbientMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentPostLightingCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                if (this._pAlphaPremultiplied) {
                    this._pFragmentCode += "add " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.commons + ".z\n" + "div " + this._pSharedRegisters.shadedTarget + ".xyz, " + this._pSharedRegisters.shadedTarget + ", " + this._pSharedRegisters.shadedTarget + ".w\n" + "sub " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.commons + ".z\n" + "sat " + this._pSharedRegisters.shadedTarget + ".xyz, " + this._pSharedRegisters.shadedTarget + "\n";
                }

                if (this._pMethodSetup._iDiffuseMethodVO.needsNormals)
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                if (this._pMethodSetup._iDiffuseMethodVO.needsView)
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);

                if (this._usingSpecularMethod) {
                    this._pMethodSetup._iSpecularMethod.iShadowRegister = this._shadowRegister;
                    this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentPostLightingCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);
                    if (this._pMethodSetup._iSpecularMethodVO.needsNormals)
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                    if (this._pMethodSetup._iSpecularMethodVO.needsView)
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._pMethodSetup._iShadowMethod) {
                    this._pRegisterCache.removeFragmentTempUsage(this._shadowRegister);
                }
            };

            /**
            * Provides the code to provide shadow mapping.
            */
            LightingShaderCompiler.prototype.compileShadowCode = function () {
                if (this._pSharedRegisters.normalFragment)
                    this._shadowRegister = this._pSharedRegisters.normalFragment;
else
                    this._shadowRegister = this._pRegisterCache.getFreeFragmentVectorTemp();

                this._pRegisterCache.addFragmentTempUsages(this._shadowRegister, 1);

                this._pVertexCode += this._pMethodSetup._iShadowMethod.iGetVertexCode(this._pMethodSetup._iShadowMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iShadowMethod.iGetFragmentCode(this._pMethodSetup._iShadowMethodVO, this._pRegisterCache, this._shadowRegister);
            };

            /**
            * Initializes constant registers to contain light data.
            */
            LightingShaderCompiler.prototype.initLightRegisters = function () {
                // init these first so we're sure they're in sequence
                var i, len;

                if (this._dirLightVertexConstants) {
                    len = this._dirLightVertexConstants.length;

                    for (i = 0; i < len; ++i) {
                        this._dirLightVertexConstants[i] = this._pRegisterCache.getFreeVertexConstant();

                        if (this._lightVertexConstantIndex == -1) {
                            this._lightVertexConstantIndex = this._dirLightVertexConstants[i].index * 4;
                        }
                    }
                }

                len = this._pointLightVertexConstants.length;
                for (i = 0; i < len; ++i) {
                    this._pointLightVertexConstants[i] = this._pRegisterCache.getFreeVertexConstant();

                    if (this._lightVertexConstantIndex == -1) {
                        this._lightVertexConstantIndex = this._pointLightVertexConstants[i].index * 4;
                    }
                }

                len = this._dirLightFragmentConstants.length;
                for (i = 0; i < len; ++i) {
                    this._dirLightFragmentConstants[i] = this._pRegisterCache.getFreeFragmentConstant();

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = this._dirLightFragmentConstants[i].index * 4;
                    }
                }

                len = this._pointLightFragmentConstants.length;

                for (i = 0; i < len; ++i) {
                    this._pointLightFragmentConstants[i] = this._pRegisterCache.getFreeFragmentConstant();
                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = this._pointLightFragmentConstants[i].index * 4;
                    }
                }
            };

            /**
            * Compiles the shading code for directional lights.
            */
            LightingShaderCompiler.prototype.compileDirectionalLightCode = function () {
                var diffuseColorReg;
                var specularColorReg;
                var lightDirReg;
                var vertexRegIndex = 0;
                var fragmentRegIndex = 0;
                var addSpec = this._usingSpecularMethod && this.pUsesLightsForSpecular();
                var addDiff = this.pUsesLightsForDiffuse();

                if (!(addSpec || addDiff))
                    return;

                for (var i = 0; i < this._pNumDirectionalLights; ++i) {
                    if (this.tangentSpace) {
                        lightDirReg = this._dirLightVertexConstants[vertexRegIndex++];

                        var lightVarying = this._pRegisterCache.getFreeVarying();

                        this._pVertexCode += "m33 " + lightVarying + ".xyz, " + lightDirReg + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + lightVarying + ".w, " + lightDirReg + ".w\n";

                        lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();
                        this._pRegisterCache.addVertexTempUsages(lightDirReg, 1);
                        this._pFragmentCode += "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n";
                        this._pFragmentCode += "mov " + lightDirReg + ".w, " + lightVarying + ".w\n";
                    } else {
                        lightDirReg = this._dirLightFragmentConstants[fragmentRegIndex++];
                    }

                    diffuseColorReg = this._dirLightFragmentConstants[fragmentRegIndex++];
                    specularColorReg = this._dirLightFragmentConstants[fragmentRegIndex++];
                    if (addDiff) {
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerLight(this._pMethodSetup._iDiffuseMethodVO, lightDirReg, diffuseColorReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerLight(this._pMethodSetup._iSpecularMethodVO, lightDirReg, specularColorReg, this._pRegisterCache);
                    }

                    if (this.tangentSpace)
                        this._pRegisterCache.removeVertexTempUsage(lightDirReg);
                }
            };

            /**
            * Compiles the shading code for point lights.
            */
            LightingShaderCompiler.prototype.compilePointLightCode = function () {
                var diffuseColorReg;
                var specularColorReg;
                var lightPosReg;
                var lightDirReg;
                var vertexRegIndex = 0;
                var fragmentRegIndex = 0;
                var addSpec = this._usingSpecularMethod && this.pUsesLightsForSpecular();
                var addDiff = this.pUsesLightsForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                for (var i = 0; i < this._pNumPointLights; ++i) {
                    lightPosReg = this._pointLightVertexConstants[vertexRegIndex++];
                    diffuseColorReg = this._pointLightFragmentConstants[fragmentRegIndex++];
                    specularColorReg = this._pointLightFragmentConstants[fragmentRegIndex++];
                    lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();

                    this._pRegisterCache.addFragmentTempUsages(lightDirReg, 1);

                    var lightVarying = this._pRegisterCache.getFreeVarying();
                    if (this.tangentSpace) {
                        var temp = this._pRegisterCache.getFreeVertexVectorTemp();
                        this._pVertexCode += "sub " + temp + ", " + lightPosReg + ", " + this._pSharedRegisters.localPosition + "\n" + "m33 " + lightVarying + ".xyz, " + temp + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + lightVarying + ".w, " + this._pSharedRegisters.localPosition + ".w\n";
                    } else {
                        this._pVertexCode += "sub " + lightVarying + ", " + lightPosReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
                    }

                    if (this._pEnableLightFallOff && this._pProfile != "baselineConstrained") {
                        // calculate attenuation
                        this._pFragmentCode += "dp3 " + lightDirReg + ".w, " + lightVarying + ", " + lightVarying + "\n" + "sub " + lightDirReg + ".w, " + lightDirReg + ".w, " + diffuseColorReg + ".w\n" + "mul " + lightDirReg + ".w, " + lightDirReg + ".w, " + specularColorReg + ".w\n" + "sat " + lightDirReg + ".w, " + lightDirReg + ".w\n" + "sub " + lightDirReg + ".w, " + this._pSharedRegisters.commons + ".w, " + lightDirReg + ".w\n" + "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n";
                    } else {
                        this._pFragmentCode += "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n" + "mov " + lightDirReg + ".w, " + lightVarying + ".w\n";
                    }

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = lightPosReg.index * 4;
                    }

                    if (addDiff) {
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerLight(this._pMethodSetup._iDiffuseMethodVO, lightDirReg, diffuseColorReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerLight(this._pMethodSetup._iSpecularMethodVO, lightDirReg, specularColorReg, this._pRegisterCache);
                    }

                    this._pRegisterCache.removeFragmentTempUsage(lightDirReg);
                }
            };

            /**
            * Compiles shading code for light probes.
            */
            LightingShaderCompiler.prototype.compileLightProbeCode = function () {
                var weightReg;
                var weightComponents = [".x", ".y", ".z", ".w"];
                var weightRegisters = new Array();
                var i;
                var texReg;
                var addSpec = this._usingSpecularMethod && this.pUsesProbesForSpecular();
                var addDiff = this.pUsesProbesForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                if (addDiff) {
                    this._pLightProbeDiffuseIndices = new Array();
                }
                if (addSpec) {
                    this._pLightProbeSpecularIndices = new Array();
                }

                for (i = 0; i < this._pNumProbeRegisters; ++i) {
                    weightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();
                    if (i == 0) {
                        this._pProbeWeightsIndex = weightRegisters[i].index * 4;
                    }
                }

                for (i = 0; i < this._pNumLightProbes; ++i) {
                    weightReg = weightRegisters[Math.floor(i / 4)].toString() + weightComponents[i % 4];

                    if (addDiff) {
                        texReg = this._pRegisterCache.getFreeTextureReg();
                        this._pLightProbeDiffuseIndices[i] = texReg.index;
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerProbe(this._pMethodSetup._iDiffuseMethodVO, texReg, weightReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        texReg = this._pRegisterCache.getFreeTextureReg();
                        this._pLightProbeSpecularIndices[i] = texReg.index;
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerProbe(this._pMethodSetup._iSpecularMethodVO, texReg, weightReg, this._pRegisterCache);
                    }
                }
            };
            return LightingShaderCompiler;
        })(materials.ShaderCompiler);
        materials.LightingShaderCompiler = LightingShaderCompiler;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * SegmentMaterial is a material exclusively used to render wireframe objects
        *
        * @see away3d.entities.Lines
        */
        var SegmentMaterial = (function (_super) {
            __extends(SegmentMaterial, _super);
            /**
            * Creates a new SegmentMaterial object.
            *
            * @param thickness The thickness of the wireframe lines.
            */
            function SegmentMaterial(thickness) {
                if (typeof thickness === "undefined") { thickness = 1.25; }
                _super.call(this);

                this.bothSides = true;
                this.pAddPass(this._screenPass = new materials.SegmentPass(thickness));
                this._screenPass.material = this;
            }
            return SegmentMaterial;
        })(materials.MaterialBase);
        materials.SegmentMaterial = SegmentMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * SkyboxMaterial is a material exclusively used to render skyboxes
        *
        * @see away3d.primitives.Skybox
        */
        var SkyboxMaterial = (function (_super) {
            __extends(SkyboxMaterial, _super);
            /**
            * Creates a new SkyboxMaterial object.
            * @param cubeMap The CubeMap to use as the skybox.
            */
            function SkyboxMaterial(cubeMap) {
                _super.call(this);

                this._cubeMap = cubeMap;
                this.pAddPass(this._skyboxPass = new materials.SkyboxPass());
                this._skyboxPass.cubeTexture = this._cubeMap;
            }
            Object.defineProperty(SkyboxMaterial.prototype, "cubeMap", {
                get: /**
                * The cube texture to use as the skybox.
                */
                function () {
                    return this._cubeMap;
                },
                set: function (value) {
                    if (value && this._cubeMap && (value.hasMipMaps != this._cubeMap.hasMipMaps || value.format != this._cubeMap.format))
                        this.iInvalidatePasses(null);

                    this._cubeMap = value;
                    this._skyboxPass.cubeTexture = this._cubeMap;
                },
                enumerable: true,
                configurable: true
            });

            return SkyboxMaterial;
        })(materials.MaterialBase);
        materials.SkyboxMaterial = SkyboxMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //import away3d.arcane;
        //import away3d.core.base.CompactSubGeometry;
        //import away3d.core.base.Geometry;
        //import away3d.core.base.ISubGeometry;
        //import away3d.errors.AbstractMethodError;
        //import flash.geom.Matrix3D;
        //use namespace arcane;
        /**
        * PrimitiveBase is an abstract base class for mesh primitives, which are prebuilt simple meshes.
        */
        var PrimitiveBase = (function (_super) {
            __extends(PrimitiveBase, _super);
            /**
            * Creates a new PrimitiveBase object.
            * @param material The material with which to render the object
            */
            function PrimitiveBase() {
                _super.call(this);
                this._geomDirty = true;
                this._uvDirty = true;

                this._subGeometry = new away.base.CompactSubGeometry();
                this._subGeometry.autoGenerateDummyUVs = false;
                this.addSubGeometry(this._subGeometry);
            }
            Object.defineProperty(PrimitiveBase.prototype, "subGeometries", {
                get: /**
                * @inheritDoc
                */
                function () {
                    if (this._geomDirty)
                        this.updateGeometry();

                    if (this._uvDirty)
                        this.updateUVs();

                    return _super.prototype.getSubGeometries.call(this);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            PrimitiveBase.prototype.clone = function () {
                if (this._geomDirty)
                    this.updateGeometry();

                if (this._uvDirty)
                    this.updateUVs();

                return _super.prototype.clone.call(this);
            };

            /**
            * @inheritDoc
            */
            PrimitiveBase.prototype.scale = function (scale) {
                if (this._geomDirty)
                    this.updateGeometry();

                _super.prototype.scale.call(this, scale);
            };

            /**
            * @inheritDoc
            */
            PrimitiveBase.prototype.scaleUV = function (scaleU, scaleV) {
                if (typeof scaleU === "undefined") { scaleU = 1; }
                if (typeof scaleV === "undefined") { scaleV = 1; }
                if (this._uvDirty)
                    this.updateUVs();

                _super.prototype.scaleUV.call(this, scaleU, scaleV);
            };

            /**
            * @inheritDoc
            */
            PrimitiveBase.prototype.applyTransformation = function (transform) {
                if (this._geomDirty)
                    this.updateGeometry();

                _super.prototype.applyTransformation.call(this, transform);
            };

            /**
            * Builds the primitive's geometry when invalid. This method should not be called directly. The calling should
            * be triggered by the invalidateGeometry method (and in turn by updateGeometry).
            */
            PrimitiveBase.prototype.pBuildGeometry = function (target) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Builds the primitive's uv coordinates when invalid. This method should not be called directly. The calling
            * should be triggered by the invalidateUVs method (and in turn by updateUVs).
            */
            PrimitiveBase.prototype.pBuildUVs = function (target) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Invalidates the primitive's geometry, causing it to be updated when requested.
            */
            PrimitiveBase.prototype.pInvalidateGeometry = function () {
                this._geomDirty = true;
            };

            /**
            * Invalidates the primitive's uv coordinates, causing them to be updated when requested.
            */
            PrimitiveBase.prototype.pInvalidateUVs = function () {
                this._uvDirty = true;
            };

            /**
            * Updates the geometry when invalid.
            */
            PrimitiveBase.prototype.updateGeometry = function () {
                this.pBuildGeometry(this._subGeometry);
                this._geomDirty = false;
            };

            /**
            * Updates the uv coordinates when invalid.
            */
            PrimitiveBase.prototype.updateUVs = function () {
                this.pBuildUVs(this._subGeometry);
                this._uvDirty = false;
            };

            PrimitiveBase.prototype.iValidate = function () {
                if (this._geomDirty)
                    this.updateGeometry();

                if (this._uvDirty)
                    this.updateUVs();
            };
            return PrimitiveBase;
        })(away.base.Geometry);
        primitives.PrimitiveBase = PrimitiveBase;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        var LineSegment = (function (_super) {
            __extends(LineSegment, _super);
            function LineSegment(v0, v1, color0, color1, thickness) {
                if (typeof color0 === "undefined") { color0 = 0x333333; }
                if (typeof color1 === "undefined") { color1 = 0x333333; }
                if (typeof thickness === "undefined") { thickness = 1; }
                _super.call(this, v0, v1, null, color0, color1, thickness);
                this.TYPE = "line";
            }
            return LineSegment;
        })(away.base.Segment);
        primitives.LineSegment = LineSegment;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //import away3d.arcane;
        //import away3d.core.base.CompactSubGeometry;
        //use namespace arcane;
        /**
        * A UV Cylinder primitive mesh.
        */
        var TorusGeometry = (function (_super) {
            __extends(TorusGeometry, _super);
            /**
            * Creates a new <code>Torus</code> object.
            * @param radius The radius of the torus.
            * @param tuebRadius The radius of the inner tube of the torus.
            * @param segmentsR Defines the number of horizontal segments that make up the torus.
            * @param segmentsT Defines the number of vertical segments that make up the torus.
            * @param yUp Defines whether the torus poles should lay on the Y-axis (true) or on the Z-axis (false).
            */
            function TorusGeometry(radius, tubeRadius, segmentsR, segmentsT, yUp) {
                if (typeof radius === "undefined") { radius = 50; }
                if (typeof tubeRadius === "undefined") { tubeRadius = 50; }
                if (typeof segmentsR === "undefined") { segmentsR = 16; }
                if (typeof segmentsT === "undefined") { segmentsT = 8; }
                if (typeof yUp === "undefined") { yUp = true; }
                _super.call(this);
                this._nextVertexIndex = 0;
                this._currentIndex = 0;
                this._currentTriangleIndex = 0;
                this._numVertices = 0;

                this._radius = radius;
                this._tubeRadius = tubeRadius;
                this._segmentsR = segmentsR;
                this._segmentsT = segmentsT;
                this._yUp = yUp;
            }
            TorusGeometry.prototype.addVertex = function (px, py, pz, nx, ny, nz, tx, ty, tz) {
                var compVertInd = this._vertexOffset + this._nextVertexIndex * this._vertexStride;
                this._rawVertexData[compVertInd++] = px;
                this._rawVertexData[compVertInd++] = py;
                this._rawVertexData[compVertInd++] = pz;
                this._rawVertexData[compVertInd++] = nx;
                this._rawVertexData[compVertInd++] = ny;
                this._rawVertexData[compVertInd++] = nz;
                this._rawVertexData[compVertInd++] = tx;
                this._rawVertexData[compVertInd++] = ty;
                this._rawVertexData[compVertInd] = tz;
                this._nextVertexIndex++;
            };

            TorusGeometry.prototype.addTriangleClockWise = function (cwVertexIndex0, cwVertexIndex1, cwVertexIndex2) {
                this._rawIndices[this._currentIndex++] = cwVertexIndex0;
                this._rawIndices[this._currentIndex++] = cwVertexIndex1;
                this._rawIndices[this._currentIndex++] = cwVertexIndex2;
                this._currentTriangleIndex++;
            };

            /**
            * @inheritDoc
            */
            TorusGeometry.prototype.pBuildGeometry = function (target) {
                var i, j;
                var x, y, z, nx, ny, nz, revolutionAngleR, revolutionAngleT;
                var numTriangles;

                // reset utility variables
                this._numVertices = 0;
                this._nextVertexIndex = 0;
                this._currentIndex = 0;
                this._currentTriangleIndex = 0;
                this._vertexStride = target.vertexStride;
                this._vertexOffset = target.vertexOffset;

                // evaluate target number of vertices, triangles and indices
                this._numVertices = (this._segmentsT + 1) * (this._segmentsR + 1);
                numTriangles = this._segmentsT * this._segmentsR * 2;

                if (this._numVertices == target.numVertices) {
                    this._rawVertexData = target.vertexData;

                    if (target.indexData == null) {
                        this._rawIndices = new Array(numTriangles * 3);
                    } else {
                        this._rawIndices = target.indexData;
                    }
                } else {
                    var numVertComponents = this._numVertices * this._vertexStride;
                    this._rawVertexData = new Array(numVertComponents);
                    this._rawIndices = new Array(numTriangles * 3);
                    this.pInvalidateUVs();
                }

                // evaluate revolution steps
                var revolutionAngleDeltaR = 2 * Math.PI / this._segmentsR;
                var revolutionAngleDeltaT = 2 * Math.PI / this._segmentsT;

                var comp1, comp2;
                var t1, t2, n1, n2;
                var startIndex;

                // surface
                var a, b, c, d, length;

                for (j = 0; j <= this._segmentsT; ++j) {
                    startIndex = this._vertexOffset + this._nextVertexIndex * this._vertexStride;

                    for (i = 0; i <= this._segmentsR; ++i) {
                        // revolution vertex
                        revolutionAngleR = i * revolutionAngleDeltaR;
                        revolutionAngleT = j * revolutionAngleDeltaT;

                        length = Math.cos(revolutionAngleT);
                        nx = length * Math.cos(revolutionAngleR);
                        ny = length * Math.sin(revolutionAngleR);
                        nz = Math.sin(revolutionAngleT);

                        x = this._radius * Math.cos(revolutionAngleR) + this._tubeRadius * nx;
                        y = this._radius * Math.sin(revolutionAngleR) + this._tubeRadius * ny;
                        z = (j == this._segmentsT) ? 0 : this._tubeRadius * nz;

                        if (this._yUp) {
                            n1 = -nz;
                            n2 = ny;
                            t1 = 0;
                            t2 = (length ? nx / length : x / this._radius);
                            comp1 = -z;
                            comp2 = y;
                        } else {
                            n1 = ny;
                            n2 = nz;
                            t1 = (length ? nx / length : x / this._radius);
                            t2 = 0;
                            comp1 = y;
                            comp2 = z;
                        }

                        if (i == this._segmentsR) {
                            this.addVertex(x, this._rawVertexData[startIndex + 1], this._rawVertexData[startIndex + 2], nx, n1, n2, -(length ? ny / length : y / this._radius), t1, t2);
                        } else {
                            this.addVertex(x, comp1, comp2, nx, n1, n2, -(length ? ny / length : y / this._radius), t1, t2);
                        }

                        if (i > 0 && j > 0) {
                            a = this._nextVertexIndex - 1;
                            b = this._nextVertexIndex - 2;
                            c = b - this._segmentsR - 1;
                            d = a - this._segmentsR - 1;
                            this.addTriangleClockWise(a, b, c);
                            this.addTriangleClockWise(a, c, d);
                        }
                    }
                }

                // build real data from raw data
                target.updateData(this._rawVertexData);
                target.updateIndexData(this._rawIndices);
            };

            /**
            * @inheritDoc
            */
            TorusGeometry.prototype.pBuildUVs = function (target) {
                var i, j;
                var data;
                var stride = target.UVStride;
                var offset = target.UVOffset;
                var skip = target.UVStride - 2;

                // evaluate num uvs
                var numUvs = this._numVertices * stride;

                if (target.UVData && numUvs == target.UVData.length) {
                    data = target.UVData;
                } else {
                    data = new Array(numUvs);
                    this.pInvalidateGeometry();
                }

                // current uv component index
                var currentUvCompIndex = offset;

                for (j = 0; j <= this._segmentsT; ++j) {
                    for (i = 0; i <= this._segmentsR; ++i) {
                        // revolution vertex
                        data[currentUvCompIndex++] = (i / this._segmentsR) * target.scaleU;
                        data[currentUvCompIndex++] = (j / this._segmentsT) * target.scaleV;
                        currentUvCompIndex += skip;
                    }
                }

                // build real data from raw data
                target.updateData(data);
            };

            Object.defineProperty(TorusGeometry.prototype, "radius", {
                get: /**
                * The radius of the torus.
                */
                function () {
                    return this._radius;
                },
                set: function (value) {
                    this._radius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TorusGeometry.prototype, "tubeRadius", {
                get: /**
                * The radius of the inner tube of the torus.
                */
                function () {
                    return this._tubeRadius;
                },
                set: function (value) {
                    this._tubeRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TorusGeometry.prototype, "segmentsR", {
                get: /**
                * Defines the number of horizontal segments that make up the torus. Defaults to 16.
                */
                function () {
                    return this._segmentsR;
                },
                set: function (value) {
                    this._segmentsR = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TorusGeometry.prototype, "segmentsT", {
                get: /**
                * Defines the number of vertical segments that make up the torus. Defaults to 8.
                */
                function () {
                    return this._segmentsT;
                },
                set: function (value) {
                    this._segmentsT = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TorusGeometry.prototype, "yUp", {
                get: /**
                * Defines whether the torus poles should lay on the Y-axis (true) or on the Z-axis (false).
                */
                function () {
                    return this._yUp;
                },
                set: function (value) {
                    this._yUp = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });

            return TorusGeometry;
        })(away.primitives.PrimitiveBase);
        primitives.TorusGeometry = TorusGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //import away3d.arcane;
        //import away3d.core.base.CompactSubGeometry;
        //use namespace arcane;
        /**
        * A Cube primitive mesh.
        */
        var CubeGeometry = (function (_super) {
            __extends(CubeGeometry, _super);
            /**
            * Creates a new Cube object.
            * @param width The size of the cube along its X-axis.
            * @param height The size of the cube along its Y-axis.
            * @param depth The size of the cube along its Z-axis.
            * @param segmentsW The number of segments that make up the cube along the X-axis.
            * @param segmentsH The number of segments that make up the cube along the Y-axis.
            * @param segmentsD The number of segments that make up the cube along the Z-axis.
            * @param tile6 The type of uv mapping to use. When true, a texture will be subdivided in a 2x3 grid, each used for a single face. When false, the entire image is mapped on each face.
            */
            function CubeGeometry(width, height, depth, segmentsW, segmentsH, segmentsD, tile6) {
                if (typeof width === "undefined") { width = 100; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof depth === "undefined") { depth = 100; }
                if (typeof segmentsW === "undefined") { segmentsW = 1; }
                if (typeof segmentsH === "undefined") { segmentsH = 1; }
                if (typeof segmentsD === "undefined") { segmentsD = 1; }
                if (typeof tile6 === "undefined") { tile6 = true; }
                _super.call(this);

                this._width = width;
                this._height = height;
                this._depth = depth;
                this._segmentsW = segmentsW;
                this._segmentsH = segmentsH;
                this._segmentsD = segmentsD;
                this._tile6 = tile6;
            }
            Object.defineProperty(CubeGeometry.prototype, "width", {
                get: /**
                * The size of the cube along its X-axis.
                */
                function () {
                    return this._width;
                },
                set: function (value) {
                    this._width = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CubeGeometry.prototype, "height", {
                get: /**
                * The size of the cube along its Y-axis.
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    this._height = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CubeGeometry.prototype, "depth", {
                get: /**
                * The size of the cube along its Z-axis.
                */
                function () {
                    return this._depth;
                },
                set: function (value) {
                    this._depth = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CubeGeometry.prototype, "tile6", {
                get: /**
                * The type of uv mapping to use. When false, the entire image is mapped on each face.
                * When true, a texture will be subdivided in a 3x2 grid, each used for a single face.
                * Reading the tiles from left to right, top to bottom they represent the faces of the
                * cube in the following order: bottom, top, back, left, front, right. This creates
                * several shared edges (between the top, front, left and right faces) which simplifies
                * texture painting.
                */
                function () {
                    return this._tile6;
                },
                set: function (value) {
                    this._tile6 = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CubeGeometry.prototype, "segmentsW", {
                get: /**
                * The number of segments that make up the cube along the X-axis. Defaults to 1.
                */
                function () {
                    return this._segmentsW;
                },
                set: function (value) {
                    this._segmentsW = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CubeGeometry.prototype, "segmentsH", {
                get: /**
                * The number of segments that make up the cube along the Y-axis. Defaults to 1.
                */
                function () {
                    return this._segmentsH;
                },
                set: function (value) {
                    this._segmentsH = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CubeGeometry.prototype, "segmentsD", {
                get: /**
                * The number of segments that make up the cube along the Z-axis. Defaults to 1.
                */
                function () {
                    return this._segmentsD;
                },
                set: function (value) {
                    this._segmentsD = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            CubeGeometry.prototype.pBuildGeometry = function (target) {
                var data;
                var indices/*uint*/ ;

                var tl, tr, bl, br;
                var i, j, inc = 0;

                var vidx, fidx;
                var hw, hh, hd;
                var dw, dh, dd;

                var outer_pos;

                var numVerts = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2;

                var stride = target.vertexStride;
                var skip = stride - 9;

                if (numVerts == target.numVertices) {
                    data = target.vertexData;

                    indices = (target.indexData) ? target.indexData : new Array((this._segmentsW * this._segmentsH + this._segmentsW * this._segmentsD + this._segmentsH * this._segmentsD) * 12);
                    //indices = target.indexData || new Vector.<uint>((_segmentsW*_segmentsH + _segmentsW*_segmentsD + _segmentsH*_segmentsD)*12, true);
                } else {
                    data = new Array(numVerts * stride);
                    indices = new Array((this._segmentsW * this._segmentsH + this._segmentsW * this._segmentsD + this._segmentsH * this._segmentsD) * 12);
                    this.pInvalidateUVs();
                }

                // Indices
                vidx = target.vertexOffset;
                fidx = 0;

                // half cube dimensions
                hw = this._width / 2;
                hh = this._height / 2;
                hd = this._depth / 2;

                // Segment dimensions
                dw = this._width / this._segmentsW;
                dh = this._height / this._segmentsH;
                dd = this._depth / this._segmentsD;

                for (i = 0; i <= this._segmentsW; i++) {
                    outer_pos = -hw + i * dw;

                    for (j = 0; j <= this._segmentsH; j++) {
                        // front
                        data[vidx++] = outer_pos;
                        data[vidx++] = -hh + j * dh;
                        data[vidx++] = -hd;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = -1;
                        data[vidx++] = 1;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        vidx += skip;

                        // back
                        data[vidx++] = outer_pos;
                        data[vidx++] = -hh + j * dh;
                        data[vidx++] = hd;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = 1;
                        data[vidx++] = -1;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        vidx += skip;

                        if (i && j) {
                            tl = 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
                            tr = 2 * (i * (this._segmentsH + 1) + (j - 1));
                            bl = tl + 2;
                            br = tr + 2;

                            indices[fidx++] = tl;
                            indices[fidx++] = bl;
                            indices[fidx++] = br;
                            indices[fidx++] = tl;
                            indices[fidx++] = br;
                            indices[fidx++] = tr;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = br + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tl + 1;
                        }
                    }
                }

                inc += 2 * (this._segmentsW + 1) * (this._segmentsH + 1);

                for (i = 0; i <= this._segmentsW; i++) {
                    outer_pos = -hw + i * dw;

                    for (j = 0; j <= this._segmentsD; j++) {
                        // top
                        data[vidx++] = outer_pos;
                        data[vidx++] = hh;
                        data[vidx++] = -hd + j * dd;
                        data[vidx++] = 0;
                        data[vidx++] = 1;
                        data[vidx++] = 0;
                        data[vidx++] = 1;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        vidx += skip;

                        // bottom
                        data[vidx++] = outer_pos;
                        data[vidx++] = -hh;
                        data[vidx++] = -hd + j * dd;
                        data[vidx++] = 0;
                        data[vidx++] = -1;
                        data[vidx++] = 0;
                        data[vidx++] = 1;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        vidx += skip;

                        if (i && j) {
                            tl = inc + 2 * ((i - 1) * (this._segmentsD + 1) + (j - 1));
                            tr = inc + 2 * (i * (this._segmentsD + 1) + (j - 1));
                            bl = tl + 2;
                            br = tr + 2;

                            indices[fidx++] = tl;
                            indices[fidx++] = bl;
                            indices[fidx++] = br;
                            indices[fidx++] = tl;
                            indices[fidx++] = br;
                            indices[fidx++] = tr;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = br + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tl + 1;
                        }
                    }
                }

                inc += 2 * (this._segmentsW + 1) * (this._segmentsD + 1);

                for (i = 0; i <= this._segmentsD; i++) {
                    outer_pos = hd - i * dd;

                    for (j = 0; j <= this._segmentsH; j++) {
                        // left
                        data[vidx++] = -hw;
                        data[vidx++] = -hh + j * dh;
                        data[vidx++] = outer_pos;
                        data[vidx++] = -1;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = -1;
                        vidx += skip;

                        // right
                        data[vidx++] = hw;
                        data[vidx++] = -hh + j * dh;
                        data[vidx++] = outer_pos;
                        data[vidx++] = 1;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = 1;
                        vidx += skip;

                        if (i && j) {
                            tl = inc + 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
                            tr = inc + 2 * (i * (this._segmentsH + 1) + (j - 1));
                            bl = tl + 2;
                            br = tr + 2;

                            indices[fidx++] = tl;
                            indices[fidx++] = bl;
                            indices[fidx++] = br;
                            indices[fidx++] = tl;
                            indices[fidx++] = br;
                            indices[fidx++] = tr;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = br + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tl + 1;
                        }
                    }
                }

                target.updateData(data);
                target.updateIndexData(indices);
            };

            /**
            * @inheritDoc
            */
            CubeGeometry.prototype.pBuildUVs = function (target) {
                var i, j, uidx;
                var data;

                var u_tile_dim, v_tile_dim;
                var u_tile_step, v_tile_step;
                var tl0u, tl0v;
                var tl1u, tl1v;
                var du, dv;
                var stride = target.UVStride;
                var numUvs = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2 * stride;
                var skip = stride - 2;

                if (target.UVData && numUvs == target.UVData.length)
                    data = target.UVData;
else {
                    data = new Array(numUvs);
                    this.pInvalidateGeometry();
                }

                if (this._tile6) {
                    u_tile_dim = u_tile_step = 1 / 3;
                    v_tile_dim = v_tile_step = 1 / 2;
                } else {
                    u_tile_dim = v_tile_dim = 1;
                    u_tile_step = v_tile_step = 0;
                }

                // Create planes two and two, the same way that they were
                // constructed in the buildGeometry() function. First calculate
                // the top-left UV coordinate for both planes, and then loop
                // over the points, calculating the UVs from these numbers.
                // When tile6 is true, the layout is as follows:
                //       .-----.-----.-----. (1,1)
                //       | Bot |  T  | Bak |
                //       |-----+-----+-----|
                //       |  L  |  F  |  R  |
                // (0,0)'-----'-----'-----'
                uidx = target.UVOffset;

                // FRONT / BACK
                tl0u = 1 * u_tile_step;
                tl0v = 1 * v_tile_step;
                tl1u = 2 * u_tile_step;
                tl1v = 0 * v_tile_step;
                du = u_tile_dim / this._segmentsW;
                dv = v_tile_dim / this._segmentsH;
                for (i = 0; i <= this._segmentsW; i++) {
                    for (j = 0; j <= this._segmentsH; j++) {
                        data[uidx++] = (tl0u + i * du) * target.scaleU;
                        data[uidx++] = (tl0v + (v_tile_dim - j * dv)) * target.scaleV;
                        uidx += skip;
                        data[uidx++] = (tl1u + (u_tile_dim - i * du)) * target.scaleU;
                        data[uidx++] = (tl1v + (v_tile_dim - j * dv)) * target.scaleV;
                        uidx += skip;
                    }
                }

                // TOP / BOTTOM
                tl0u = 1 * u_tile_step;
                tl0v = 0 * v_tile_step;
                tl1u = 0 * u_tile_step;
                tl1v = 0 * v_tile_step;
                du = u_tile_dim / this._segmentsW;
                dv = v_tile_dim / this._segmentsD;
                for (i = 0; i <= this._segmentsW; i++) {
                    for (j = 0; j <= this._segmentsD; j++) {
                        data[uidx++] = (tl0u + i * du) * target.scaleU;
                        data[uidx++] = (tl0v + (v_tile_dim - j * dv)) * target.scaleV;
                        uidx += skip;
                        data[uidx++] = (tl1u + i * du) * target.scaleU;
                        data[uidx++] = (tl1v + j * dv) * target.scaleV;
                        uidx += skip;
                    }
                }

                // LEFT / RIGHT
                tl0u = 0 * u_tile_step;
                tl0v = 1 * v_tile_step;
                tl1u = 2 * u_tile_step;
                tl1v = 1 * v_tile_step;
                du = u_tile_dim / this._segmentsD;
                dv = v_tile_dim / this._segmentsH;
                for (i = 0; i <= this._segmentsD; i++) {
                    for (j = 0; j <= this._segmentsH; j++) {
                        data[uidx++] = (tl0u + i * du) * target.scaleU;
                        ;
                        data[uidx++] = (tl0v + (v_tile_dim - j * dv)) * target.scaleV;
                        uidx += skip;
                        data[uidx++] = (tl1u + (u_tile_dim - i * du)) * target.scaleU;
                        data[uidx++] = (tl1v + (v_tile_dim - j * dv)) * target.scaleV;
                        uidx += skip;
                    }
                }

                target.updateData(data);
            };
            return CubeGeometry;
        })(away.primitives.PrimitiveBase);
        primitives.CubeGeometry = CubeGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        /**
        * A Plane primitive mesh.
        */
        var PlaneGeometry = (function (_super) {
            __extends(PlaneGeometry, _super);
            /**
            * Creates a new Plane object.
            * @param width The width of the plane.
            * @param height The height of the plane.
            * @param segmentsW The number of segments that make up the plane along the X-axis.
            * @param segmentsH The number of segments that make up the plane along the Y or Z-axis.
            * @param yUp Defines whether the normal vector of the plane should point along the Y-axis (true) or Z-axis (false).
            * @param doubleSided Defines whether the plane will be visible from both sides, with correct vertex normals.
            */
            function PlaneGeometry(width, height, segmentsW, segmentsH, yUp, doubleSided) {
                if (typeof width === "undefined") { width = 100; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof segmentsW === "undefined") { segmentsW = 1; }
                if (typeof segmentsH === "undefined") { segmentsH = 1; }
                if (typeof yUp === "undefined") { yUp = true; }
                if (typeof doubleSided === "undefined") { doubleSided = false; }
                _super.call(this);

                this._segmentsW = segmentsW;
                this._segmentsH = segmentsH;
                this._yUp = yUp;
                this._width = width;
                this._height = height;
                this._doubleSided = doubleSided;
            }
            Object.defineProperty(PlaneGeometry.prototype, "segmentsW", {
                get: /**
                * The number of segments that make up the plane along the X-axis. Defaults to 1.
                */
                function () {
                    return this._segmentsW;
                },
                set: function (value) {
                    this._segmentsW = value;

                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PlaneGeometry.prototype, "segmentsH", {
                get: /**
                * The number of segments that make up the plane along the Y or Z-axis, depending on whether yUp is true or
                * false, respectively. Defaults to 1.
                */
                function () {
                    return this._segmentsH;
                },
                set: function (value) {
                    this._segmentsH = value;

                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PlaneGeometry.prototype, "yUp", {
                get: /**
                *  Defines whether the normal vector of the plane should point along the Y-axis (true) or Z-axis (false). Defaults to true.
                */
                function () {
                    return this._yUp;
                },
                set: function (value) {
                    this._yUp = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PlaneGeometry.prototype, "doubleSided", {
                get: /**
                * Defines whether the plane will be visible from both sides, with correct vertex normals (as opposed to bothSides on Material). Defaults to false.
                */
                function () {
                    return this._doubleSided;
                },
                set: function (value) {
                    this._doubleSided = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PlaneGeometry.prototype, "width", {
                get: /**
                * The width of the plane.
                */
                function () {
                    return this._width;
                },
                set: function (value) {
                    this._width = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PlaneGeometry.prototype, "height", {
                get: /**
                * The height of the plane.
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    this._height = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            PlaneGeometry.prototype.pBuildGeometry = function (target) {
                var data;
                var indices/*uint*/ ;
                var x, y;
                var numIndices;
                var base;
                var tw = this._segmentsW + 1;
                var numVertices = (this._segmentsH + 1) * tw;
                var stride = target.vertexStride;
                var skip = stride - 9;

                if (this._doubleSided)
                    numVertices *= 2;

                numIndices = this._segmentsH * this._segmentsW * 6;

                if (this._doubleSided)
                    numIndices <<= 1;

                if (numVertices == target.numVertices) {
                    data = target.vertexData;

                    if (indices == null) {
                        indices = new Array(numIndices);
                    } else {
                        indices = target.indexData;
                    }
                } else {
                    data = new Array(numVertices * stride);
                    indices = new Array(numIndices);

                    this.pInvalidateUVs();
                }

                numIndices = 0;

                var index = target.vertexOffset;

                for (var yi = 0; yi <= this._segmentsH; ++yi) {
                    for (var xi = 0; xi <= this._segmentsW; ++xi) {
                        x = (xi / this._segmentsW - .5) * this._width;
                        y = (yi / this._segmentsH - .5) * this._height;

                        data[index++] = x;
                        if (this._yUp) {
                            data[index++] = 0;
                            data[index++] = y;
                        } else {
                            data[index++] = y;
                            data[index++] = 0;
                        }

                        data[index++] = 0;

                        if (this._yUp) {
                            data[index++] = 1;
                            data[index++] = 0;
                        } else {
                            data[index++] = 0;
                            data[index++] = -1;
                        }

                        data[index++] = 1;
                        data[index++] = 0;
                        data[index++] = 0;

                        index += skip;

                        if (this._doubleSided) {
                            for (var i = 0; i < 3; ++i) {
                                data[index] = data[index - stride];
                                ++index;
                            }

                            for (i = 0; i < 3; ++i) {
                                data[index] = -data[index - stride];
                                ++index;
                            }

                            for (i = 0; i < 3; ++i) {
                                data[index] = -data[index - stride];
                                ++index;
                            }

                            index += skip;
                        }

                        if (xi != this._segmentsW && yi != this._segmentsH) {
                            base = xi + yi * tw;
                            var mult = this._doubleSided ? 2 : 1;

                            indices[numIndices++] = base * mult;
                            indices[numIndices++] = (base + tw) * mult;
                            indices[numIndices++] = (base + tw + 1) * mult;
                            indices[numIndices++] = base * mult;
                            indices[numIndices++] = (base + tw + 1) * mult;
                            indices[numIndices++] = (base + 1) * mult;

                            if (this._doubleSided) {
                                indices[numIndices++] = (base + tw + 1) * mult + 1;
                                indices[numIndices++] = (base + tw) * mult + 1;
                                indices[numIndices++] = base * mult + 1;
                                indices[numIndices++] = (base + 1) * mult + 1;
                                indices[numIndices++] = (base + tw + 1) * mult + 1;
                                indices[numIndices++] = base * mult + 1;
                            }
                        }
                    }
                }

                target.updateData(data);
                target.updateIndexData(indices);
            };

            /**
            * @inheritDoc
            */
            PlaneGeometry.prototype.pBuildUVs = function (target) {
                var data;
                var stride = target.UVStride;
                var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
                var skip = stride - 2;

                if (this._doubleSided) {
                    numUvs *= 2;
                }

                if (target.UVData && numUvs == target.UVData.length) {
                    data = target.UVData;
                } else {
                    data = new Array(numUvs);
                    this.pInvalidateGeometry();
                }

                var index = target.UVOffset;

                for (var yi = 0; yi <= this._segmentsH; ++yi) {
                    for (var xi = 0; xi <= this._segmentsW; ++xi) {
                        data[index++] = (xi / this._segmentsW) * target.scaleU;
                        data[index++] = (1 - yi / this._segmentsH) * target.scaleV;
                        index += skip;

                        if (this._doubleSided) {
                            data[index++] = (xi / this._segmentsW) * target.scaleU;
                            data[index++] = (1 - yi / this._segmentsH) * target.scaleV;
                            index += skip;
                        }
                    }
                }

                target.updateData(data);
            };
            return PlaneGeometry;
        })(away.primitives.PrimitiveBase);
        primitives.PlaneGeometry = PlaneGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        /**
        * A Capsule primitive mesh.
        */
        var CapsuleGeometry = (function (_super) {
            __extends(CapsuleGeometry, _super);
            /**
            * Creates a new Capsule object.
            * @param radius The radius of the capsule.
            * @param height The height of the capsule.
            * @param segmentsW Defines the number of horizontal segments that make up the capsule. Defaults to 16.
            * @param segmentsH Defines the number of vertical segments that make up the capsule. Defaults to 15. Must be uneven value.
            * @param yUp Defines whether the capsule poles should lay on the Y-axis (true) or on the Z-axis (false).
            */
            function CapsuleGeometry(radius, height, segmentsW, segmentsH, yUp) {
                if (typeof radius === "undefined") { radius = 50; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof segmentsW === "undefined") { segmentsW = 16; }
                if (typeof segmentsH === "undefined") { segmentsH = 15; }
                if (typeof yUp === "undefined") { yUp = true; }
                _super.call(this);

                this._radius = radius;
                this._height = height;
                this._segmentsW = segmentsW;
                this._segmentsH = (segmentsH % 2 == 0) ? segmentsH + 1 : segmentsH;
                this._yUp = yUp;
            }
            /**
            * @inheritDoc
            */
            CapsuleGeometry.prototype.pBuildGeometry = function (target) {
                var data;
                var indices/*uint*/ ;
                var i;
                var j;
                var triIndex = 0;
                var numVerts = (this._segmentsH + 1) * (this._segmentsW + 1);
                var stride = target.vertexStride;
                var skip = stride - 9;
                var index = 0;
                var startIndex;
                var comp1, comp2, t1, t2;

                if (numVerts == target.numVertices) {
                    data = target.vertexData;

                    if (target.indexData) {
                        indices = target.indexData;
                    } else {
                        indices = new Array((this._segmentsH - 1) * this._segmentsW * 6);
                    }
                } else {
                    data = new Array(numVerts * stride);
                    indices = new Array((this._segmentsH - 1) * this._segmentsW * 6);
                    this.pInvalidateUVs();
                }

                for (j = 0; j <= this._segmentsH; ++j) {
                    var horangle = Math.PI * j / this._segmentsH;
                    var z = -this._radius * Math.cos(horangle);
                    var ringradius = this._radius * Math.sin(horangle);

                    startIndex = index;

                    for (i = 0; i <= this._segmentsW; ++i) {
                        var verangle = 2 * Math.PI * i / this._segmentsW;
                        var x = ringradius * Math.cos(verangle);
                        var offset = j > this._segmentsH / 2 ? this._height / 2 : -this._height / 2;
                        var y = ringradius * Math.sin(verangle);
                        var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                        var tanLen = Math.sqrt(y * y + x * x);

                        if (this._yUp) {
                            t1 = 0;
                            t2 = tanLen > .007 ? x / tanLen : 0;
                            comp1 = -z;
                            comp2 = y;
                        } else {
                            t1 = tanLen > .007 ? x / tanLen : 0;
                            t2 = 0;
                            comp1 = y;
                            comp2 = z;
                        }

                        if (i == this._segmentsW) {
                            data[index++] = data[startIndex];
                            data[index++] = data[startIndex + 1];
                            data[index++] = data[startIndex + 2];
                            data[index++] = (data[startIndex + 3] + (x * normLen)) * .5;
                            data[index++] = (data[startIndex + 4] + (comp1 * normLen)) * .5;
                            data[index++] = (data[startIndex + 5] + (comp2 * normLen)) * .5;
                            data[index++] = (data[startIndex + 6] + (tanLen > .007 ? -y / tanLen : 1)) * .5;
                            data[index++] = (data[startIndex + 7] + t1) * .5;
                            data[index++] = (data[startIndex + 8] + t2) * .5;
                        } else {
                            // vertex
                            data[index++] = x;
                            data[index++] = (this._yUp) ? comp1 - offset : comp1;
                            data[index++] = (this._yUp) ? comp2 : comp2 + offset;

                            // normal
                            data[index++] = x * normLen;
                            data[index++] = comp1 * normLen;
                            data[index++] = comp2 * normLen;

                            // tangent
                            data[index++] = tanLen > .007 ? -y / tanLen : 1;
                            data[index++] = t1;
                            data[index++] = t2;
                        }

                        if (i > 0 && j > 0) {
                            var a = (this._segmentsW + 1) * j + i;
                            var b = (this._segmentsW + 1) * j + i - 1;
                            var c = (this._segmentsW + 1) * (j - 1) + i - 1;
                            var d = (this._segmentsW + 1) * (j - 1) + i;

                            if (j == this._segmentsH) {
                                data[index - 9] = data[startIndex];
                                data[index - 8] = data[startIndex + 1];
                                data[index - 7] = data[startIndex + 2];

                                indices[triIndex++] = a;
                                indices[triIndex++] = c;
                                indices[triIndex++] = d;
                            } else if (j == 1) {
                                indices[triIndex++] = a;
                                indices[triIndex++] = b;
                                indices[triIndex++] = c;
                            } else {
                                indices[triIndex++] = a;
                                indices[triIndex++] = b;
                                indices[triIndex++] = c;
                                indices[triIndex++] = a;
                                indices[triIndex++] = c;
                                indices[triIndex++] = d;
                            }
                        }

                        index += skip;
                    }
                }

                target.updateData(data);
                target.updateIndexData(indices);
            };

            /**
            * @inheritDoc
            */
            CapsuleGeometry.prototype.pBuildUVs = function (target) {
                var i;
                var j;
                var index;
                var data;
                var stride = target.UVStride;
                var UVlen = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
                var skip = stride - 2;

                if (target.UVData && UVlen == target.UVData.length) {
                    data = target.UVData;
                } else {
                    data = new Array(UVlen);
                    this.pInvalidateGeometry();
                }

                index = target.UVOffset;

                for (j = 0; j <= this._segmentsH; ++j) {
                    for (i = 0; i <= this._segmentsW; ++i) {
                        data[index++] = (i / this._segmentsW) * target.scaleU;
                        data[index++] = (j / this._segmentsH) * target.scaleV;
                        index += skip;
                    }
                }

                target.updateData(data);
            };

            Object.defineProperty(CapsuleGeometry.prototype, "radius", {
                get: /**
                * The radius of the capsule.
                */
                function () {
                    return this._radius;
                },
                set: function (value) {
                    this._radius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CapsuleGeometry.prototype, "height", {
                get: /**
                * The height of the capsule.
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    this._height = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CapsuleGeometry.prototype, "segmentsW", {
                get: /**
                * Defines the number of horizontal segments that make up the capsule. Defaults to 16.
                */
                function () {
                    return this._segmentsW;
                },
                set: function (value) {
                    this._segmentsW = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CapsuleGeometry.prototype, "segmentsH", {
                get: /**
                * Defines the number of vertical segments that make up the capsule. Defaults to 15. Must be uneven.
                */
                function () {
                    return this._segmentsH;
                },
                set: function (value) {
                    this._segmentsH = (value % 2 == 0) ? value + 1 : value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CapsuleGeometry.prototype, "yUp", {
                get: /**
                * Defines whether the capsule poles should lay on the Y-axis (true) or on the Z-axis (false).
                */
                function () {
                    return this._yUp;
                },
                set: function (value) {
                    this._yUp = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });

            return CapsuleGeometry;
        })(away.primitives.PrimitiveBase);
        primitives.CapsuleGeometry = CapsuleGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        /**
        * A Cylinder primitive mesh.
        */
        var CylinderGeometry = (function (_super) {
            __extends(CylinderGeometry, _super);
            /**
            * Creates a new Cylinder object.
            * @param topRadius The radius of the top end of the cylinder.
            * @param bottomRadius The radius of the bottom end of the cylinder
            * @param height The radius of the bottom end of the cylinder
            * @param segmentsW Defines the number of horizontal segments that make up the cylinder. Defaults to 16.
            * @param segmentsH Defines the number of vertical segments that make up the cylinder. Defaults to 1.
            * @param topClosed Defines whether the top end of the cylinder is closed (true) or open.
            * @param bottomClosed Defines whether the bottom end of the cylinder is closed (true) or open.
            * @param yUp Defines whether the cone poles should lay on the Y-axis (true) or on the Z-axis (false).
            */
            function CylinderGeometry(topRadius, bottomRadius, height, segmentsW, segmentsH, topClosed, bottomClosed, surfaceClosed, yUp) {
                if (typeof topRadius === "undefined") { topRadius = 50; }
                if (typeof bottomRadius === "undefined") { bottomRadius = 50; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof segmentsW === "undefined") { segmentsW = 16; }
                if (typeof segmentsH === "undefined") { segmentsH = 1; }
                if (typeof topClosed === "undefined") { topClosed = true; }
                if (typeof bottomClosed === "undefined") { bottomClosed = true; }
                if (typeof surfaceClosed === "undefined") { surfaceClosed = true; }
                if (typeof yUp === "undefined") { yUp = true; }
                _super.call(this);
                this._currentIndex = 0;
                this._numVertices = 0;

                this._topRadius = topRadius;
                this._pBottomRadius = bottomRadius;
                this._height = height;
                this._pSegmentsW = segmentsW;
                this._pSegmentsH = segmentsH;
                this._topClosed = topClosed;
                this._bottomClosed = bottomClosed;
                this._surfaceClosed = surfaceClosed;
                this._yUp = yUp;
            }
            CylinderGeometry.prototype.addVertex = function (px, py, pz, nx, ny, nz, tx, ty, tz) {
                var compVertInd = this._vertexOffset + this._nextVertexIndex * this._stride;
                this._rawData[compVertInd++] = px;
                this._rawData[compVertInd++] = py;
                this._rawData[compVertInd++] = pz;
                this._rawData[compVertInd++] = nx;
                this._rawData[compVertInd++] = ny;
                this._rawData[compVertInd++] = nz;
                this._rawData[compVertInd++] = tx;
                this._rawData[compVertInd++] = ty;
                this._rawData[compVertInd++] = tz;
                this._nextVertexIndex++;
            };

            CylinderGeometry.prototype.addTriangleClockWise = function (cwVertexIndex0, cwVertexIndex1, cwVertexIndex2) {
                this._rawIndices[this._currentIndex++] = cwVertexIndex0;
                this._rawIndices[this._currentIndex++] = cwVertexIndex1;
                this._rawIndices[this._currentIndex++] = cwVertexIndex2;
                this._currentTriangleIndex++;
            };

            /**
            * @inheritDoc
            */
            CylinderGeometry.prototype.pBuildGeometry = function (target) {
                var i;
                var j;
                var x;
                var y;
                var z;
                var radius;
                var revolutionAngle;

                var dr;
                var latNormElev;
                var latNormBase;
                var numTriangles = 0;

                var comp1;
                var comp2;
                var startIndex = 0;

                var t1;
                var t2;

                this._stride = target.vertexStride;
                this._vertexOffset = target.vertexOffset;

                // reset utility variables
                this._numVertices = 0;
                this._nextVertexIndex = 0;
                this._currentIndex = 0;
                this._currentTriangleIndex = 0;

                if (this._surfaceClosed) {
                    this._numVertices += (this._pSegmentsH + 1) * (this._pSegmentsW + 1);
                    numTriangles += this._pSegmentsH * this._pSegmentsW * 2;
                }
                if (this._topClosed) {
                    this._numVertices += 2 * (this._pSegmentsW + 1);
                    numTriangles += this._pSegmentsW;
                }
                if (this._bottomClosed) {
                    this._numVertices += 2 * (this._pSegmentsW + 1);
                    numTriangles += this._pSegmentsW;
                }

                if (this._numVertices == target.numVertices) {
                    this._rawData = target.vertexData;

                    if (target.indexData) {
                        this._rawIndices = target.indexData;
                    } else {
                        this._rawIndices = new Array(numTriangles * 3);
                    }
                } else {
                    var numVertComponents = this._numVertices * this._stride;
                    this._rawData = new Array(numVertComponents);
                    this._rawIndices = new Array(numTriangles * 3);
                }

                // evaluate revolution steps
                var revolutionAngleDelta = 2 * Math.PI / this._pSegmentsW;

                if (this._topClosed && this._topRadius > 0) {
                    z = -0.5 * this._height;

                    for (i = 0; i <= this._pSegmentsW; ++i) {
                        if (this._yUp) {
                            t1 = 1;
                            t2 = 0;
                            comp1 = -z;
                            comp2 = 0;
                        } else {
                            t1 = 0;
                            t2 = -1;
                            comp1 = 0;
                            comp2 = z;
                        }

                        this.addVertex(0, comp1, comp2, 0, t1, t2, 1, 0, 0);

                        // revolution vertex
                        revolutionAngle = i * revolutionAngleDelta;
                        x = this._topRadius * Math.cos(revolutionAngle);
                        y = this._topRadius * Math.sin(revolutionAngle);

                        if (this._yUp) {
                            comp1 = -z;
                            comp2 = y;
                        } else {
                            comp1 = y;
                            comp2 = z;
                        }

                        if (i == this._pSegmentsW)
                            this.addVertex(this._rawData[startIndex + this._stride], this._rawData[startIndex + this._stride + 1], this._rawData[startIndex + this._stride + 2], 0, t1, t2, 1, 0, 0);
else
                            this.addVertex(x, comp1, comp2, 0, t1, t2, 1, 0, 0);

                        if (i > 0)
                            this.addTriangleClockWise(this._nextVertexIndex - 1, this._nextVertexIndex - 3, this._nextVertexIndex - 2);
                    }
                }

                if (this._bottomClosed && this._pBottomRadius > 0) {
                    z = 0.5 * this._height;

                    startIndex = this._vertexOffset + this._nextVertexIndex * this._stride;

                    for (i = 0; i <= this._pSegmentsW; ++i) {
                        if (this._yUp) {
                            t1 = -1;
                            t2 = 0;
                            comp1 = -z;
                            comp2 = 0;
                        } else {
                            t1 = 0;
                            t2 = 1;
                            comp1 = 0;
                            comp2 = z;
                        }

                        this.addVertex(0, comp1, comp2, 0, t1, t2, 1, 0, 0);

                        // revolution vertex
                        revolutionAngle = i * revolutionAngleDelta;
                        x = this._pBottomRadius * Math.cos(revolutionAngle);
                        y = this._pBottomRadius * Math.sin(revolutionAngle);

                        if (this._yUp) {
                            comp1 = -z;
                            comp2 = y;
                        } else {
                            comp1 = y;
                            comp2 = z;
                        }

                        if (i == this._pSegmentsW)
                            this.addVertex(x, this._rawData[startIndex + 1], this._rawData[startIndex + 2], 0, t1, t2, 1, 0, 0);
else
                            this.addVertex(x, comp1, comp2, 0, t1, t2, 1, 0, 0);

                        if (i > 0)
                            this.addTriangleClockWise(this._nextVertexIndex - 2, this._nextVertexIndex - 3, this._nextVertexIndex - 1);
                    }
                }

                // The normals on the lateral surface all have the same incline, i.e.
                // the "elevation" component (Y or Z depending on yUp) is constant.
                // Same principle goes for the "base" of these vectors, which will be
                // calculated such that a vector [base,elev] will be a unit vector.
                dr = (this._pBottomRadius - this._topRadius);
                latNormElev = dr / this._height;
                latNormBase = (latNormElev == 0) ? 1 : this._height / dr;

                if (this._surfaceClosed) {
                    var a;
                    var b;
                    var c;
                    var d;
                    var na0, na1, naComp1, naComp2;

                    for (j = 0; j <= this._pSegmentsH; ++j) {
                        radius = this._topRadius - ((j / this._pSegmentsH) * (this._topRadius - this._pBottomRadius));
                        z = -(this._height / 2) + (j / this._pSegmentsH * this._height);

                        startIndex = this._vertexOffset + this._nextVertexIndex * this._stride;

                        for (i = 0; i <= this._pSegmentsW; ++i) {
                            // revolution vertex
                            revolutionAngle = i * revolutionAngleDelta;
                            x = radius * Math.cos(revolutionAngle);
                            y = radius * Math.sin(revolutionAngle);
                            na0 = latNormBase * Math.cos(revolutionAngle);
                            na1 = latNormBase * Math.sin(revolutionAngle);

                            if (this._yUp) {
                                t1 = 0;
                                t2 = -na0;
                                comp1 = -z;
                                comp2 = y;
                                naComp1 = latNormElev;
                                naComp2 = na1;
                            } else {
                                t1 = -na0;
                                t2 = 0;
                                comp1 = y;
                                comp2 = z;
                                naComp1 = na1;
                                naComp2 = latNormElev;
                            }

                            if (i == this._pSegmentsW) {
                                this.addVertex(this._rawData[startIndex], this._rawData[startIndex + 1], this._rawData[startIndex + 2], na0, latNormElev, na1, na1, t1, t2);
                            } else {
                                this.addVertex(x, comp1, comp2, na0, naComp1, naComp2, -na1, t1, t2);
                            }

                            if (i > 0 && j > 0) {
                                a = this._nextVertexIndex - 1;
                                b = this._nextVertexIndex - 2;
                                c = b - this._pSegmentsW - 1;
                                d = a - this._pSegmentsW - 1;
                                this.addTriangleClockWise(a, b, c);
                                this.addTriangleClockWise(a, c, d);
                            }
                        }
                    }
                }

                // build real data from raw data
                target.updateData(this._rawData);
                target.updateIndexData(this._rawIndices);
            };

            /**
            * @inheritDoc
            */
            CylinderGeometry.prototype.pBuildUVs = function (target) {
                var i;
                var j;
                var x;
                var y;
                var revolutionAngle;
                var stride = target.UVStride;
                var skip = stride - 2;
                var UVData;

                // evaluate num uvs
                var numUvs = this._numVertices * stride;

                if (target.UVData && numUvs == target.UVData.length) {
                    UVData = target.UVData;
                } else {
                    UVData = new Array(numUvs);
                    this.pInvalidateGeometry();
                }

                // evaluate revolution steps
                var revolutionAngleDelta = 2 * Math.PI / this._pSegmentsW;

                // current uv component index
                var currentUvCompIndex = target.UVOffset;

                if (this._topClosed) {
                    for (i = 0; i <= this._pSegmentsW; ++i) {
                        revolutionAngle = i * revolutionAngleDelta;
                        x = 0.5 + 0.5 * -Math.cos(revolutionAngle);
                        y = 0.5 + 0.5 * Math.sin(revolutionAngle);

                        UVData[currentUvCompIndex++] = 0.5 * target.scaleU;
                        UVData[currentUvCompIndex++] = 0.5 * target.scaleV;
                        currentUvCompIndex += skip;
                        UVData[currentUvCompIndex++] = x * target.scaleU;
                        UVData[currentUvCompIndex++] = y * target.scaleV;
                        currentUvCompIndex += skip;
                    }
                }

                if (this._bottomClosed) {
                    for (i = 0; i <= this._pSegmentsW; ++i) {
                        revolutionAngle = i * revolutionAngleDelta;
                        x = 0.5 + 0.5 * Math.cos(revolutionAngle);
                        y = 0.5 + 0.5 * Math.sin(revolutionAngle);

                        UVData[currentUvCompIndex++] = 0.5 * target.scaleU;
                        UVData[currentUvCompIndex++] = 0.5 * target.scaleV;
                        currentUvCompIndex += skip;
                        UVData[currentUvCompIndex++] = x * target.scaleU;
                        UVData[currentUvCompIndex++] = y * target.scaleV;
                        currentUvCompIndex += skip;
                    }
                }

                if (this._surfaceClosed) {
                    for (j = 0; j <= this._pSegmentsH; ++j) {
                        for (i = 0; i <= this._pSegmentsW; ++i) {
                            // revolution vertex
                            UVData[currentUvCompIndex++] = (i / this._pSegmentsW) * target.scaleU;
                            UVData[currentUvCompIndex++] = (j / this._pSegmentsH) * target.scaleV;
                            currentUvCompIndex += skip;
                        }
                    }
                }

                // build real data from raw data
                target.updateData(UVData);
            };

            Object.defineProperty(CylinderGeometry.prototype, "topRadius", {
                get: /**
                * The radius of the top end of the cylinder.
                */
                function () {
                    return this._topRadius;
                },
                set: function (value) {
                    this._topRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CylinderGeometry.prototype, "bottomRadius", {
                get: /**
                * The radius of the bottom end of the cylinder.
                */
                function () {
                    return this._pBottomRadius;
                },
                set: function (value) {
                    this._pBottomRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CylinderGeometry.prototype, "height", {
                get: /**
                * The radius of the top end of the cylinder.
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    this._height = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CylinderGeometry.prototype, "segmentsW", {
                get: /**
                * Defines the number of horizontal segments that make up the cylinder. Defaults to 16.
                */
                function () {
                    return this._pSegmentsW;
                },
                set: function (value) {
                    this.setSegmentsW(value);
                },
                enumerable: true,
                configurable: true
            });


            CylinderGeometry.prototype.setSegmentsW = function (value) {
                this._pSegmentsW = value;
                this.pInvalidateGeometry();
                this.pInvalidateUVs();
            };

            Object.defineProperty(CylinderGeometry.prototype, "segmentsH", {
                get: /**
                * Defines the number of vertical segments that make up the cylinder. Defaults to 1.
                */
                function () {
                    return this._pSegmentsH;
                },
                set: function (value) {
                    this.setSegmentsH(value);
                },
                enumerable: true,
                configurable: true
            });


            CylinderGeometry.prototype.setSegmentsH = function (value) {
                this._pSegmentsH = value;
                this.pInvalidateGeometry();
                this.pInvalidateUVs();
            };

            Object.defineProperty(CylinderGeometry.prototype, "topClosed", {
                get: /**
                * Defines whether the top end of the cylinder is closed (true) or open.
                */
                function () {
                    return this._topClosed;
                },
                set: function (value) {
                    this._topClosed = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CylinderGeometry.prototype, "bottomClosed", {
                get: /**
                * Defines whether the bottom end of the cylinder is closed (true) or open.
                */
                function () {
                    return this._bottomClosed;
                },
                set: function (value) {
                    this._bottomClosed = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CylinderGeometry.prototype, "yUp", {
                get: /**
                * Defines whether the cylinder poles should lay on the Y-axis (true) or on the Z-axis (false).
                */
                function () {
                    return this._yUp;
                },
                set: function (value) {
                    this._yUp = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });

            return CylinderGeometry;
        })(away.primitives.PrimitiveBase);
        primitives.CylinderGeometry = CylinderGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        /**
        * A UV Cone primitive mesh.
        */
        var ConeGeometry = (function (_super) {
            __extends(ConeGeometry, _super);
            /**
            * Creates a new Cone object.
            * @param radius The radius of the bottom end of the cone
            * @param height The height of the cone
            * @param segmentsW Defines the number of horizontal segments that make up the cone. Defaults to 16.
            * @param segmentsH Defines the number of vertical segments that make up the cone. Defaults to 1.
            * @param yUp Defines whether the cone poles should lay on the Y-axis (true) or on the Z-axis (false).
            */
            function ConeGeometry(radius, height, segmentsW, segmentsH, closed, yUp) {
                if (typeof radius === "undefined") { radius = 50; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof segmentsW === "undefined") { segmentsW = 16; }
                if (typeof segmentsH === "undefined") { segmentsH = 1; }
                if (typeof closed === "undefined") { closed = true; }
                if (typeof yUp === "undefined") { yUp = true; }
                _super.call(this, 0, radius, height, segmentsW, segmentsH, false, closed, true, yUp);
            }
            Object.defineProperty(ConeGeometry.prototype, "radius", {
                get: /**
                * The radius of the bottom end of the cone.
                */
                function () {
                    return this._pBottomRadius;
                },
                set: function (value) {
                    this._pBottomRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });

            return ConeGeometry;
        })(away.primitives.CylinderGeometry);
        primitives.ConeGeometry = ConeGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        /**
        * A UV RegularPolygon primitive mesh.
        */
        var RegularPolygonGeometry = (function (_super) {
            __extends(RegularPolygonGeometry, _super);
            /**
            * Creates a new RegularPolygon disc object.
            * @param radius The radius of the regular polygon
            * @param sides Defines the number of sides of the regular polygon.
            * @param yUp Defines whether the regular polygon should lay on the Y-axis (true) or on the Z-axis (false).
            */
            function RegularPolygonGeometry(radius, sides, yUp) {
                if (typeof radius === "undefined") { radius = 100; }
                if (typeof sides === "undefined") { sides = 16; }
                if (typeof yUp === "undefined") { yUp = true; }
                _super.call(this, radius, 0, 0, sides, 1, true, false, false, yUp);
            }
            Object.defineProperty(RegularPolygonGeometry.prototype, "radius", {
                get: /**
                * The radius of the regular polygon.
                */
                function () {
                    return this._pBottomRadius;
                },
                set: function (value) {
                    this._pBottomRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RegularPolygonGeometry.prototype, "sides", {
                get: /**
                * The number of sides of the regular polygon.
                */
                function () {
                    return this._pSegmentsW;
                },
                set: function (value) {
                    this.setSegmentsW(value);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RegularPolygonGeometry.prototype, "subdivisions", {
                get: /**
                * The number of subdivisions from the edge to the center of the regular polygon.
                */
                function () {
                    return this._pSegmentsH;
                },
                set: function (value) {
                    this.setSegmentsH(value);
                },
                enumerable: true,
                configurable: true
            });

            return RegularPolygonGeometry;
        })(away.primitives.CylinderGeometry);
        primitives.RegularPolygonGeometry = RegularPolygonGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //import away3d.arcane;
        //import away3d.core.base.CompactSubGeometry;
        /**
        * A UV Sphere primitive mesh.
        */
        var SphereGeometry = (function (_super) {
            __extends(SphereGeometry, _super);
            /**
            * Creates a new Sphere object.
            * @param radius The radius of the sphere.
            * @param segmentsW Defines the number of horizontal segments that make up the sphere.
            * @param segmentsH Defines the number of vertical segments that make up the sphere.
            * @param yUp Defines whether the sphere poles should lay on the Y-axis (true) or on the Z-axis (false).
            */
            function SphereGeometry(radius, segmentsW, segmentsH, yUp) {
                if (typeof radius === "undefined") { radius = 50; }
                if (typeof segmentsW === "undefined") { segmentsW = 16; }
                if (typeof segmentsH === "undefined") { segmentsH = 12; }
                if (typeof yUp === "undefined") { yUp = true; }
                _super.call(this);

                this._radius = radius;
                this._segmentsW = segmentsW;
                this._segmentsH = segmentsH;
                this._yUp = yUp;
            }
            /**
            * @inheritDoc
            */
            SphereGeometry.prototype.pBuildGeometry = function (target) {
                var vertices;
                var indices/*uint*/ ;
                var i;
                var j;
                var triIndex = 0;
                var numVerts = (this._segmentsH + 1) * (this._segmentsW + 1);
                var stride = target.vertexStride;
                var skip = stride - 9;

                if (numVerts == target.numVertices) {
                    vertices = target.vertexData;

                    if (target.indexData) {
                        indices = target.indexData;
                    } else {
                        indices = new Array((this._segmentsH - 1) * this._segmentsW * 6);
                    }
                } else {
                    vertices = new Array(numVerts * stride);
                    indices = new Array((this._segmentsH - 1) * this._segmentsW * 6);
                    this.pInvalidateGeometry();
                }

                var startIndex;
                var index = target.vertexOffset;
                var comp1;
                var comp2;
                var t1;
                var t2;

                for (j = 0; j <= this._segmentsH; ++j) {
                    startIndex = index;

                    var horangle = Math.PI * j / this._segmentsH;
                    var z = -this._radius * Math.cos(horangle);
                    var ringradius = this._radius * Math.sin(horangle);

                    for (i = 0; i <= this._segmentsW; ++i) {
                        var verangle = 2 * Math.PI * i / this._segmentsW;
                        var x = ringradius * Math.cos(verangle);
                        var y = ringradius * Math.sin(verangle);
                        var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                        var tanLen = Math.sqrt(y * y + x * x);

                        if (this._yUp) {
                            t1 = 0;
                            t2 = tanLen > .007 ? x / tanLen : 0;
                            comp1 = -z;
                            comp2 = y;
                        } else {
                            t1 = tanLen > .007 ? x / tanLen : 0;
                            t2 = 0;
                            comp1 = y;
                            comp2 = z;
                        }

                        if (i == this._segmentsW) {
                            vertices[index++] = vertices[startIndex];
                            vertices[index++] = vertices[startIndex + 1];
                            vertices[index++] = vertices[startIndex + 2];
                            vertices[index++] = vertices[startIndex + 3] + (x * normLen) * .5;
                            vertices[index++] = vertices[startIndex + 4] + (comp1 * normLen) * .5;
                            vertices[index++] = vertices[startIndex + 5] + (comp2 * normLen) * .5;
                            vertices[index++] = tanLen > .007 ? -y / tanLen : 1;
                            vertices[index++] = t1;
                            vertices[index++] = t2;
                        } else {
                            vertices[index++] = x;
                            vertices[index++] = comp1;
                            vertices[index++] = comp2;
                            vertices[index++] = x * normLen;
                            vertices[index++] = comp1 * normLen;
                            vertices[index++] = comp2 * normLen;
                            vertices[index++] = tanLen > .007 ? -y / tanLen : 1;
                            vertices[index++] = t1;
                            vertices[index++] = t2;
                        }

                        if (i > 0 && j > 0) {
                            var a = (this._segmentsW + 1) * j + i;
                            var b = (this._segmentsW + 1) * j + i - 1;
                            var c = (this._segmentsW + 1) * (j - 1) + i - 1;
                            var d = (this._segmentsW + 1) * (j - 1) + i;

                            if (j == this._segmentsH) {
                                vertices[index - 9] = vertices[startIndex];
                                vertices[index - 8] = vertices[startIndex + 1];
                                vertices[index - 7] = vertices[startIndex + 2];

                                indices[triIndex++] = a;
                                indices[triIndex++] = c;
                                indices[triIndex++] = d;
                            } else if (j == 1) {
                                indices[triIndex++] = a;
                                indices[triIndex++] = b;
                                indices[triIndex++] = c;
                            } else {
                                indices[triIndex++] = a;
                                indices[triIndex++] = b;
                                indices[triIndex++] = c;
                                indices[triIndex++] = a;
                                indices[triIndex++] = c;
                                indices[triIndex++] = d;
                            }
                        }

                        index += skip;
                    }
                }

                target.updateData(vertices);
                target.updateIndexData(indices);
            };

            /**
            * @inheritDoc
            */
            SphereGeometry.prototype.pBuildUVs = function (target) {
                var i, j;
                var stride = target.UVStride;
                var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
                var data;
                var skip = stride - 2;

                if (target.UVData && numUvs == target.UVData.length)
                    data = target.UVData;
else {
                    data = new Array(numUvs);
                    this.pInvalidateGeometry();
                }

                var index = target.UVOffset;
                for (j = 0; j <= this._segmentsH; ++j) {
                    for (i = 0; i <= this._segmentsW; ++i) {
                        data[index++] = (i / this._segmentsW) * target.scaleU;
                        data[index++] = (j / this._segmentsH) * target.scaleV;
                        index += skip;
                    }
                }

                target.updateData(data);
            };

            Object.defineProperty(SphereGeometry.prototype, "radius", {
                get: /**
                * The radius of the sphere.
                */
                function () {
                    return this._radius;
                },
                set: function (value) {
                    this._radius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SphereGeometry.prototype, "segmentsW", {
                get: /**
                * Defines the number of horizontal segments that make up the sphere. Defaults to 16.
                */
                function () {
                    return this._segmentsW;
                },
                set: function (value) {
                    this._segmentsW = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SphereGeometry.prototype, "segmentsH", {
                get: /**
                * Defines the number of vertical segments that make up the sphere. Defaults to 12.
                */
                function () {
                    return this._segmentsH;
                },
                set: function (value) {
                    this._segmentsH = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SphereGeometry.prototype, "yUp", {
                get: /**
                * Defines whether the sphere poles should lay on the Y-axis (true) or on the Z-axis (false).
                */
                function () {
                    return this._yUp;
                },
                set: function (value) {
                    this._yUp = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });

            return SphereGeometry;
        })(away.primitives.PrimitiveBase);
        primitives.SphereGeometry = SphereGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        var WireframePrimitiveBase = (function (_super) {
            __extends(WireframePrimitiveBase, _super);
            function WireframePrimitiveBase(color, thickness) {
                if (typeof color === "undefined") { color = 0xffffff; }
                if (typeof thickness === "undefined") { thickness = 1; }
                _super.call(this);
                this._geomDirty = true;
                if (thickness <= 0) {
                    thickness = 1;
                }
                this._color = color;
                this._thickness = thickness;
            }
            Object.defineProperty(WireframePrimitiveBase.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    this._color = value;

                    this._pSubGeometry._iSetColor(value);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframePrimitiveBase.prototype, "thickness", {
                get: function () {
                    return this._thickness;
                },
                set: function (value) {
                    this._thickness = value;

                    this._pSubGeometry._iSetThickness(value);
                },
                enumerable: true,
                configurable: true
            });


            //@override
            WireframePrimitiveBase.prototype.removeAllSegments = function () {
                _super.prototype.removeAllSegments.call(this);
            };

            WireframePrimitiveBase.prototype.pBuildGeometry = function () {
                throw new away.errors.AbstractMethodError();
            };

            WireframePrimitiveBase.prototype.pInvalidateGeometry = function () {
                this.pInvalidateBounds();

                this._geomDirty = true;
            };

            WireframePrimitiveBase.prototype.updateGeometry = function () {
                this.pBuildGeometry();

                this._geomDirty = false;
            };

            WireframePrimitiveBase.prototype.pUpdateBounds = function () {
                if (this._geomDirty)
                    this.updateGeometry();

                _super.prototype.pUpdateBounds.call(this);
            };

            WireframePrimitiveBase.prototype.pUpdateOrAddSegment = function (index, v0, v1) {
                var segment;
                var s;
                var e;

                if ((segment = this.getSegment(index)) != null) {
                    s = segment.start;
                    e = segment.end;
                    s.x = v0.x;
                    s.y = v0.y;
                    s.z = v0.z;
                    e.x = v1.x;
                    e.y = v1.y;
                    e.z = v1.z;
                    segment.updateSegment(s, e, null, this._color, this._color, this._thickness);
                } else {
                    this.addSegment(new away.primitives.LineSegment(v0.clone(), v1.clone(), this._color, this._color, this._thickness));
                }
            };
            return WireframePrimitiveBase;
        })(away.entities.SegmentSet);
        primitives.WireframePrimitiveBase = WireframePrimitiveBase;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (primitives) {
        //TODO - convert to geometry primitive
        /**
        * A WireframeSphere primitive mesh
        */
        var WireframeSphere = (function (_super) {
            __extends(WireframeSphere, _super);
            /**
            * Creates a new WireframeSphere object.
            * @param radius The radius of the sphere.
            * @param segmentsW Defines the number of horizontal segments that make up the sphere.
            * @param segmentsH Defines the number of vertical segments that make up the sphere.
            * @param color The colour of the wireframe lines
            * @param thickness The thickness of the wireframe lines
            */
            function WireframeSphere(radius, segmentsW, segmentsH, color, thickness) {
                if (typeof radius === "undefined") { radius = 50; }
                if (typeof segmentsW === "undefined") { segmentsW = 16; }
                if (typeof segmentsH === "undefined") { segmentsH = 12; }
                if (typeof color === "undefined") { color = 0xFFFFFF; }
                if (typeof thickness === "undefined") { thickness = 1; }
                _super.call(this, color, thickness);

                this._radius = radius;
                this._segmentsW = segmentsW;
                this._segmentsH = segmentsH;
            }
            /**
            * @inheritDoc
            */
            WireframeSphere.prototype.pBuildGeometry = function () {
                var vertices = new Array();
                var v0 = new away.geom.Vector3D();
                var v1 = new away.geom.Vector3D();
                var i, j;
                var numVerts = 0;
                var index = 0;

                for (j = 0; j <= this._segmentsH; ++j) {
                    var horangle = Math.PI * j / this._segmentsH;
                    var z = -this._radius * Math.cos(horangle);
                    var ringradius = this._radius * Math.sin(horangle);

                    for (i = 0; i <= this._segmentsW; ++i) {
                        var verangle = 2 * Math.PI * i / this._segmentsW;
                        var x = ringradius * Math.cos(verangle);
                        var y = ringradius * Math.sin(verangle);
                        vertices[numVerts++] = x;
                        vertices[numVerts++] = -z;
                        vertices[numVerts++] = y;
                    }
                }

                for (j = 1; j <= this._segmentsH; ++j) {
                    for (i = 1; i <= this._segmentsW; ++i) {
                        var a = ((this._segmentsW + 1) * j + i) * 3;
                        var b = ((this._segmentsW + 1) * j + i - 1) * 3;
                        var c = ((this._segmentsW + 1) * (j - 1) + i - 1) * 3;
                        var d = ((this._segmentsW + 1) * (j - 1) + i) * 3;

                        if (j == this._segmentsH) {
                            v0.x = vertices[c];
                            v0.y = vertices[c + 1];
                            v0.z = vertices[c + 2];
                            v1.x = vertices[d];
                            v1.y = vertices[d + 1];
                            v1.z = vertices[d + 2];
                            this.pUpdateOrAddSegment(index++, v0, v1);
                            v0.x = vertices[a];
                            v0.y = vertices[a + 1];
                            v0.z = vertices[a + 2];
                            this.pUpdateOrAddSegment(index++, v0, v1);
                        } else if (j == 1) {
                            v1.x = vertices[b];
                            v1.y = vertices[b + 1];
                            v1.z = vertices[b + 2];
                            v0.x = vertices[c];
                            v0.y = vertices[c + 1];
                            v0.z = vertices[c + 2];
                            this.pUpdateOrAddSegment(index++, v0, v1);
                        } else {
                            v1.x = vertices[b];
                            v1.y = vertices[b + 1];
                            v1.z = vertices[b + 2];
                            v0.x = vertices[c];
                            v0.y = vertices[c + 1];
                            v0.z = vertices[c + 2];
                            this.pUpdateOrAddSegment(index++, v0, v1);
                            v1.x = vertices[d];
                            v1.y = vertices[d + 1];
                            v1.z = vertices[d + 2];
                            this.pUpdateOrAddSegment(index++, v0, v1);
                        }
                    }
                }
            };
            return WireframeSphere;
        })(away.primitives.WireframePrimitiveBase);
        primitives.WireframeSphere = WireframeSphere;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //TODO - convert to geometry primitive
        /**
        * A WirefameCube primitive mesh.
        */
        var WireframeCube = (function (_super) {
            __extends(WireframeCube, _super);
            /**
            * Creates a new WireframeCube object.
            * @param width The size of the cube along its X-axis.
            * @param height The size of the cube along its Y-axis.
            * @param depth The size of the cube along its Z-axis.
            * @param color The colour of the wireframe lines
            * @param thickness The thickness of the wireframe lines
            */
            function WireframeCube(width, height, depth, color, thickness) {
                if (typeof width === "undefined") { width = 100; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof depth === "undefined") { depth = 100; }
                if (typeof color === "undefined") { color = 0xFFFFFF; }
                if (typeof thickness === "undefined") { thickness = 1; }
                _super.call(this, color, thickness);

                this.width = width;
                this.height = height;
                this.depth = depth;
            }
            /**
            * @inheritDoc
            */
            WireframeCube.prototype.pBuildGeometry = function () {
                var v0 = new away.geom.Vector3D();
                var v1 = new away.geom.Vector3D();
                var hw = 0.5;
                var hh = 0.5;
                var hd = 0.5;

                v0.x = -hw;
                v0.y = hh;
                v0.z = -hd;
                v1.x = -hw;
                v1.y = -hh;
                v1.z = -hd;

                this.pUpdateOrAddSegment(0, v0, v1);
                v0.z = hd;
                v1.z = hd;
                this.pUpdateOrAddSegment(1, v0, v1);
                v0.x = hw;
                v1.x = hw;
                this.pUpdateOrAddSegment(2, v0, v1);
                v0.z = -hd;
                v1.z = -hd;
                this.pUpdateOrAddSegment(3, v0, v1);

                v0.x = -hw;
                v0.y = -hh;
                v0.z = -hd;
                v1.x = hw;
                v1.y = -hh;
                v1.z = -hd;
                this.pUpdateOrAddSegment(4, v0, v1);
                v0.y = hh;
                v1.y = hh;
                this.pUpdateOrAddSegment(5, v0, v1);
                v0.z = hd;
                v1.z = hd;
                this.pUpdateOrAddSegment(6, v0, v1);
                v0.y = -hh;
                v1.y = -hh;
                this.pUpdateOrAddSegment(7, v0, v1);

                v0.x = -hw;
                v0.y = -hh;
                v0.z = -hd;
                v1.x = -hw;
                v1.y = -hh;
                v1.z = hd;
                this.pUpdateOrAddSegment(8, v0, v1);
                v0.y = hh;
                v1.y = hh;
                this.pUpdateOrAddSegment(9, v0, v1);
                v0.x = hw;
                v1.x = hw;
                this.pUpdateOrAddSegment(10, v0, v1);
                v0.y = -hh;
                v1.y = -hh;
                this.pUpdateOrAddSegment(11, v0, v1);
            };
            return WireframeCube;
        })(away.primitives.WireframePrimitiveBase);
        primitives.WireframeCube = WireframeCube;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //TODO - convert to geometry primitive
        /**
        * Generates a wireframd cylinder primitive.
        */
        var WireframeCylinder = (function (_super) {
            __extends(WireframeCylinder, _super);
            /**
            * Creates a new WireframeCylinder instance
            * @param topRadius Top radius of the cylinder
            * @param bottomRadius Bottom radius of the cylinder
            * @param height The height of the cylinder
            * @param segmentsW Number of radial segments
            * @param segmentsH Number of vertical segments
            * @param color The color of the wireframe lines
            * @param thickness The thickness of the wireframe lines
            */
            function WireframeCylinder(topRadius, bottomRadius, height, segmentsW, segmentsH, color, thickness) {
                if (typeof topRadius === "undefined") { topRadius = 50; }
                if (typeof bottomRadius === "undefined") { bottomRadius = 50; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof segmentsW === "undefined") { segmentsW = 16; }
                if (typeof segmentsH === "undefined") { segmentsH = 1; }
                if (typeof color === "undefined") { color = 0xFFFFFF; }
                if (typeof thickness === "undefined") { thickness = 1; }
                _super.call(this, color, thickness);
                this._topRadius = topRadius;
                this._bottomRadius = bottomRadius;
                this._segmentsW = segmentsW;
                this._segmentsH = segmentsH;

                this.height = height;
            }
            WireframeCylinder.prototype.pBuildGeometry = function () {
                var i, j;
                var radius = this._topRadius;
                var revolutionAngle;
                var revolutionAngleDelta = WireframeCylinder.TWO_PI / this._segmentsW;
                var nextVertexIndex = 0;
                var x, y, z;

                var lastLayer = new Array(this._segmentsH + 1);

                for (j = 0; j <= this._segmentsH; ++j) {
                    lastLayer[j] = new Array(this._segmentsW + 1);

                    radius = this._topRadius - ((j / this._segmentsH) * (this._topRadius - this._bottomRadius));
                    z = -(1 / 2) + (j / this._segmentsH * 1);

                    var previousV = null;

                    for (i = 0; i <= this._segmentsW; ++i) {
                        // revolution vertex
                        revolutionAngle = i * revolutionAngleDelta;
                        x = radius * Math.cos(revolutionAngle);
                        y = radius * Math.sin(revolutionAngle);
                        var vertex;
                        if (previousV) {
                            vertex = new away.geom.Vector3D(x, -z, y);
                            this.pUpdateOrAddSegment(nextVertexIndex++, vertex, previousV);
                            previousV = vertex;
                        } else
                            previousV = new away.geom.Vector3D(x, -z, y);

                        if (j > 0) {
                            this.pUpdateOrAddSegment(nextVertexIndex++, vertex, lastLayer[j - 1][i]);
                        }
                        lastLayer[j][i] = previousV;
                    }
                }
            };

            Object.defineProperty(WireframeCylinder.prototype, "topRadius", {
                get: /**
                * Top radius of the cylinder
                */
                function () {
                    return this._topRadius;
                },
                set: function (value) {
                    this._topRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframeCylinder.prototype, "bottomRadius", {
                get: /**
                * Bottom radius of the cylinder
                */
                function () {
                    return this._bottomRadius;
                },
                set: function (value) {
                    this._bottomRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });

            WireframeCylinder.TWO_PI = 2 * Math.PI;
            return WireframeCylinder;
        })(away.primitives.WireframePrimitiveBase);
        primitives.WireframeCylinder = WireframeCylinder;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //TODO - convert to geometry primitive
        /**
        * A WireframePlane primitive mesh.
        */
        var WireframePlane = (function (_super) {
            __extends(WireframePlane, _super);
            /**
            * Creates a new WireframePlane object.
            * @param width The size of the cube along its X-axis.
            * @param height The size of the cube along its Y-axis.
            * @param segmentsW The number of segments that make up the cube along the X-axis.
            * @param segmentsH The number of segments that make up the cube along the Y-axis.
            * @param color The colour of the wireframe lines
            * @param thickness The thickness of the wireframe lines
            * @param orientation The orientaion in which the plane lies.
            */
            function WireframePlane(width, height, segmentsW, segmentsH, color, thickness, orientation) {
                if (typeof segmentsW === "undefined") { segmentsW = 10; }
                if (typeof segmentsH === "undefined") { segmentsH = 10; }
                if (typeof color === "undefined") { color = 0xFFFFFF; }
                if (typeof thickness === "undefined") { thickness = 1; }
                if (typeof orientation === "undefined") { orientation = "yz"; }
                _super.call(this, color, thickness);

                this._segmentsW = segmentsW;
                this._segmentsH = segmentsH;
                this._orientation = orientation;

                this.width = width;
                this.height = height;
            }
            Object.defineProperty(WireframePlane.prototype, "orientation", {
                get: /**
                * The orientaion in which the plane lies.
                */
                function () {
                    return this._orientation;
                },
                set: function (value) {
                    this._orientation = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframePlane.prototype, "segmentsW", {
                get: /**
                * The number of segments that make up the plane along the X-axis.
                */
                function () {
                    return this._segmentsW;
                },
                set: function (value) {
                    this._segmentsW = value;
                    this.removeAllSegments();
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframePlane.prototype, "segmentsH", {
                get: /**
                * The number of segments that make up the plane along the Y-axis.
                */
                function () {
                    return this._segmentsH;
                },
                set: function (value) {
                    this._segmentsH = value;
                    this.removeAllSegments();
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            WireframePlane.prototype.pBuildGeometry = function () {
                var v0 = new away.geom.Vector3D();
                var v1 = new away.geom.Vector3D();
                var hw = 0.5;
                var hh = 0.5;
                var index = 0;
                var ws, hs;

                if (this._orientation == WireframePlane.ORIENTATION_XY) {
                    v0.y = hh;
                    v0.z = 0;
                    v1.y = -hh;
                    v1.z = 0;

                    for (ws = 0; ws <= this._segmentsW; ++ws) {
                        v0.x = v1.x = (ws / this._segmentsW - .5);
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }

                    v0.x = -hw;
                    v1.x = hw;

                    for (hs = 0; hs <= this._segmentsH; ++hs) {
                        v0.y = v1.y = (hs / this._segmentsH - .5);
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }
                } else if (this._orientation == WireframePlane.ORIENTATION_XZ) {
                    v0.z = hh;
                    v0.y = 0;
                    v1.z = -hh;
                    v1.y = 0;

                    for (ws = 0; ws <= this._segmentsW; ++ws) {
                        v0.x = v1.x = (ws / this._segmentsW - .5);
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }

                    v0.x = -hw;
                    v1.x = hw;

                    for (hs = 0; hs <= this._segmentsH; ++hs) {
                        v0.z = v1.z = (hs / this._segmentsH - .5);
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }
                } else if (this._orientation == WireframePlane.ORIENTATION_YZ) {
                    v0.y = hh;
                    v0.x = 0;
                    v1.y = -hh;
                    v1.x = 0;

                    for (ws = 0; ws <= this._segmentsW; ++ws) {
                        v0.z = v1.z = (ws / this._segmentsW - .5);
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }

                    v0.z = hw;
                    v1.z = -hw;

                    for (hs = 0; hs <= this._segmentsH; ++hs) {
                        v0.y = v1.y = (hs / this._segmentsH - .5);
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }
                }
            };
            WireframePlane.ORIENTATION_YZ = "yz";
            WireframePlane.ORIENTATION_XY = "xy";
            WireframePlane.ORIENTATION_XZ = "xz";
            return WireframePlane;
        })(away.primitives.WireframePrimitiveBase);
        primitives.WireframePlane = WireframePlane;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //TODO - convert to geometry primitive
        /**
        * A WireframeRegularPolygon primitive mesh.
        */
        var WireframeRegularPolygon = (function (_super) {
            __extends(WireframeRegularPolygon, _super);
            /**
            * Creates a new WireframeRegularPolygon object.
            * @param radius The radius of the polygon.
            * @param sides The number of sides on the polygon.
            * @param color The colour of the wireframe lines
            * @param thickness The thickness of the wireframe lines
            * @param orientation The orientaion in which the plane lies.
            */
            function WireframeRegularPolygon(radius, sides, color, thickness, orientation) {
                if (typeof color === "undefined") { color = 0xFFFFFF; }
                if (typeof thickness === "undefined") { thickness = 1; }
                if (typeof orientation === "undefined") { orientation = "yz"; }
                _super.call(this, color, thickness);

                this._radius = radius;
                this._sides = sides;
                this._orientation = orientation;
            }
            Object.defineProperty(WireframeRegularPolygon.prototype, "orientation", {
                get: /**
                * The orientaion in which the polygon lies.
                */
                function () {
                    return this._orientation;
                },
                set: function (value) {
                    this._orientation = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframeRegularPolygon.prototype, "radius", {
                get: /**
                * The radius of the regular polygon.
                */
                function () {
                    return this._radius;
                },
                set: function (value) {
                    this._radius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframeRegularPolygon.prototype, "sides", {
                get: /**
                * The number of sides to the regular polygon.
                */
                function () {
                    return this._sides;
                },
                set: function (value) {
                    this._sides = value;
                    this.removeAllSegments();
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            WireframeRegularPolygon.prototype.pBuildGeometry = function () {
                var v0 = new away.geom.Vector3D();
                var v1 = new away.geom.Vector3D();
                var index = 0;
                var s;

                if (this._orientation == WireframeRegularPolygon.ORIENTATION_XY) {
                    v0.z = 0;
                    v1.z = 0;

                    for (s = 0; s < this._sides; ++s) {
                        v0.x = this._radius * Math.cos(2 * Math.PI * s / this._sides);
                        v0.y = this._radius * Math.sin(2 * Math.PI * s / this._sides);
                        v1.x = this._radius * Math.cos(2 * Math.PI * (s + 1) / this._sides);
                        v1.y = this._radius * Math.sin(2 * Math.PI * (s + 1) / this._sides);
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }
                } else if (this._orientation == WireframeRegularPolygon.ORIENTATION_XZ) {
                    v0.y = 0;
                    v1.y = 0;

                    for (s = 0; s < this._sides; ++s) {
                        v0.x = this._radius * Math.cos(2 * Math.PI * s / this._sides);
                        v0.z = this._radius * Math.sin(2 * Math.PI * s / this._sides);
                        v1.x = this._radius * Math.cos(2 * Math.PI * (s + 1) / this._sides);
                        v1.z = this._radius * Math.sin(2 * Math.PI * (s + 1) / this._sides);
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }
                } else if (this._orientation == WireframeRegularPolygon.ORIENTATION_YZ) {
                    v0.x = 0;
                    v1.x = 0;

                    for (s = 0; s < this._sides; ++s) {
                        v0.z = this._radius * Math.cos(2 * Math.PI * s / this._sides);
                        v0.y = this._radius * Math.sin(2 * Math.PI * s / this._sides);
                        v1.z = this._radius * Math.cos(2 * Math.PI * (s + 1) / this._sides);
                        v1.y = this._radius * Math.sin(2 * Math.PI * (s + 1) / this._sides);
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }
                }
            };
            WireframeRegularPolygon.ORIENTATION_YZ = "yz";
            WireframeRegularPolygon.ORIENTATION_XY = "xy";
            WireframeRegularPolygon.ORIENTATION_XZ = "xz";
            return WireframeRegularPolygon;
        })(away.primitives.WireframePrimitiveBase);
        primitives.WireframeRegularPolygon = WireframeRegularPolygon;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (primitives) {
        //TODO - convert to geometry primitive
        /**
        * A WireframeTetrahedron primitive mesh
        */
        var WireframeTetrahedron = (function (_super) {
            __extends(WireframeTetrahedron, _super);
            /**
            * Creates a new WireframeTetrahedron object.
            * @param width The size of the tetrahedron buttom size.
            * @param height The size of the tetranhedron height.
            * @param color The color of the wireframe lines.
            * @param thickness The thickness of the wireframe lines.
            */
            function WireframeTetrahedron(width, height, color, thickness, orientation) {
                if (typeof color === "undefined") { color = 0xffffff; }
                if (typeof thickness === "undefined") { thickness = 1; }
                if (typeof orientation === "undefined") { orientation = "yz"; }
                _super.call(this, color, thickness);

                this._orientation = orientation;

                this.width = width;
                this.height = height;
            }
            Object.defineProperty(WireframeTetrahedron.prototype, "orientation", {
                get: /**
                * The orientation in which the plane lies
                */
                function () {
                    return this._orientation;
                },
                set: function (value) {
                    this._orientation = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            WireframeTetrahedron.prototype.pBuildGeometry = function () {
                var bv0;
                var bv1;
                var bv2;
                var bv3;
                var top;

                var hw = 0.5;

                switch (this._orientation) {
                    case WireframeTetrahedron.ORIENTATION_XY:
                        bv0 = new away.geom.Vector3D(-hw, hw, 0);
                        bv1 = new away.geom.Vector3D(hw, hw, 0);
                        bv2 = new away.geom.Vector3D(hw, -hw, 0);
                        bv3 = new away.geom.Vector3D(-hw, -hw, 0);
                        top = new away.geom.Vector3D(0, 0, 1);
                        break;
                    case WireframeTetrahedron.ORIENTATION_XZ:
                        bv0 = new away.geom.Vector3D(-hw, 0, hw);
                        bv1 = new away.geom.Vector3D(hw, 0, hw);
                        bv2 = new away.geom.Vector3D(hw, 0, -hw);
                        bv3 = new away.geom.Vector3D(-hw, 0, -hw);
                        top = new away.geom.Vector3D(0, 1, 0);
                        break;
                    case WireframeTetrahedron.ORIENTATION_YZ:
                        bv0 = new away.geom.Vector3D(0, -hw, hw);
                        bv1 = new away.geom.Vector3D(0, hw, hw);
                        bv2 = new away.geom.Vector3D(0, hw, -hw);
                        bv3 = new away.geom.Vector3D(0, -hw, -hw);
                        top = new away.geom.Vector3D(1, 0, 0);
                        break;
                }

                //bottom
                this.pUpdateOrAddSegment(0, bv0, bv1);
                this.pUpdateOrAddSegment(1, bv1, bv2);
                this.pUpdateOrAddSegment(2, bv2, bv3);
                this.pUpdateOrAddSegment(3, bv3, bv0);

                //bottom to top
                this.pUpdateOrAddSegment(4, bv0, top);
                this.pUpdateOrAddSegment(5, bv1, top);
                this.pUpdateOrAddSegment(6, bv2, top);
                this.pUpdateOrAddSegment(7, bv3, top);
            };
            WireframeTetrahedron.ORIENTATION_YZ = "yz";
            WireframeTetrahedron.ORIENTATION_XY = "xy";
            WireframeTetrahedron.ORIENTATION_XZ = "xz";
            return WireframeTetrahedron;
        })(away.primitives.WireframePrimitiveBase);
        primitives.WireframeTetrahedron = WireframeTetrahedron;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (utils) {
        var GeometryUtils = (function () {
            function GeometryUtils() {
            }
            GeometryUtils.fromVectors = /**
            * Build a list of sub-geometries from raw data vectors, splitting them up in
            * such a way that they won't exceed buffer length limits.
            */
            function (verts, indices/*uint*/ , uvs, normals, tangents, weights, jointIndices, triangleOffset) {
                if (typeof triangleOffset === "undefined") { triangleOffset = 0; }
                var LIMIT_VERTS = 3 * 0xffff;
                var LIMIT_INDICES = 15 * 0xffff;

                var subs = new Array();

                if (uvs && !uvs.length)
                    uvs = null;

                if (normals && !normals.length)
                    normals = null;

                if (tangents && !tangents.length)
                    tangents = null;

                if (weights && !weights.length)
                    weights = null;

                if (jointIndices && !jointIndices.length)
                    jointIndices = null;

                if ((indices.length >= LIMIT_INDICES) || (verts.length >= LIMIT_VERTS)) {
                    var i;
                    var len;
                    var outIndex;
                    var j;
                    var splitVerts = new Array();
                    var splitIndices = new Array();
                    var splitUvs = (uvs != null) ? new Array() : null;
                    var splitNormals = (normals != null) ? new Array() : null;
                    var splitTangents = (tangents != null) ? new Array() : null;
                    var splitWeights = (weights != null) ? new Array() : null;
                    var splitJointIndices = (jointIndices != null) ? new Array() : null;

                    var mappings = new Array(verts.length / 3);

                    i = mappings.length;

                    while (i-- > 0) {
                        mappings[i] = -1;
                    }

                    var originalIndex;
                    var splitIndex;
                    var o0;
                    var o1;
                    var o2;
                    var s0;
                    var s1;
                    var s2;
                    var su;
                    var ou;
                    var sv;
                    var ov;

                    // Loop over all triangles
                    outIndex = 0;
                    len = indices.length;

                    for (i = 0; i < len; i += 3) {
                        splitIndex = splitVerts.length + 6;

                        if (((outIndex + 2) >= LIMIT_INDICES) || (splitIndex >= LIMIT_VERTS)) {
                            subs.push(GeometryUtils.constructSubGeometry(splitVerts, splitIndices, splitUvs, splitNormals, splitTangents, splitWeights, splitJointIndices, triangleOffset));
                            splitVerts = new Array();
                            splitIndices = new Array();
                            splitUvs = (uvs != null) ? new Array() : null;
                            splitNormals = (normals != null) ? new Array() : null;
                            splitTangents = (tangents != null) ? new Array() : null;
                            splitWeights = (weights != null) ? new Array() : null;
                            splitJointIndices = (jointIndices != null) ? new Array() : null;
                            splitIndex = 0;
                            j = mappings.length;

                            while (j-- > 0) {
                                mappings[j] = -1;
                            }

                            outIndex = 0;
                        }

                        for (j = 0; j < 3; j++) {
                            originalIndex = indices[i + j];

                            if (mappings[originalIndex] >= 0) {
                                splitIndex = mappings[originalIndex];
                            } else {
                                o0 = originalIndex * 3 + 0;
                                o1 = originalIndex * 3 + 1;
                                o2 = originalIndex * 3 + 2;

                                // This vertex does not yet exist in the split list and
                                // needs to be copied from the long list.
                                splitIndex = splitVerts.length / 3;

                                s0 = splitIndex * 3 + 0;
                                s1 = splitIndex * 3 + 1;
                                s2 = splitIndex * 3 + 2;

                                splitVerts[s0] = verts[o0];
                                splitVerts[s1] = verts[o1];
                                splitVerts[s2] = verts[o2];

                                if (uvs) {
                                    su = splitIndex * 2 + 0;
                                    sv = splitIndex * 2 + 1;
                                    ou = originalIndex * 2 + 0;
                                    ov = originalIndex * 2 + 1;

                                    splitUvs[su] = uvs[ou];
                                    splitUvs[sv] = uvs[ov];
                                }

                                if (normals) {
                                    splitNormals[s0] = normals[o0];
                                    splitNormals[s1] = normals[o1];
                                    splitNormals[s2] = normals[o2];
                                }

                                if (tangents) {
                                    splitTangents[s0] = tangents[o0];
                                    splitTangents[s1] = tangents[o1];
                                    splitTangents[s2] = tangents[o2];
                                }

                                if (weights) {
                                    splitWeights[s0] = weights[o0];
                                    splitWeights[s1] = weights[o1];
                                    splitWeights[s2] = weights[o2];
                                }

                                if (jointIndices) {
                                    splitJointIndices[s0] = jointIndices[o0];
                                    splitJointIndices[s1] = jointIndices[o1];
                                    splitJointIndices[s2] = jointIndices[o2];
                                }

                                mappings[originalIndex] = splitIndex;
                            }

                            // Store new index, which may have come from the mapping look-up,
                            // or from copying a new set of vertex data from the original vector
                            splitIndices[outIndex + j] = splitIndex;
                        }

                        outIndex += 3;
                    }

                    if (splitVerts.length > 0) {
                        // More was added in the last iteration of the loop.
                        subs.push(GeometryUtils.constructSubGeometry(splitVerts, splitIndices, splitUvs, splitNormals, splitTangents, splitWeights, splitJointIndices, triangleOffset));
                    }
                } else {
                    subs.push(GeometryUtils.constructSubGeometry(verts, indices, uvs, normals, tangents, weights, jointIndices, triangleOffset));
                }

                return subs;
            };

            GeometryUtils.constructSubGeometry = /**
            * Build a sub-geometry from data vectors.
            */
            function (verts, indices/*uint*/ , uvs, normals, tangents, weights, jointIndices, triangleOffset) {
                var sub;

                if (weights && jointIndices) {
                    // If there were weights and joint indices defined, this
                    // is a skinned mesh and needs to be built from skinned
                    // sub-geometries.
                    sub = new away.base.SkinnedSubGeometry(weights.length / (verts.length / 3));

                    var ssg = sub;

                    ssg.iUpdateJointWeightsData(weights);
                    ssg.iUpdateJointIndexData(jointIndices);
                } else {
                    sub = new away.base.CompactSubGeometry();
                }

                sub.updateIndexData(indices);
                sub.fromVectors(verts, uvs, normals, tangents);

                return sub;
            };

            GeometryUtils.interleaveBuffers = /*
            * Combines a set of separate raw buffers into an interleaved one, compatible
            * with CompactSubGeometry. SubGeometry uses separate buffers, whereas CompactSubGeometry
            * uses a single, combined buffer.
            * */
            function (numVertices, vertices, normals, tangents, uvs, suvs) {
                if (typeof vertices === "undefined") { vertices = null; }
                if (typeof normals === "undefined") { normals = null; }
                if (typeof tangents === "undefined") { tangents = null; }
                if (typeof uvs === "undefined") { uvs = null; }
                if (typeof suvs === "undefined") { suvs = null; }
                var i, compIndex, uvCompIndex, interleavedCompIndex;
                var interleavedBuffer;

                interleavedBuffer = new Array();

                for (i = 0; i < numVertices; ++i) {
                    uvCompIndex = i * 2;
                    compIndex = i * 3;
                    interleavedCompIndex = i * 13;

                    interleavedBuffer[interleavedCompIndex] = vertices ? vertices[compIndex] : 0;
                    interleavedBuffer[interleavedCompIndex + 1] = vertices ? vertices[compIndex + 1] : 0;
                    interleavedBuffer[interleavedCompIndex + 2] = vertices ? vertices[compIndex + 2] : 0;
                    interleavedBuffer[interleavedCompIndex + 3] = normals ? normals[compIndex] : 0;
                    interleavedBuffer[interleavedCompIndex + 4] = normals ? normals[compIndex + 1] : 0;
                    interleavedBuffer[interleavedCompIndex + 5] = normals ? normals[compIndex + 2] : 0;
                    interleavedBuffer[interleavedCompIndex + 6] = tangents ? tangents[compIndex] : 0;
                    interleavedBuffer[interleavedCompIndex + 7] = tangents ? tangents[compIndex + 1] : 0;
                    interleavedBuffer[interleavedCompIndex + 8] = tangents ? tangents[compIndex + 2] : 0;
                    interleavedBuffer[interleavedCompIndex + 9] = uvs ? uvs[uvCompIndex] : 0;
                    interleavedBuffer[interleavedCompIndex + 10] = uvs ? uvs[uvCompIndex + 1] : 0;
                    interleavedBuffer[interleavedCompIndex + 11] = suvs ? suvs[uvCompIndex] : 0;
                    interleavedBuffer[interleavedCompIndex + 12] = suvs ? suvs[uvCompIndex + 1] : 0;
                }

                return interleavedBuffer;
            };

            GeometryUtils.getMeshSubGeometryIndex = /*
            * returns the subGeometry index in its parent mesh subgeometries vector
            */
            function (subGeometry) {
                var index;
                var subGeometries = subGeometry.parentGeometry.subGeometries;

                for (var i = 0; i < subGeometries.length; ++i) {
                    if (subGeometries[i] == subGeometry) {
                        index = i;
                        break;
                    }
                }

                return index;
            };

            GeometryUtils.getMeshSubMeshIndex = /*
            * returns the subMesh index in its parent mesh subMeshes vector
            */
            function (subMesh) {
                var index;
                var subMeshes = (subMesh.sourceEntity).subMeshes;

                for (var i = 0; i < subMeshes.length; ++i) {
                    if (subMeshes[i] == subMesh) {
                        index = i;
                        break;
                    }
                }

                return index;
            };
            return GeometryUtils;
        })();
        utils.GeometryUtils = GeometryUtils;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (utils) {
        var PerspectiveMatrix3D = (function (_super) {
            __extends(PerspectiveMatrix3D, _super);
            function PerspectiveMatrix3D(v) {
                if (typeof v === "undefined") { v = null; }
                _super.call(this, v);
            }
            PerspectiveMatrix3D.prototype.perspectiveFieldOfViewLH = function (fieldOfViewY, aspectRatio, zNear, zFar) {
                var yScale = 1 / Math.tan(fieldOfViewY / 2);
                var xScale = yScale / aspectRatio;
                this.copyRawDataFrom([xScale, 0.0, 0.0, 0.0, 0.0, yScale, 0.0, 0.0, 0.0, 0.0, zFar / (zFar - zNear), 1.0, 0.0, 0.0, (zNear * zFar) / (zNear - zFar), 0.0]);
            };
            return PerspectiveMatrix3D;
        })(away.geom.Matrix3D);
        utils.PerspectiveMatrix3D = PerspectiveMatrix3D;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;
        var Matrix3D = away.geom.Matrix3D;

        /**
        * ...
        */
        var AnimationRegisterCache = (function (_super) {
            __extends(AnimationRegisterCache, _super);
            function AnimationRegisterCache(profile) {
                _super.call(this, profile);
                this.indexDictionary = new Object();
                this.vertexConstantData = new Array();
                this.fragmentConstantData = new Array();
            }
            AnimationRegisterCache.prototype.reset = function () {
                _super.prototype.reset.call(this);

                this.rotationRegisters = new Array();
                this.positionAttribute = this.getRegisterFromString(this.sourceRegisters[0]);
                this.scaleAndRotateTarget = this.getRegisterFromString(this.targetRegisters[0]);
                this.addVertexTempUsages(this.scaleAndRotateTarget, 1);

                for (var i = 1; i < this.targetRegisters.length; i++) {
                    this.rotationRegisters.push(this.getRegisterFromString(this.targetRegisters[i]));
                    this.addVertexTempUsages(this.rotationRegisters[i - 1], 1);
                }

                this.scaleAndRotateTarget = new ShaderRegisterElement(this.scaleAndRotateTarget.regName, this.scaleAndRotateTarget.index);

                //allot const register
                this.vertexZeroConst = this.getFreeVertexConstant();
                this.vertexZeroConst = new ShaderRegisterElement(this.vertexZeroConst.regName, this.vertexZeroConst.index, 0);
                this.vertexOneConst = new ShaderRegisterElement(this.vertexZeroConst.regName, this.vertexZeroConst.index, 1);
                this.vertexTwoConst = new ShaderRegisterElement(this.vertexZeroConst.regName, this.vertexZeroConst.index, 2);

                //allot temp register
                this.positionTarget = this.getFreeVertexVectorTemp();
                this.addVertexTempUsages(this.positionTarget, 1);
                this.positionTarget = new ShaderRegisterElement(this.positionTarget.regName, this.positionTarget.index);

                if (this.needVelocity) {
                    this.velocityTarget = this.getFreeVertexVectorTemp();
                    this.addVertexTempUsages(this.velocityTarget, 1);
                    this.velocityTarget = new ShaderRegisterElement(this.velocityTarget.regName, this.velocityTarget.index);
                    this.vertexTime = new ShaderRegisterElement(this.velocityTarget.regName, this.velocityTarget.index, 3);
                    this.vertexLife = new ShaderRegisterElement(this.positionTarget.regName, this.positionTarget.index, 3);
                } else {
                    var tempTime = this.getFreeVertexVectorTemp();
                    this.addVertexTempUsages(tempTime, 1);
                    this.vertexTime = new ShaderRegisterElement(tempTime.regName, tempTime.index, 0);
                    this.vertexLife = new ShaderRegisterElement(tempTime.regName, tempTime.index, 1);
                }
            };

            AnimationRegisterCache.prototype.setUVSourceAndTarget = function (UVAttribute, UVVaring) {
                this.uvVar = this.getRegisterFromString(UVVaring);
                this.uvAttribute = this.getRegisterFromString(UVAttribute);

                //uv action is processed after normal actions,so use offsetTarget as uvTarget
                this.uvTarget = new ShaderRegisterElement(this.positionTarget.regName, this.positionTarget.index);
            };

            AnimationRegisterCache.prototype.setRegisterIndex = function (node, parameterIndex/*int*/ , registerIndex/*int*/ ) {
                //8 should be enough for any node.
                var t = this.indexDictionary[node.id];

                if (t == null)
                    t = this.indexDictionary[node.id] = new Array(8);

                t[parameterIndex] = registerIndex;
            };

            AnimationRegisterCache.prototype.getRegisterIndex = function (node, parameterIndex/*int*/ ) {
                return (this.indexDictionary[node.id])[parameterIndex];
            };

            AnimationRegisterCache.prototype.getInitCode = function () {
                var len = this.sourceRegisters.length;
                var code = "";
                for (var i = 0; i < len; i++)
                    code += "mov " + this.targetRegisters[i] + "," + this.sourceRegisters[i] + "\n";

                code += "mov " + this.positionTarget + ".xyz," + this.vertexZeroConst.toString() + "\n";

                if (this.needVelocity)
                    code += "mov " + this.velocityTarget + ".xyz," + this.vertexZeroConst.toString() + "\n";

                return code;
            };

            AnimationRegisterCache.prototype.getCombinationCode = function () {
                return "add " + this.scaleAndRotateTarget + ".xyz," + this.scaleAndRotateTarget + ".xyz," + this.positionTarget + ".xyz\n";
            };

            AnimationRegisterCache.prototype.initColorRegisters = function () {
                var code = "";
                if (this.hasColorMulNode) {
                    this.colorMulTarget = this.getFreeVertexVectorTemp();
                    this.addVertexTempUsages(this.colorMulTarget, 1);
                    this.colorMulVary = this.getFreeVarying();
                    code += "mov " + this.colorMulTarget + "," + this.vertexOneConst + "\n";
                }
                if (this.hasColorAddNode) {
                    this.colorAddTarget = this.getFreeVertexVectorTemp();
                    this.addVertexTempUsages(this.colorAddTarget, 1);
                    this.colorAddVary = this.getFreeVarying();
                    code += "mov " + this.colorAddTarget + "," + this.vertexZeroConst + "\n";
                }
                return code;
            };

            AnimationRegisterCache.prototype.getColorPassCode = function () {
                var code = "";
                if (this.needFragmentAnimation && (this.hasColorAddNode || this.hasColorMulNode)) {
                    if (this.hasColorMulNode)
                        code += "mov " + this.colorMulVary + "," + this.colorMulTarget + "\n";
                    if (this.hasColorAddNode)
                        code += "mov " + this.colorAddVary + "," + this.colorAddTarget + "\n";
                }
                return code;
            };

            AnimationRegisterCache.prototype.getColorCombinationCode = function (shadedTarget) {
                var code = "";
                if (this.needFragmentAnimation && (this.hasColorAddNode || this.hasColorMulNode)) {
                    var colorTarget = this.getRegisterFromString(shadedTarget);
                    this.addFragmentTempUsages(colorTarget, 1);
                    if (this.hasColorMulNode)
                        code += "mul " + colorTarget + "," + colorTarget + "," + this.colorMulVary + "\n";
                    if (this.hasColorAddNode)
                        code += "add " + colorTarget + "," + colorTarget + "," + this.colorAddVary + "\n";
                }
                return code;
            };

            AnimationRegisterCache.prototype.getRegisterFromString = function (code) {
                var temp = code.split(/(\d+)/);
                return new ShaderRegisterElement(temp[0], parseInt(temp[1]));
            };

            Object.defineProperty(AnimationRegisterCache.prototype, "numVertexConstant", {
                get: function () {
                    return this._numVertexConstant;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationRegisterCache.prototype, "numFragmentConstant", {
                get: function () {
                    return this._numFragmentConstant;
                },
                enumerable: true,
                configurable: true
            });

            AnimationRegisterCache.prototype.setDataLength = function () {
                this._numVertexConstant = this.numUsedVertexConstants - this.vertexConstantOffset;
                this._numFragmentConstant = this.numUsedFragmentConstants - this.fragmentConstantOffset;
                this.vertexConstantData.length = this._numVertexConstant * 4;
                this.fragmentConstantData.length = this._numFragmentConstant * 4;
            };

            AnimationRegisterCache.prototype.setVertexConst = function (index/*int*/ , x, y, z, w) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof z === "undefined") { z = 0; }
                if (typeof w === "undefined") { w = 0; }
                var _index = (index - this.vertexConstantOffset) * 4;
                this.vertexConstantData[_index++] = x;
                this.vertexConstantData[_index++] = y;
                this.vertexConstantData[_index++] = z;
                this.vertexConstantData[_index] = w;
            };

            AnimationRegisterCache.prototype.setVertexConstFromArray = function (index/*int*/ , data) {
                var _index = (index - this.vertexConstantOffset) * 4;
                for (var i = 0; i < data.length; i++)
                    this.vertexConstantData[_index++] = data[i];
            };

            AnimationRegisterCache.prototype.setVertexConstFromMatrix = function (index/*int*/ , matrix) {
                var rawData = matrix.rawData;
                var _index = (index - this.vertexConstantOffset) * 4;
                this.vertexConstantData[_index++] = rawData[0];
                this.vertexConstantData[_index++] = rawData[4];
                this.vertexConstantData[_index++] = rawData[8];
                this.vertexConstantData[_index++] = rawData[12];
                this.vertexConstantData[_index++] = rawData[1];
                this.vertexConstantData[_index++] = rawData[5];
                this.vertexConstantData[_index++] = rawData[9];
                this.vertexConstantData[_index++] = rawData[13];
                this.vertexConstantData[_index++] = rawData[2];
                this.vertexConstantData[_index++] = rawData[6];
                this.vertexConstantData[_index++] = rawData[10];
                this.vertexConstantData[_index++] = rawData[14];
                this.vertexConstantData[_index++] = rawData[3];
                this.vertexConstantData[_index++] = rawData[7];
                this.vertexConstantData[_index++] = rawData[11];
                this.vertexConstantData[_index] = rawData[15];
            };

            AnimationRegisterCache.prototype.setFragmentConst = function (index/*int*/ , x, y, z, w) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof z === "undefined") { z = 0; }
                if (typeof w === "undefined") { w = 0; }
                var _index = (index - this.fragmentConstantOffset) * 4;
                this.fragmentConstantData[_index++] = x;
                this.fragmentConstantData[_index++] = y;
                this.fragmentConstantData[_index++] = z;
                this.fragmentConstantData[_index] = w;
            };
            return AnimationRegisterCache;
        })(away.materials.ShaderRegisterCache);
        animators.AnimationRegisterCache = AnimationRegisterCache;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var StageGL = away.base.StageGL;
        var ContextGL = away.gl.ContextGL;
        var VertexBuffer = away.gl.VertexBuffer;

        /**
        * ...
        */
        var AnimationSubGeometry = (function () {
            function AnimationSubGeometry() {
                this._pVertexBuffer = new Array(8);
                this._pBufferContext = new Array(8);
                this._pBufferDirty = new Array(8);
                this.numProcessedVertices = 0;
                this.previousTime = Number.NEGATIVE_INFINITY;
                this.animationParticles = new Array();
                for (var i = 0; i < 8; i++)
                    this._pBufferDirty[i] = true;

                this._iUniqueId = AnimationSubGeometry.SUBGEOM_ID_COUNT++;
            }
            AnimationSubGeometry.prototype.createVertexData = function (numVertices/*uint*/ , totalLenOfOneVertex/*uint*/ ) {
                this._numVertices = numVertices;
                this._totalLenOfOneVertex = totalLenOfOneVertex;
                this._pVertexData = new Array(numVertices * totalLenOfOneVertex);
            };

            //TODO Why does Typescript complain when stageGL type away.base.StageGL is changed to StageGL?
            AnimationSubGeometry.prototype.activateVertexBuffer = function (index/*int*/ , bufferOffset/*int*/ , stageGL, format) {
                var contextIndex = stageGL.stageGLIndex;
                var context = stageGL.contextGL;

                var buffer = this._pVertexBuffer[contextIndex];
                if (!buffer || this._pBufferContext[contextIndex] != context) {
                    buffer = this._pVertexBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, this._totalLenOfOneVertex);
                    this._pBufferContext[contextIndex] = context;
                    this._pBufferDirty[contextIndex] = true;
                }
                if (this._pBufferDirty[contextIndex]) {
                    buffer.uploadFromArray(this._pVertexData, 0, this._numVertices);
                    this._pBufferDirty[contextIndex] = false;
                }
                context.setVertexBufferAt(index, buffer, bufferOffset, format);
            };

            AnimationSubGeometry.prototype.dispose = function () {
                while (this._pVertexBuffer.length) {
                    var vertexBuffer = this._pVertexBuffer.pop();

                    if (vertexBuffer)
                        vertexBuffer.dispose();
                }
            };

            AnimationSubGeometry.prototype.invalidateBuffer = function () {
                for (var i = 0; i < 8; i++)
                    this._pBufferDirty[i] = true;
            };

            Object.defineProperty(AnimationSubGeometry.prototype, "vertexData", {
                get: function () {
                    return this._pVertexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationSubGeometry.prototype, "numVertices", {
                get: function () {
                    return this._numVertices;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationSubGeometry.prototype, "totalLenOfOneVertex", {
                get: function () {
                    return this._totalLenOfOneVertex;
                },
                enumerable: true,
                configurable: true
            });
            AnimationSubGeometry.SUBGEOM_ID_COUNT = 0;
            return AnimationSubGeometry;
        })();
        animators.AnimationSubGeometry = AnimationSubGeometry;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var ColorTransform = away.geom.ColorTransform;

        var ColorSegmentPoint = (function () {
            function ColorSegmentPoint(life, color) {
                if (life <= 0 || life >= 1)
                    throw (new Error("life exceeds range (0,1)"));
                this._life = life;
                this._color = color;
            }
            Object.defineProperty(ColorSegmentPoint.prototype, "color", {
                get: function () {
                    return this._color;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ColorSegmentPoint.prototype, "life", {
                get: function () {
                    return this._life;
                },
                enumerable: true,
                configurable: true
            });
            return ColorSegmentPoint;
        })();
        animators.ColorSegmentPoint = ColorSegmentPoint;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var Matrix3D = away.geom.Matrix3D;
        var Quaternion = away.geom.Quaternion;

        /**
        * Contains transformation data for a skeleton joint, used for skeleton animation.
        *
        * @see away.animation.Skeleton
        * @see away.animation.SkeletonJoint
        *
        * todo: support (uniform) scale
        */
        var JointPose = (function () {
            function JointPose() {
                /**
                * The rotation of the pose stored as a quaternion
                */
                this.orientation = new Quaternion();
                /**
                * The translation of the pose
                */
                this.translation = new Vector3D();
            }
            /**
            * Converts the transformation to a Matrix3D representation.
            *
            * @param target An optional target matrix to store the transformation. If not provided, it will create a new instance.
            * @return The transformation matrix of the pose.
            */
            JointPose.prototype.toMatrix3D = function (target) {
                if (typeof target === "undefined") { target = null; }
                if (target == null)
                    target = new Matrix3D();

                this.orientation.toMatrix3D(target);
                target.appendTranslation(this.translation.x, this.translation.y, this.translation.z);
                return target;
            };

            /**
            * Copies the transformation data from a source pose object into the existing pose object.
            *
            * @param pose The source pose to copy from.
            */
            JointPose.prototype.copyFrom = function (pose) {
                var or = pose.orientation;
                var tr = pose.translation;
                this.orientation.x = or.x;
                this.orientation.y = or.y;
                this.orientation.z = or.z;
                this.orientation.w = or.w;
                this.translation.x = tr.x;
                this.translation.y = tr.y;
                this.translation.z = tr.z;
            };
            return JointPose;
        })();
        animators.JointPose = JointPose;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * ...
        */
        var ParticleAnimationData = (function () {
            function ParticleAnimationData(index/*uint*/ , startTime, duration, delay, particle) {
                this.index = index;
                this.startTime = startTime;
                this.totalTime = duration + delay;
                this.duration = duration;
                this.delay = delay;
                this.startVertexIndex = particle.startVertexIndex;
                this.numVertices = particle.numVertices;
            }
            return ParticleAnimationData;
        })();
        animators.ParticleAnimationData = ParticleAnimationData;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var CompactSubGeometry = away.base.CompactSubGeometry;

        var ParticleData = (function () {
            function ParticleData() {
            }
            return ParticleData;
        })();
        animators.ParticleData = ParticleData;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * Dynamic class for holding the local properties of a particle, used for processing the static properties
        * of particles in the particle animation set before beginning upload to the GPU.
        */
        var ParticleProperties = (function () {
            function ParticleProperties() {
            }
            return ParticleProperties;
        })();
        animators.ParticleProperties = ParticleProperties;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * Options for setting the properties mode of a particle animation node.
        */
        var ParticlePropertiesMode = (function () {
            function ParticlePropertiesMode() {
            }
            ParticlePropertiesMode.GLOBAL = 0;

            ParticlePropertiesMode.LOCAL_STATIC = 1;

            ParticlePropertiesMode.LOCAL_DYNAMIC = 2;
            return ParticlePropertiesMode;
        })();
        animators.ParticlePropertiesMode = ParticlePropertiesMode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var AssetType = away.library.AssetType;

        /**
        * A Skeleton object is a hierarchical grouping of joint objects that can be used for skeletal animation.
        *
        * @see away.animators.SkeletonJoint
        */
        var Skeleton = (function (_super) {
            __extends(Skeleton, _super);
            /**
            * Creates a new <code>Skeleton</code> object
            */
            function Skeleton() {
                _super.call(this);

                // in the long run, it might be a better idea to not store Joint objects, but keep all data in Vectors, that we can upload easily?
                this.joints = new Array();
            }
            Object.defineProperty(Skeleton.prototype, "numJoints", {
                get: /**
                * The total number of joints in the skeleton.
                */
                function () {
                    return this.joints.length;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns the joint object in the skeleton with the given name, otherwise returns a null object.
            *
            * @param jointName The name of the joint object to be found.
            * @return The joint object with the given name.
            *
            * @see #joints
            */
            Skeleton.prototype.jointFromName = function (jointName) {
                var jointIndex = this.jointIndexFromName(jointName);
                if (jointIndex != -1)
                    return this.joints[jointIndex];
else
                    return null;
            };

            /**
            * Returns the joint index, given the joint name. -1 is returned if the joint name is not found.
            *
            * @param jointName The name of the joint object to be found.
            * @return The index of the joint object in the joints Array
            *
            * @see #joints
            */
            Skeleton.prototype.jointIndexFromName = function (jointName) {
                // this is implemented as a linear search, rather than a possibly
                // more optimal method (Dictionary lookup, for example) because:
                // a) it is assumed that it will be called once for each joint
                // b) it is assumed that it will be called only during load, and not during main loop
                // c) maintaining a dictionary (for safety) would dictate an interface to access SkeletonJoints,
                //    rather than direct array access.  this would be sub-optimal.
                var jointIndex/*int*/ ;
                var joint;
                for (var i/*int*/ ; i < this.joints.length; i++) {
                    joint = this.joints[i];
                    if (joint.name == jointName)
                        return jointIndex;
                    jointIndex++;
                }

                return -1;
            };

            /**
            * @inheritDoc
            */
            Skeleton.prototype.dispose = function () {
                this.joints.length = 0;
            };

            Object.defineProperty(Skeleton.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return AssetType.SKELETON;
                },
                enumerable: true,
                configurable: true
            });
            return Skeleton;
        })(away.library.NamedAssetBase);
        animators.Skeleton = Skeleton;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * Options for setting the animation mode of a vertex animator object.
        *
        * @see away.animators.VertexAnimator
        */
        var VertexAnimationMode = (function () {
            function VertexAnimationMode() {
            }
            VertexAnimationMode.ADDITIVE = "additive";

            VertexAnimationMode.ABSOLUTE = "absolute";
            return VertexAnimationMode;
        })();
        animators.VertexAnimationMode = VertexAnimationMode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * A value obect representing a single joint in a skeleton object.
        *
        * @see away.animators.Skeleton
        */
        var SkeletonJoint = (function () {
            /**
            * Creates a new <code>SkeletonJoint</code> object
            */
            function SkeletonJoint() {
                /**
                * The index of the parent joint in the skeleton's joints vector.
                *
                * @see away.animators.Skeleton#joints
                */
                this.parentIndex = -1;
            }
            return SkeletonJoint;
        })();
        animators.SkeletonJoint = SkeletonJoint;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var AssetType = away.library.AssetType;

        /**
        * A collection of pose objects, determining the pose for an entire skeleton.
        * The <code>jointPoses</code> vector object corresponds to a skeleton's <code>joints</code> vector object, however, there is no
        * reference to a skeleton's instance, since several skeletons can be influenced by the same pose (eg: animation
        * clips are added to any animator with a valid skeleton)
        *
        * @see away.animators.Skeleton
        * @see away.animators.JointPose
        */
        var SkeletonPose = (function (_super) {
            __extends(SkeletonPose, _super);
            /**
            * Creates a new <code>SkeletonPose</code> object.
            */
            function SkeletonPose() {
                _super.call(this);

                this.jointPoses = new Array();
            }
            Object.defineProperty(SkeletonPose.prototype, "numJointPoses", {
                get: /**
                * The total number of joint poses in the skeleton pose.
                */
                function () {
                    return this.jointPoses.length;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkeletonPose.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return AssetType.SKELETON_POSE;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns the joint pose object with the given joint name, otherwise returns a null object.
            *
            * @param jointName The name of the joint object whose pose is to be found.
            * @return The pose object with the given joint name.
            */
            SkeletonPose.prototype.jointPoseFromName = function (jointName) {
                var jointPoseIndex = this.jointPoseIndexFromName(jointName);
                if (jointPoseIndex != -1)
                    return this.jointPoses[jointPoseIndex];
else
                    return null;
            };

            /**
            * Returns the pose index, given the joint name. -1 is returned if the joint name is not found in the pose.
            *
            * @param The name of the joint object whose pose is to be found.
            * @return The index of the pose object in the jointPoses Array
            *
            * @see #jointPoses
            */
            SkeletonPose.prototype.jointPoseIndexFromName = function (jointName) {
                // this is implemented as a linear search, rather than a possibly
                // more optimal method (Dictionary lookup, for example) because:
                // a) it is assumed that it will be called once for each joint
                // b) it is assumed that it will be called only during load, and not during main loop
                // c) maintaining a dictionary (for safety) would dictate an interface to access JointPoses,
                //    rather than direct array access.  this would be sub-optimal.
                var jointPoseIndex/*int*/ ;
                var jointPose;
                for (var i/*uint*/ ; i < this.jointPoses.length; i++) {
                    jointPose = this.jointPoses[i];
                    if (jointPose.name == jointName)
                        return jointPoseIndex;
                    jointPoseIndex++;
                }

                return -1;
            };

            /**
            * Creates a copy of the <code>SkeletonPose</code> object, with a dulpicate of its component joint poses.
            *
            * @return SkeletonPose
            */
            SkeletonPose.prototype.clone = function () {
                var clone = new SkeletonPose();
                var numJointPoses = this.jointPoses.length;
                for (var i = 0; i < numJointPoses; i++) {
                    var cloneJointPose = new animators.JointPose();
                    var thisJointPose = this.jointPoses[i];
                    cloneJointPose.name = thisJointPose.name;
                    cloneJointPose.copyFrom(thisJointPose);
                    clone.jointPoses[i] = cloneJointPose;
                }
                return clone;
            };

            /**
            * @inheritDoc
            */
            SkeletonPose.prototype.dispose = function () {
                this.jointPoses.length = 0;
            };
            return SkeletonPose;
        })(away.library.NamedAssetBase);
        animators.SkeletonPose = SkeletonPose;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * Provides an abstract base class for nodes in an animation blend tree.
        */
        var AnimationNodeBase = (function (_super) {
            __extends(AnimationNodeBase, _super);
            /**
            * Creates a new <code>AnimationNodeBase</code> object.
            */
            function AnimationNodeBase() {
                _super.call(this);
            }
            Object.defineProperty(AnimationNodeBase.prototype, "stateClass", {
                get: function () {
                    return this._pStateClass;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            AnimationNodeBase.prototype.dispose = function () {
            };

            Object.defineProperty(AnimationNodeBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.ANIMATION_NODE;
                },
                enumerable: true,
                configurable: true
            });
            return AnimationNodeBase;
        })(away.library.NamedAssetBase);
        animators.AnimationNodeBase = AnimationNodeBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * Provides an abstract base class for nodes with time-based animation data in an animation blend tree.
        */
        var AnimationClipNodeBase = (function (_super) {
            __extends(AnimationClipNodeBase, _super);
            /**
            * Creates a new <code>AnimationClipNodeBase</code> object.
            */
            function AnimationClipNodeBase() {
                _super.call(this);
                this._pLooping = true;
                this._pTotalDuration = 0;
                this._pStitchDirty = true;
                this._pStitchFinalFrame = false;
                this._pNumFrames = 0;
                this._pDurations = new Array();
                /*uint*/
                this._pTotalDelta = new away.geom.Vector3D();
                this.fixedFrameRate = true;
            }
            Object.defineProperty(AnimationClipNodeBase.prototype, "looping", {
                get: /**
                * Determines whether the contents of the animation node have looping characteristics enabled.
                */
                function () {
                    return this._pLooping;
                },
                set: function (value) {
                    if (this._pLooping == value)
                        return;

                    this._pLooping = value;

                    this._pStitchDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AnimationClipNodeBase.prototype, "stitchFinalFrame", {
                get: /**
                * Defines if looping content blends the final frame of animation data with the first (true) or works on the
                * assumption that both first and last frames are identical (false). Defaults to false.
                */
                function () {
                    return this._pStitchFinalFrame;
                },
                set: function (value) {
                    if (this._pStitchFinalFrame == value)
                        return;

                    this._pStitchFinalFrame = value;

                    this._pStitchDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AnimationClipNodeBase.prototype, "totalDuration", {
                get: function () {
                    if (this._pStitchDirty)
                        this._pUpdateStitch();

                    return this._pTotalDuration;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipNodeBase.prototype, "totalDelta", {
                get: function () {
                    if (this._pStitchDirty)
                        this._pUpdateStitch();

                    return this._pTotalDelta;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipNodeBase.prototype, "lastFrame", {
                get: function () {
                    if (this._pStitchDirty)
                        this._pUpdateStitch();

                    return this._pLastFrame;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipNodeBase.prototype, "durations", {
                get: /**
                * Returns a vector of time values representing the duration (in milliseconds) of each animation frame in the clip.
                */
                function () {
                    return this._pDurations;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the node's final frame stitch state.
            *
            * @see #stitchFinalFrame
            */
            AnimationClipNodeBase.prototype._pUpdateStitch = function () {
                this._pStitchDirty = false;

                this._pLastFrame = (this._pStitchFinalFrame) ? this._pNumFrames : this._pNumFrames - 1;

                this._pTotalDuration = 0;
                this._pTotalDelta.x = 0;
                this._pTotalDelta.y = 0;
                this._pTotalDelta.z = 0;
            };
            return AnimationClipNodeBase;
        })(animators.AnimationNodeBase);
        animators.AnimationClipNodeBase = AnimationClipNodeBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * Provides an abstract base class for particle animation nodes.
        */
        var ParticleNodeBase = (function (_super) {
            __extends(ParticleNodeBase, _super);
            /**
            * Creates a new <code>ParticleNodeBase</code> object.
            *
            * @param               name            Defines the generic name of the particle animation node.
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param               dataLength      Defines the length of the data used by the node when in <code>LOCAL_STATIC</code> mode.
            * @param    [optional] priority        the priority of the particle animation node, used to order the agal generated in a particle animation set. Defaults to 1.
            */
            function ParticleNodeBase(name, mode/*uint*/ , dataLength/*uint*/ , priority) {
                if (typeof priority === "undefined") { priority = 1; }
                _super.call(this);
                this._pDataLength = 3;

                name = name + ParticleNodeBase.MODES[mode];

                this.name = name;
                this._pMode = mode;
                this._priority = priority;
                this._pDataLength = dataLength;

                this._pOneData = new Array(this._pDataLength);
            }
            Object.defineProperty(ParticleNodeBase.prototype, "mode", {
                get: /**
                * Returns the property mode of the particle animation node. Typically set in the node constructor
                *
                * @see away.animators.ParticlePropertiesMode
                */
                function () {
                    return this._pMode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleNodeBase.prototype, "priority", {
                get: /**
                * Returns the priority of the particle animation node, used to order the agal generated in a particle animation set. Set automatically on instantiation.
                *
                * @see away.animators.ParticleAnimationSet
                * @see #getAGALVertexCode
                */
                function () {
                    return this._priority;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleNodeBase.prototype, "dataLength", {
                get: /**
                * Returns the length of the data used by the node when in <code>LOCAL_STATIC</code> mode. Used to generate the local static data of the particle animation set.
                *
                * @see away.animators.ParticleAnimationSet
                * @see #getAGALVertexCode
                */
                function () {
                    return this._pDataLength;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleNodeBase.prototype, "oneData", {
                get: /**
                * Returns the generated data vector of the node after one particle pass during the generation of all local static data of the particle animation set.
                *
                * @see away.animators.ParticleAnimationSet
                * @see #generatePropertyOfOneParticle
                */
                function () {
                    return this._pOneData;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns the AGAL code of the particle animation node for use in the vertex shader.
            */
            ParticleNodeBase.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                return "";
            };

            /**
            * Returns the AGAL code of the particle animation node for use in the fragment shader.
            */
            ParticleNodeBase.prototype.getAGALFragmentCode = function (pass, animationRegisterCache) {
                return "";
            };

            /**
            * Returns the AGAL code of the particle animation node for use in the fragment shader when UV coordinates are required.
            */
            ParticleNodeBase.prototype.getAGALUVCode = function (pass, animationRegisterCache) {
                return "";
            };

            /**
            * Called internally by the particle animation set when assigning the set of static properties originally defined by the initParticleFunc of the set.
            *
            * @see away.animators.ParticleAnimationSet#initParticleFunc
            */
            ParticleNodeBase.prototype._iGeneratePropertyOfOneParticle = function (param) {
            };

            /**
            * Called internally by the particle animation set when determining the requirements of the particle animation node AGAL.
            */
            ParticleNodeBase.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
            };
            ParticleNodeBase.GLOBAL = 'Global';
            ParticleNodeBase.LOCAL_STATIC = 'LocalStatic';
            ParticleNodeBase.LOCAL_DYNAMIC = 'LocalDynamic';

            ParticleNodeBase.MODES = {
                0: ParticleNodeBase.GLOBAL,
                1: ParticleNodeBase.LOCAL_STATIC,
                2: ParticleNodeBase.LOCAL_DYNAMIC
            };
            return ParticleNodeBase;
        })(animators.AnimationNodeBase);
        animators.ParticleNodeBase = ParticleNodeBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to apply a constant acceleration vector to the motion of a particle.
        */
        var ParticleAccelerationNode = (function (_super) {
            __extends(ParticleAccelerationNode, _super);
            /**
            * Creates a new <code>ParticleAccelerationNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] acceleration    Defines the default acceleration vector of the node, used when in global mode.
            */
            function ParticleAccelerationNode(mode/*uint*/ , acceleration) {
                if (typeof acceleration === "undefined") { acceleration = null; }
                _super.call(this, "ParticleAcceleration", mode, 3);

                this._pStateClass = animators.ParticleAccelerationState;

                this._acceleration = acceleration || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleAccelerationNode.prototype.pGetAGALVertexCode = function (pass, animationRegisterCache) {
                var accelerationValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleAccelerationNode.ACCELERATION_INDEX, accelerationValue.index);

                var temp = animationRegisterCache.getFreeVertexVectorTemp();
                animationRegisterCache.addVertexTempUsages(temp, 1);

                var code = "mul " + temp + "," + animationRegisterCache.vertexTime + "," + accelerationValue + "\n";

                if (animationRegisterCache.needVelocity) {
                    var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                    code += "mul " + temp2 + "," + temp + "," + animationRegisterCache.vertexTwoConst + "\n";
                    code += "add " + animationRegisterCache.velocityTarget + ".xyz," + temp2 + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
                }
                animationRegisterCache.removeVertexTempUsage(temp);

                code += "mul " + temp + "," + temp + "," + animationRegisterCache.vertexTime + "\n";
                code += "add " + animationRegisterCache.positionTarget + ".xyz," + temp + "," + animationRegisterCache.positionTarget + ".xyz\n";
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleAccelerationNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleAccelerationNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var tempAcceleration = param[ParticleAccelerationNode.ACCELERATION_VECTOR3D];
                if (!tempAcceleration)
                    throw new Error("there is no " + ParticleAccelerationNode.ACCELERATION_VECTOR3D + " in param!");

                this._pOneData[0] = tempAcceleration.x / 2;
                this._pOneData[1] = tempAcceleration.y / 2;
                this._pOneData[2] = tempAcceleration.z / 2;
            };
            ParticleAccelerationNode.ACCELERATION_INDEX = 0;

            ParticleAccelerationNode.ACCELERATION_VECTOR3D = "AccelerationVector3D";
            return ParticleAccelerationNode;
        })(animators.ParticleNodeBase);
        animators.ParticleAccelerationNode = ParticleAccelerationNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the position of a particle over time along a bezier curve.
        */
        var ParticleBezierCurveNode = (function (_super) {
            __extends(ParticleBezierCurveNode, _super);
            /**
            * Creates a new <code>ParticleBezierCurveNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] controlPoint    Defines the default control point of the node, used when in global mode.
            * @param    [optional] endPoint        Defines the default end point of the node, used when in global mode.
            */
            function ParticleBezierCurveNode(mode/*uint*/ , controlPoint, endPoint) {
                if (typeof controlPoint === "undefined") { controlPoint = null; }
                if (typeof endPoint === "undefined") { endPoint = null; }
                _super.call(this, "ParticleBezierCurve", mode, 6);

                this._pStateClass = animators.ParticleBezierCurveState;

                this._iControlPoint = controlPoint || new Vector3D();
                this._iEndPoint = endPoint || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleBezierCurveNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                pass = pass;
                var controlValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleBezierCurveNode.BEZIER_CONTROL_INDEX, controlValue.index);

                var endValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleBezierCurveNode.BEZIER_END_INDEX, endValue.index);

                var temp = animationRegisterCache.getFreeVertexVectorTemp();
                var rev_time = new ShaderRegisterElement(temp.regName, temp.index, 0);
                var time_2 = new ShaderRegisterElement(temp.regName, temp.index, 1);
                var time_temp = new ShaderRegisterElement(temp.regName, temp.index, 2);
                animationRegisterCache.addVertexTempUsages(temp, 1);
                var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                var distance = new ShaderRegisterElement(temp2.regName, temp2.index);
                animationRegisterCache.removeVertexTempUsage(temp);

                var code = "";
                code += "sub " + rev_time + "," + animationRegisterCache.vertexOneConst + "," + animationRegisterCache.vertexLife + "\n";
                code += "mul " + time_2 + "," + animationRegisterCache.vertexLife + "," + animationRegisterCache.vertexLife + "\n";

                code += "mul " + time_temp + "," + animationRegisterCache.vertexLife + "," + rev_time + "\n";
                code += "mul " + time_temp + "," + time_temp + "," + animationRegisterCache.vertexTwoConst + "\n";
                code += "mul " + distance + ".xyz," + time_temp + "," + controlValue + "\n";
                code += "add " + animationRegisterCache.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";
                code += "mul " + distance + ".xyz," + time_2 + "," + endValue + "\n";
                code += "add " + animationRegisterCache.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";

                if (animationRegisterCache.needVelocity) {
                    code += "mul " + time_2 + "," + animationRegisterCache.vertexLife + "," + animationRegisterCache.vertexTwoConst + "\n";
                    code += "sub " + time_temp + "," + animationRegisterCache.vertexOneConst + "," + time_2 + "\n";
                    code += "mul " + time_temp + "," + animationRegisterCache.vertexTwoConst + "," + time_temp + "\n";
                    code += "mul " + distance + ".xyz," + controlValue + "," + time_temp + "\n";
                    code += "add " + animationRegisterCache.velocityTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
                    code += "mul " + distance + ".xyz," + endValue + "," + time_2 + "\n";
                    code += "add " + animationRegisterCache.velocityTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleBezierCurveNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleBezierCurveNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var bezierControl = param[ParticleBezierCurveNode.BEZIER_CONTROL_VECTOR3D];
                if (!bezierControl)
                    throw new Error("there is no " + ParticleBezierCurveNode.BEZIER_CONTROL_VECTOR3D + " in param!");

                var bezierEnd = param[ParticleBezierCurveNode.BEZIER_END_VECTOR3D];
                if (!bezierEnd)
                    throw new Error("there is no " + ParticleBezierCurveNode.BEZIER_END_VECTOR3D + " in param!");

                this._pOneData[0] = bezierControl.x;
                this._pOneData[1] = bezierControl.y;
                this._pOneData[2] = bezierControl.z;
                this._pOneData[3] = bezierEnd.x;
                this._pOneData[4] = bezierEnd.y;
                this._pOneData[5] = bezierEnd.z;
            };
            ParticleBezierCurveNode.BEZIER_CONTROL_INDEX = 0;

            ParticleBezierCurveNode.BEZIER_END_INDEX = 1;

            ParticleBezierCurveNode.BEZIER_CONTROL_VECTOR3D = "BezierControlVector3D";

            ParticleBezierCurveNode.BEZIER_END_VECTOR3D = "BezierEndVector3D";
            return ParticleBezierCurveNode;
        })(animators.ParticleNodeBase);
        animators.ParticleBezierCurveNode = ParticleBezierCurveNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node that controls the rotation of a particle to always face the camera.
        */
        var ParticleBillboardNode = (function (_super) {
            __extends(ParticleBillboardNode, _super);
            /**
            * Creates a new <code>ParticleBillboardNode</code>
            */
            function ParticleBillboardNode(billboardAxis) {
                if (typeof billboardAxis === "undefined") { billboardAxis = null; }
                _super.call(this, "ParticleBillboard", animators.ParticlePropertiesMode.GLOBAL, 0, 4);

                this._pStateClass = animators.ParticleBillboardState;

                this._iBillboardAxis = billboardAxis;
            }
            /**
            * @inheritDoc
            */
            ParticleBillboardNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var rotationMatrixRegister = animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.setRegisterIndex(this, ParticleBillboardNode.MATRIX_INDEX, rotationMatrixRegister.index);
                animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.getFreeVertexConstant();

                var temp = animationRegisterCache.getFreeVertexVectorTemp();

                var code = "m33 " + temp + ".xyz," + animationRegisterCache.scaleAndRotateTarget + "," + rotationMatrixRegister + "\n" + "mov " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp + "\n";

                var shaderRegisterElement;
                for (var i = 0; i < animationRegisterCache.rotationRegisters.length; i++) {
                    shaderRegisterElement = animationRegisterCache.rotationRegisters[i];
                    code += "m33 " + temp + ".xyz," + shaderRegisterElement + "," + rotationMatrixRegister + "\n" + "mov " + shaderRegisterElement + ".xyz," + shaderRegisterElement + "\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleBillboardNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleBillboardNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                particleAnimationSet.hasBillboard = true;
            };
            ParticleBillboardNode.MATRIX_INDEX = 0;
            return ParticleBillboardNode;
        })(animators.ParticleNodeBase);
        animators.ParticleBillboardNode = ParticleBillboardNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var ColorTransform = away.geom.ColorTransform;
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the color variation of a particle over time.
        */
        var ParticleColorNode = (function (_super) {
            __extends(ParticleColorNode, _super);
            /**
            * Creates a new <code>ParticleColorNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] usesMultiplier  Defines whether the node uses multiplier data in the shader for its color transformations. Defaults to true.
            * @param    [optional] usesOffset      Defines whether the node uses offset data in the shader for its color transformations. Defaults to true.
            * @param    [optional] usesCycle       Defines whether the node uses the <code>cycleDuration</code> property in the shader to calculate the period of the animation independent of particle duration. Defaults to false.
            * @param    [optional] usesPhase       Defines whether the node uses the <code>cyclePhase</code> property in the shader to calculate a starting offset to the cycle rotation of the particle. Defaults to false.
            * @param    [optional] startColor      Defines the default start color transform of the node, when in global mode.
            * @param    [optional] endColor        Defines the default end color transform of the node, when in global mode.
            * @param    [optional] cycleDuration   Defines the duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
            * @param    [optional] cyclePhase      Defines the phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
            */
            function ParticleColorNode(mode/*uint*/ , usesMultiplier, usesOffset, usesCycle, usesPhase, startColor, endColor, cycleDuration, cyclePhase) {
                if (typeof usesMultiplier === "undefined") { usesMultiplier = true; }
                if (typeof usesOffset === "undefined") { usesOffset = true; }
                if (typeof usesCycle === "undefined") { usesCycle = false; }
                if (typeof usesPhase === "undefined") { usesPhase = false; }
                if (typeof startColor === "undefined") { startColor = null; }
                if (typeof endColor === "undefined") { endColor = null; }
                if (typeof cycleDuration === "undefined") { cycleDuration = 1; }
                if (typeof cyclePhase === "undefined") { cyclePhase = 0; }
                _super.call(this, "ParticleColor", mode, (usesMultiplier && usesOffset) ? 16 : 8, animators.ParticleAnimationSet.COLOR_PRIORITY);

                this._pStateClass = animators.ParticleColorState;

                this._iUsesMultiplier = usesMultiplier;
                this._iUsesOffset = usesOffset;
                this._iUsesCycle = usesCycle;
                this._iUsesPhase = usesPhase;

                this._iStartColor = startColor || new ColorTransform();
                this._iEndColor = endColor || new ColorTransform();
                this._iCycleDuration = cycleDuration;
                this._iCyclePhase = cyclePhase;
            }
            /**
            * @inheritDoc
            */
            ParticleColorNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var code = "";
                if (animationRegisterCache.needFragmentAnimation) {
                    var temp = animationRegisterCache.getFreeVertexVectorTemp();

                    if (this._iUsesCycle) {
                        var cycleConst = animationRegisterCache.getFreeVertexConstant();
                        animationRegisterCache.setRegisterIndex(this, ParticleColorNode.CYCLE_INDEX, cycleConst.index);

                        animationRegisterCache.addVertexTempUsages(temp, 1);
                        var sin = animationRegisterCache.getFreeVertexSingleTemp();
                        animationRegisterCache.removeVertexTempUsage(temp);

                        code += "mul " + sin + "," + animationRegisterCache.vertexTime + "," + cycleConst + ".x\n";

                        if (this._iUsesPhase)
                            code += "add " + sin + "," + sin + "," + cycleConst + ".y\n";

                        code += "sin " + sin + "," + sin + "\n";
                    }

                    if (this._iUsesMultiplier) {
                        var startMultiplierValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                        var deltaMultiplierValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();

                        animationRegisterCache.setRegisterIndex(this, ParticleColorNode.START_MULTIPLIER_INDEX, startMultiplierValue.index);
                        animationRegisterCache.setRegisterIndex(this, ParticleColorNode.DELTA_MULTIPLIER_INDEX, deltaMultiplierValue.index);

                        code += "mul " + temp + "," + deltaMultiplierValue + "," + (this._iUsesCycle ? sin : animationRegisterCache.vertexLife) + "\n";
                        code += "add " + temp + "," + temp + "," + startMultiplierValue + "\n";
                        code += "mul " + animationRegisterCache.colorMulTarget + "," + temp + "," + animationRegisterCache.colorMulTarget + "\n";
                    }

                    if (this._iUsesOffset) {
                        var startOffsetValue = (this._pMode == animators.ParticlePropertiesMode.LOCAL_STATIC) ? animationRegisterCache.getFreeVertexAttribute() : animationRegisterCache.getFreeVertexConstant();
                        var deltaOffsetValue = (this._pMode == animators.ParticlePropertiesMode.LOCAL_STATIC) ? animationRegisterCache.getFreeVertexAttribute() : animationRegisterCache.getFreeVertexConstant();

                        animationRegisterCache.setRegisterIndex(this, ParticleColorNode.START_OFFSET_INDEX, startOffsetValue.index);
                        animationRegisterCache.setRegisterIndex(this, ParticleColorNode.DELTA_OFFSET_INDEX, deltaOffsetValue.index);

                        code += "mul " + temp + "," + deltaOffsetValue + "," + (this._iUsesCycle ? sin : animationRegisterCache.vertexLife) + "\n";
                        code += "add " + temp + "," + temp + "," + startOffsetValue + "\n";
                        code += "add " + animationRegisterCache.colorAddTarget + "," + temp + "," + animationRegisterCache.colorAddTarget + "\n";
                    }
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleColorNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleColorNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                if (this._iUsesMultiplier)
                    particleAnimationSet.hasColorMulNode = true;
                if (this._iUsesOffset)
                    particleAnimationSet.hasColorAddNode = true;
            };

            /**
            * @inheritDoc
            */
            ParticleColorNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var startColor = param[ParticleColorNode.COLOR_START_COLORTRANSFORM];
                if (!startColor)
                    throw (new Error("there is no " + ParticleColorNode.COLOR_START_COLORTRANSFORM + " in param!"));

                var endColor = param[ParticleColorNode.COLOR_END_COLORTRANSFORM];
                if (!endColor)
                    throw (new Error("there is no " + ParticleColorNode.COLOR_END_COLORTRANSFORM + " in param!"));

                var i = 0;

                if (!this._iUsesCycle) {
                    if (this._iUsesMultiplier) {
                        this._pOneData[i++] = startColor.redMultiplier;
                        this._pOneData[i++] = startColor.greenMultiplier;
                        this._pOneData[i++] = startColor.blueMultiplier;
                        this._pOneData[i++] = startColor.alphaMultiplier;
                        this._pOneData[i++] = endColor.redMultiplier - startColor.redMultiplier;
                        this._pOneData[i++] = endColor.greenMultiplier - startColor.greenMultiplier;
                        this._pOneData[i++] = endColor.blueMultiplier - startColor.blueMultiplier;
                        this._pOneData[i++] = endColor.alphaMultiplier - startColor.alphaMultiplier;
                    }

                    if (this._iUsesOffset) {
                        this._pOneData[i++] = startColor.redOffset / 255;
                        this._pOneData[i++] = startColor.greenOffset / 255;
                        this._pOneData[i++] = startColor.blueOffset / 255;
                        this._pOneData[i++] = startColor.alphaOffset / 255;
                        this._pOneData[i++] = (endColor.redOffset - startColor.redOffset) / 255;
                        this._pOneData[i++] = (endColor.greenOffset - startColor.greenOffset) / 255;
                        this._pOneData[i++] = (endColor.blueOffset - startColor.blueOffset) / 255;
                        this._pOneData[i++] = (endColor.alphaOffset - startColor.alphaOffset) / 255;
                    }
                } else {
                    if (this._iUsesMultiplier) {
                        this._pOneData[i++] = (startColor.redMultiplier + endColor.redMultiplier) / 2;
                        this._pOneData[i++] = (startColor.greenMultiplier + endColor.greenMultiplier) / 2;
                        this._pOneData[i++] = (startColor.blueMultiplier + endColor.blueMultiplier) / 2;
                        this._pOneData[i++] = (startColor.alphaMultiplier + endColor.alphaMultiplier) / 2;
                        this._pOneData[i++] = (startColor.redMultiplier - endColor.redMultiplier) / 2;
                        this._pOneData[i++] = (startColor.greenMultiplier - endColor.greenMultiplier) / 2;
                        this._pOneData[i++] = (startColor.blueMultiplier - endColor.blueMultiplier) / 2;
                        this._pOneData[i++] = (startColor.alphaMultiplier - endColor.alphaMultiplier) / 2;
                    }

                    if (this._iUsesOffset) {
                        this._pOneData[i++] = (startColor.redOffset + endColor.redOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.greenOffset + endColor.greenOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.blueOffset + endColor.blueOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.alphaOffset + endColor.alphaOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.redOffset - endColor.redOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.greenOffset - endColor.greenOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.blueOffset - endColor.blueOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.alphaOffset - endColor.alphaOffset) / (255 * 2);
                    }
                }
            };
            ParticleColorNode.START_MULTIPLIER_INDEX = 0;

            ParticleColorNode.DELTA_MULTIPLIER_INDEX = 1;

            ParticleColorNode.START_OFFSET_INDEX = 2;

            ParticleColorNode.DELTA_OFFSET_INDEX = 3;

            ParticleColorNode.CYCLE_INDEX = 4;

            ParticleColorNode.COLOR_START_COLORTRANSFORM = "ColorStartColorTransform";

            ParticleColorNode.COLOR_END_COLORTRANSFORM = "ColorEndColorTransform";
            return ParticleColorNode;
        })(animators.ParticleNodeBase);
        animators.ParticleColorNode = ParticleColorNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to create a follow behaviour on a particle system.
        */
        var ParticleFollowNode = (function (_super) {
            __extends(ParticleFollowNode, _super);
            /**
            * Creates a new <code>ParticleFollowNode</code>
            *
            * @param    [optional] usesPosition     Defines wehether the individual particle reacts to the position of the target.
            * @param    [optional] usesRotation     Defines wehether the individual particle reacts to the rotation of the target.
            * @param    [optional] smooth     Defines wehether the state calculate the interpolated value.
            */
            function ParticleFollowNode(usesPosition, usesRotation, smooth) {
                if (typeof usesPosition === "undefined") { usesPosition = true; }
                if (typeof usesRotation === "undefined") { usesRotation = true; }
                if (typeof smooth === "undefined") { smooth = false; }
                _super.call(this, "ParticleFollow", animators.ParticlePropertiesMode.LOCAL_DYNAMIC, (usesPosition && usesRotation) ? 6 : 3, animators.ParticleAnimationSet.POST_PRIORITY);

                this._pStateClass = animators.ParticleFollowState;

                this._iUsesPosition = usesPosition;
                this._iUsesRotation = usesRotation;
                this._iSmooth = smooth;
            }
            /**
            * @inheritDoc
            */
            ParticleFollowNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                //TODO: use Quaternion to implement this function
                var code = "";
                if (this._iUsesRotation) {
                    var rotationAttribute = animationRegisterCache.getFreeVertexAttribute();
                    animationRegisterCache.setRegisterIndex(this, ParticleFollowNode.FOLLOW_ROTATION_INDEX, rotationAttribute.index);

                    var temp1 = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp1, 1);
                    var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp2, 1);
                    var temp3 = animationRegisterCache.getFreeVertexVectorTemp();

                    var temp4;
                    if (animationRegisterCache.hasBillboard) {
                        animationRegisterCache.addVertexTempUsages(temp3, 1);
                        temp4 = animationRegisterCache.getFreeVertexVectorTemp();
                    }

                    animationRegisterCache.removeVertexTempUsage(temp1);
                    animationRegisterCache.removeVertexTempUsage(temp2);
                    if (animationRegisterCache.hasBillboard)
                        animationRegisterCache.removeVertexTempUsage(temp3);

                    var len = animationRegisterCache.rotationRegisters.length;
                    var i/*int*/ ;

                    //x axis
                    code += "mov " + temp1 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp1 + ".x," + animationRegisterCache.vertexOneConst + "\n";
                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "sin " + temp3 + ".y," + rotationAttribute + ".x\n";
                    code += "cos " + temp3 + ".z," + rotationAttribute + ".x\n";
                    code += "mov " + temp2 + ".x," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp2 + ".y," + temp3 + ".z\n";
                    code += "neg " + temp2 + ".z," + temp3 + ".y\n";

                    if (animationRegisterCache.hasBillboard)
                        code += "m33 " + temp4 + ".xyz," + animationRegisterCache.positionTarget + ".xyz," + temp1 + "\n";
else {
                        code += "m33 " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                        for (i = 0; i < len; i++)
                            code += "m33 " + animationRegisterCache.rotationRegisters[i] + ".xyz," + animationRegisterCache.rotationRegisters[i] + "," + temp1 + "\n";
                    }

                    //y axis
                    code += "mov " + temp1 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "cos " + temp1 + ".x," + rotationAttribute + ".y\n";
                    code += "sin " + temp1 + ".z," + rotationAttribute + ".y\n";
                    code += "mov " + temp2 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp2 + ".y," + animationRegisterCache.vertexOneConst + "\n";
                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "neg " + temp3 + ".x," + temp1 + ".z\n";
                    code += "mov " + temp3 + ".z," + temp1 + ".x\n";

                    if (animationRegisterCache.hasBillboard)
                        code += "m33 " + temp4 + ".xyz," + temp4 + ".xyz," + temp1 + "\n";
else {
                        code += "m33 " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                        for (i = 0; i < len; i++)
                            code += "m33 " + animationRegisterCache.rotationRegisters[i] + ".xyz," + animationRegisterCache.rotationRegisters[i] + "," + temp1 + "\n";
                    }

                    //z axis
                    code += "mov " + temp2 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "sin " + temp2 + ".x," + rotationAttribute + ".z\n";
                    code += "cos " + temp2 + ".y," + rotationAttribute + ".z\n";
                    code += "mov " + temp1 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp1 + ".x," + temp2 + ".y\n";
                    code += "neg " + temp1 + ".y," + temp2 + ".x\n";
                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp3 + ".z," + animationRegisterCache.vertexOneConst + "\n";

                    if (animationRegisterCache.hasBillboard) {
                        code += "m33 " + temp4 + ".xyz," + temp4 + ".xyz," + temp1 + "\n";
                        code += "sub " + temp4 + ".xyz," + temp4 + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";
                        code += "add " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp4 + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";
                    } else {
                        code += "m33 " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                        for (i = 0; i < len; i++)
                            code += "m33 " + animationRegisterCache.rotationRegisters[i] + ".xyz," + animationRegisterCache.rotationRegisters[i] + "," + temp1 + "\n";
                    }
                }

                if (this._iUsesPosition) {
                    var positionAttribute = animationRegisterCache.getFreeVertexAttribute();
                    animationRegisterCache.setRegisterIndex(this, ParticleFollowNode.FOLLOW_POSITION_INDEX, positionAttribute.index);
                    code += "add " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + positionAttribute + "," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleFollowNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };
            ParticleFollowNode.FOLLOW_POSITION_INDEX = 0;

            ParticleFollowNode.FOLLOW_ROTATION_INDEX = 1;
            return ParticleFollowNode;
        })(animators.ParticleNodeBase);
        animators.ParticleFollowNode = ParticleFollowNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var ColorTransform = away.geom.ColorTransform;
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        var ParticleInitialColorNode = (function (_super) {
            __extends(ParticleInitialColorNode, _super);
            function ParticleInitialColorNode(mode/*uint*/ , usesMultiplier, usesOffset, initialColor) {
                if (typeof usesMultiplier === "undefined") { usesMultiplier = true; }
                if (typeof usesOffset === "undefined") { usesOffset = false; }
                if (typeof initialColor === "undefined") { initialColor = null; }
                _super.call(this, "ParticleInitialColor", mode, (usesMultiplier && usesOffset) ? 8 : 4, animators.ParticleAnimationSet.COLOR_PRIORITY);

                this._pStateClass = animators.ParticleInitialColorState;

                this._iUsesMultiplier = usesMultiplier;
                this._iUsesOffset = usesOffset;
                this._iInitialColor = initialColor || new ColorTransform();
            }
            /**
            * @inheritDoc
            */
            ParticleInitialColorNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var code = "";
                if (animationRegisterCache.needFragmentAnimation) {
                    if (this._iUsesMultiplier) {
                        var multiplierValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                        animationRegisterCache.setRegisterIndex(this, ParticleInitialColorNode.MULTIPLIER_INDEX, multiplierValue.index);

                        code += "mul " + animationRegisterCache.colorMulTarget + "," + multiplierValue + "," + animationRegisterCache.colorMulTarget + "\n";
                    }

                    if (this._iUsesOffset) {
                        var offsetValue = (this._pMode == animators.ParticlePropertiesMode.LOCAL_STATIC) ? animationRegisterCache.getFreeVertexAttribute() : animationRegisterCache.getFreeVertexConstant();
                        animationRegisterCache.setRegisterIndex(this, ParticleInitialColorNode.OFFSET_INDEX, offsetValue.index);

                        code += "add " + animationRegisterCache.colorAddTarget + "," + offsetValue + "," + animationRegisterCache.colorAddTarget + "\n";
                    }
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleInitialColorNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                if (this._iUsesMultiplier)
                    particleAnimationSet.hasColorMulNode = true;
                if (this._iUsesOffset)
                    particleAnimationSet.hasColorAddNode = true;
            };

            /**
            * @inheritDoc
            */
            ParticleInitialColorNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var initialColor = param[ParticleInitialColorNode.COLOR_INITIAL_COLORTRANSFORM];
                if (!initialColor)
                    throw (new Error("there is no " + ParticleInitialColorNode.COLOR_INITIAL_COLORTRANSFORM + " in param!"));

                var i = 0;

                if (this._iUsesMultiplier) {
                    this._pOneData[i++] = initialColor.redMultiplier;
                    this._pOneData[i++] = initialColor.greenMultiplier;
                    this._pOneData[i++] = initialColor.blueMultiplier;
                    this._pOneData[i++] = initialColor.alphaMultiplier;
                }

                if (this._iUsesOffset) {
                    this._pOneData[i++] = initialColor.redOffset / 255;
                    this._pOneData[i++] = initialColor.greenOffset / 255;
                    this._pOneData[i++] = initialColor.blueOffset / 255;
                    this._pOneData[i++] = initialColor.alphaOffset / 255;
                }
            };
            ParticleInitialColorNode.MULTIPLIER_INDEX = 0;

            ParticleInitialColorNode.OFFSET_INDEX = 1;

            ParticleInitialColorNode.COLOR_INITIAL_COLORTRANSFORM = "ColorInitialColorTransform";
            return ParticleInitialColorNode;
        })(animators.ParticleNodeBase);
        animators.ParticleInitialColorNode = ParticleInitialColorNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the position of a particle over time around a circular orbit.
        */
        var ParticleOrbitNode = (function (_super) {
            __extends(ParticleOrbitNode, _super);
            /**
            * Creates a new <code>ParticleOrbitNode</code> object.
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] usesEulers      Defines whether the node uses the <code>eulers</code> property in the shader to calculate a rotation on the orbit. Defaults to true.
            * @param    [optional] usesCycle       Defines whether the node uses the <code>cycleDuration</code> property in the shader to calculate the period of the orbit independent of particle duration. Defaults to false.
            * @param    [optional] usesPhase       Defines whether the node uses the <code>cyclePhase</code> property in the shader to calculate a starting offset to the cycle rotation of the particle. Defaults to false.
            * @param    [optional] radius          Defines the radius of the orbit when in global mode. Defaults to 100.
            * @param    [optional] cycleDuration   Defines the duration of the orbit in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
            * @param    [optional] cyclePhase      Defines the phase of the orbit in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
            * @param    [optional] eulers          Defines the euler rotation in degrees, applied to the orientation of the orbit when in global mode.
            */
            function ParticleOrbitNode(mode/*uint*/ , usesEulers, usesCycle, usesPhase, radius, cycleDuration, cyclePhase, eulers) {
                if (typeof usesEulers === "undefined") { usesEulers = true; }
                if (typeof usesCycle === "undefined") { usesCycle = false; }
                if (typeof usesPhase === "undefined") { usesPhase = false; }
                if (typeof radius === "undefined") { radius = 100; }
                if (typeof cycleDuration === "undefined") { cycleDuration = 1; }
                if (typeof cyclePhase === "undefined") { cyclePhase = 0; }
                if (typeof eulers === "undefined") { eulers = null; }
                var len = 3;
                if (usesPhase)
                    len++;
                _super.call(this, "ParticleOrbit", mode, len);

                this._pStateClass = animators.ParticleOrbitState;

                this._iUsesEulers = usesEulers;
                this._iUsesCycle = usesCycle;
                this._iUsesPhase = usesPhase;

                this._iRadius = radius;
                this._iCycleDuration = cycleDuration;
                this._iCyclePhase = cyclePhase;
                this._iEulers = eulers || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleOrbitNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var orbitRegister = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleOrbitNode.ORBIT_INDEX, orbitRegister.index);

                var eulersMatrixRegister = animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.setRegisterIndex(this, ParticleOrbitNode.EULERS_INDEX, eulersMatrixRegister.index);
                animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.getFreeVertexConstant();

                var temp1 = animationRegisterCache.getFreeVertexVectorTemp();
                animationRegisterCache.addVertexTempUsages(temp1, 1);
                var distance = new ShaderRegisterElement(temp1.regName, temp1.index);

                var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                var cos = new ShaderRegisterElement(temp2.regName, temp2.index, 0);
                var sin = new ShaderRegisterElement(temp2.regName, temp2.index, 1);
                var degree = new ShaderRegisterElement(temp2.regName, temp2.index, 2);
                animationRegisterCache.removeVertexTempUsage(temp1);

                var code = "";

                if (this._iUsesCycle) {
                    code += "mul " + degree + "," + animationRegisterCache.vertexTime + "," + orbitRegister + ".y\n";

                    if (this._iUsesPhase)
                        code += "add " + degree + "," + degree + "," + orbitRegister + ".w\n";
                } else
                    code += "mul " + degree + "," + animationRegisterCache.vertexLife + "," + orbitRegister + ".y\n";

                code += "cos " + cos + "," + degree + "\n";
                code += "sin " + sin + "," + degree + "\n";
                code += "mul " + distance + ".x," + cos + "," + orbitRegister + ".x\n";
                code += "mul " + distance + ".y," + sin + "," + orbitRegister + ".x\n";
                code += "mov " + distance + ".wz" + animationRegisterCache.vertexZeroConst + "\n";
                if (this._iUsesEulers)
                    code += "m44 " + distance + "," + distance + "," + eulersMatrixRegister + "\n";
                code += "add " + animationRegisterCache.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";

                if (animationRegisterCache.needVelocity) {
                    code += "neg " + distance + ".x," + sin + "\n";
                    code += "mov " + distance + ".y," + cos + "\n";
                    code += "mov " + distance + ".zw," + animationRegisterCache.vertexZeroConst + "\n";
                    if (this._iUsesEulers)
                        code += "m44 " + distance + "," + distance + "," + eulersMatrixRegister + "\n";
                    code += "mul " + distance + "," + distance + "," + orbitRegister + ".z\n";
                    code += "div " + distance + "," + distance + "," + orbitRegister + ".y\n";
                    if (!this._iUsesCycle)
                        code += "div " + distance + "," + distance + "," + animationRegisterCache.vertexLife + "\n";
                    code += "add " + animationRegisterCache.velocityTarget + ".xyz," + animationRegisterCache.velocityTarget + ".xyz," + distance + ".xyz\n";
                }
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleOrbitNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleOrbitNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                //Vector3D.x is radius, Vector3D.y is cycle duration, Vector3D.z is phase
                var orbit = param[ParticleOrbitNode.ORBIT_VECTOR3D];
                if (!orbit)
                    throw new Error("there is no " + ParticleOrbitNode.ORBIT_VECTOR3D + " in param!");

                this._pOneData[0] = orbit.x;
                if (this._iUsesCycle && orbit.y <= 0)
                    throw (new Error("the cycle duration must be greater than zero"));
                this._pOneData[1] = Math.PI * 2 / (!this._iUsesCycle ? 1 : orbit.y);
                this._pOneData[2] = orbit.x * Math.PI * 2;
                if (this._iUsesPhase)
                    this._pOneData[3] = orbit.z * Math.PI / 180;
            };
            ParticleOrbitNode.ORBIT_INDEX = 0;

            ParticleOrbitNode.EULERS_INDEX = 1;

            ParticleOrbitNode.ORBIT_VECTOR3D = "OrbitVector3D";
            return ParticleOrbitNode;
        })(animators.ParticleNodeBase);
        animators.ParticleOrbitNode = ParticleOrbitNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the position of a particle over time using simple harmonic motion.
        */
        var ParticleOscillatorNode = (function (_super) {
            __extends(ParticleOscillatorNode, _super);
            /**
            * Creates a new <code>ParticleOscillatorNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] oscillator      Defines the default oscillator axis (x, y, z) and cycleDuration (w) of the node, used when in global mode.
            */
            function ParticleOscillatorNode(mode/*uint*/ , oscillator) {
                if (typeof oscillator === "undefined") { oscillator = null; }
                _super.call(this, "ParticleOscillator", mode, 4);

                this._pStateClass = animators.ParticleOscillatorState;

                this._iOscillator = oscillator || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleOscillatorNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                pass = pass;
                var oscillatorRegister = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleOscillatorNode.OSCILLATOR_INDEX, oscillatorRegister.index);
                var temp = animationRegisterCache.getFreeVertexVectorTemp();
                var dgree = new ShaderRegisterElement(temp.regName, temp.index, 0);
                var sin = new ShaderRegisterElement(temp.regName, temp.index, 1);
                var cos = new ShaderRegisterElement(temp.regName, temp.index, 2);
                animationRegisterCache.addVertexTempUsages(temp, 1);
                var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                var distance = new ShaderRegisterElement(temp2.regName, temp2.index);
                animationRegisterCache.removeVertexTempUsage(temp);

                var code = "";
                code += "mul " + dgree + "," + animationRegisterCache.vertexTime + "," + oscillatorRegister + ".w\n";
                code += "sin " + sin + "," + dgree + "\n";
                code += "mul " + distance + ".xyz," + sin + "," + oscillatorRegister + ".xyz\n";
                code += "add " + animationRegisterCache.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";

                if (animationRegisterCache.needVelocity) {
                    code += "cos " + cos + "," + dgree + "\n";
                    code += "mul " + distance + ".xyz," + cos + "," + oscillatorRegister + ".xyz\n";
                    code += "add " + animationRegisterCache.velocityTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleOscillatorNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleOscillatorNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                //(Vector3D.x,Vector3D.y,Vector3D.z) is oscillator axis, Vector3D.w is oscillator cycle duration
                var drift = param[ParticleOscillatorNode.OSCILLATOR_VECTOR3D];
                if (!drift)
                    throw (new Error("there is no " + ParticleOscillatorNode.OSCILLATOR_VECTOR3D + " in param!"));

                this._pOneData[0] = drift.x;
                this._pOneData[1] = drift.y;
                this._pOneData[2] = drift.z;
                if (drift.w <= 0)
                    throw (new Error("the cycle duration must greater than zero"));
                this._pOneData[3] = Math.PI * 2 / drift.w;
            };
            ParticleOscillatorNode.OSCILLATOR_INDEX = 0;

            ParticleOscillatorNode.OSCILLATOR_VECTOR3D = "OscillatorVector3D";
            return ParticleOscillatorNode;
        })(animators.ParticleNodeBase);
        animators.ParticleOscillatorNode = ParticleOscillatorNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to set the starting position of a particle.
        */
        var ParticlePositionNode = (function (_super) {
            __extends(ParticlePositionNode, _super);
            /**
            * Creates a new <code>ParticlePositionNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] position        Defines the default position of the particle when in global mode. Defaults to 0,0,0.
            */
            function ParticlePositionNode(mode/*uint*/ , position) {
                if (typeof position === "undefined") { position = null; }
                _super.call(this, "ParticlePosition", mode, 3);

                this._pStateClass = animators.ParticlePositionState;

                this._iPosition = position || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticlePositionNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                pass = pass;
                var positionAttribute = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticlePositionNode.POSITION_INDEX, positionAttribute.index);

                return "add " + animationRegisterCache.positionTarget + ".xyz," + positionAttribute + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";
            };

            /**
            * @inheritDoc
            */
            ParticlePositionNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticlePositionNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var offset = param[ParticlePositionNode.POSITION_VECTOR3D];
                if (!offset)
                    throw (new Error("there is no " + ParticlePositionNode.POSITION_VECTOR3D + " in param!"));

                this._pOneData[0] = offset.x;
                this._pOneData[1] = offset.y;
                this._pOneData[2] = offset.z;
            };
            ParticlePositionNode.POSITION_INDEX = 0;

            ParticlePositionNode.POSITION_VECTOR3D = "PositionVector3D";
            return ParticlePositionNode;
        })(animators.ParticleNodeBase);
        animators.ParticlePositionNode = ParticlePositionNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the rotation of a particle to match its heading vector.
        */
        var ParticleRotateToHeadingNode = (function (_super) {
            __extends(ParticleRotateToHeadingNode, _super);
            /**
            * Creates a new <code>ParticleBillboardNode</code>
            */
            function ParticleRotateToHeadingNode() {
                _super.call(this, "ParticleRotateToHeading", animators.ParticlePropertiesMode.GLOBAL, 0, 3);

                this._pStateClass = animators.ParticleRotateToHeadingState;
            }
            /**
            * @inheritDoc
            */
            ParticleRotateToHeadingNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var code = "";
                var len = animationRegisterCache.rotationRegisters.length;
                var i/*int*/ ;
                if (animationRegisterCache.hasBillboard) {
                    var temp1 = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp1, 1);
                    var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp2, 1);
                    var temp3 = animationRegisterCache.getFreeVertexVectorTemp();

                    var rotationMatrixRegister = animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.setRegisterIndex(this, ParticleRotateToHeadingNode.MATRIX_INDEX, rotationMatrixRegister.index);
                    animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.getFreeVertexConstant();

                    animationRegisterCache.removeVertexTempUsage(temp1);
                    animationRegisterCache.removeVertexTempUsage(temp2);

                    //process the velocity
                    code += "m33 " + temp1 + ".xyz," + animationRegisterCache.velocityTarget + ".xyz," + rotationMatrixRegister + "\n";

                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp3 + ".xy," + temp1 + ".xy\n";
                    code += "nrm " + temp3 + ".xyz," + temp3 + ".xyz\n";

                    //temp3.x=cos,temp3.y=sin
                    //only process z axis
                    code += "mov " + temp2 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp2 + ".x," + temp3 + ".y\n";
                    code += "mov " + temp2 + ".y," + temp3 + ".x\n";
                    code += "mov " + temp1 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp1 + ".x," + temp3 + ".x\n";
                    code += "neg " + temp1 + ".y," + temp3 + ".y\n";
                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp3 + ".z," + animationRegisterCache.vertexOneConst + "\n";
                    code += "m33 " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                    for (i = 0; i < len; i++)
                        code += "m33 " + animationRegisterCache.rotationRegisters[i] + ".xyz," + animationRegisterCache.rotationRegisters[i] + "," + temp1 + "\n";
                } else {
                    var nrmVel = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(nrmVel, 1);

                    var xAxis = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(xAxis, 1);

                    var R = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(R, 1);
                    var R_rev = animationRegisterCache.getFreeVertexVectorTemp();
                    var cos = new ShaderRegisterElement(R.regName, R.index, 3);
                    var sin = new ShaderRegisterElement(R_rev.regName, R_rev.index, 3);
                    var cos2 = new ShaderRegisterElement(nrmVel.regName, nrmVel.index, 3);
                    var tempSingle = sin;

                    animationRegisterCache.removeVertexTempUsage(nrmVel);
                    animationRegisterCache.removeVertexTempUsage(xAxis);
                    animationRegisterCache.removeVertexTempUsage(R);

                    code += "mov " + xAxis + ".x," + animationRegisterCache.vertexOneConst + "\n";
                    code += "mov " + xAxis + ".yz," + animationRegisterCache.vertexZeroConst + "\n";

                    code += "nrm " + nrmVel + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
                    code += "dp3 " + cos2 + "," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                    code += "crs " + nrmVel + ".xyz," + xAxis + ".xyz," + nrmVel + ".xyz\n";
                    code += "nrm " + nrmVel + ".xyz," + nrmVel + ".xyz\n";

                    //use R as temp to judge if nrm is (0,0,0).
                    //if nrm is (0,0,0) ,change it to (0,0,1).
                    code += "dp3 " + R + ".x," + nrmVel + ".xyz," + nrmVel + ".xyz\n";
                    code += "sge " + R + ".x," + animationRegisterCache.vertexZeroConst + "," + R + ".x\n";
                    code += "add " + nrmVel + ".z," + R + ".x," + nrmVel + ".z\n";

                    code += "add " + tempSingle + "," + cos2 + "," + animationRegisterCache.vertexOneConst + "\n";
                    code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterCache.vertexTwoConst + "\n";
                    code += "sqt " + cos + "," + tempSingle + "\n";

                    code += "sub " + tempSingle + "," + animationRegisterCache.vertexOneConst + "," + cos2 + "\n";
                    code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterCache.vertexTwoConst + "\n";
                    code += "sqt " + sin + "," + tempSingle + "\n";

                    code += "mul " + R + ".xyz," + sin + "," + nrmVel + ".xyz\n";

                    //use cos as R.w
                    code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                    code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";

                    //use cos as R_rev.w
                    //nrmVel and xAxis are used as temp register
                    code += "crs " + nrmVel + ".xyz," + R + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";

                    //use cos as R.w
                    code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";
                    code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                    code += "dp3 " + xAxis + ".w," + R + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";
                    code += "neg " + nrmVel + ".w," + xAxis + ".w\n";

                    code += "crs " + R + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";

                    //code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," +R_rev + ".w\n";
                    code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
                    code += "add " + R + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
                    code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";

                    code += "add " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";

                    for (i = 0; i < len; i++) {
                        //just repeat the calculate above
                        //because of the limited registers, no need to optimise
                        code += "mov " + xAxis + ".x," + animationRegisterCache.vertexOneConst + "\n";
                        code += "mov " + xAxis + ".yz," + animationRegisterCache.vertexZeroConst + "\n";
                        code += "nrm " + nrmVel + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
                        code += "dp3 " + cos2 + "," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                        code += "crs " + nrmVel + ".xyz," + xAxis + ".xyz," + nrmVel + ".xyz\n";
                        code += "nrm " + nrmVel + ".xyz," + nrmVel + ".xyz\n";
                        code += "dp3 " + R + ".x," + nrmVel + ".xyz," + nrmVel + ".xyz\n";
                        code += "sge " + R + ".x," + animationRegisterCache.vertexZeroConst + "," + R + ".x\n";
                        code += "add " + nrmVel + ".z," + R + ".x," + nrmVel + ".z\n";
                        code += "add " + tempSingle + "," + cos2 + "," + animationRegisterCache.vertexOneConst + "\n";
                        code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterCache.vertexTwoConst + "\n";
                        code += "sqt " + cos + "," + tempSingle + "\n";
                        code += "sub " + tempSingle + "," + animationRegisterCache.vertexOneConst + "," + cos2 + "\n";
                        code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterCache.vertexTwoConst + "\n";
                        code += "sqt " + sin + "," + tempSingle + "\n";
                        code += "mul " + R + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                        code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                        code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";
                        code += "crs " + nrmVel + ".xyz," + R + ".xyz," + animationRegisterCache.rotationRegisters[i] + ".xyz\n";
                        code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterCache.rotationRegisters[i] + ".xyz\n";
                        code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                        code += "dp3 " + xAxis + ".w," + R + ".xyz," + animationRegisterCache.rotationRegisters[i] + ".xyz\n";
                        code += "neg " + nrmVel + ".w," + xAxis + ".w\n";
                        code += "crs " + R + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";
                        code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
                        code += "add " + R + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
                        code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";
                        code += "add " + animationRegisterCache.rotationRegisters[i] + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
                    }
                }
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleRotateToHeadingNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleRotateToHeadingNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                particleAnimationSet.needVelocity = true;
            };
            ParticleRotateToHeadingNode.MATRIX_INDEX = 0;
            return ParticleRotateToHeadingNode;
        })(animators.ParticleNodeBase);
        animators.ParticleRotateToHeadingNode = ParticleRotateToHeadingNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the rotation of a particle to face to a position
        */
        var ParticleRotateToPositionNode = (function (_super) {
            __extends(ParticleRotateToPositionNode, _super);
            /**
            * Creates a new <code>ParticleRotateToPositionNode</code>
            */
            function ParticleRotateToPositionNode(mode/*uint*/ , position) {
                if (typeof position === "undefined") { position = null; }
                _super.call(this, "ParticleRotateToPosition", mode, 3, 3);

                this._pStateClass = animators.ParticleRotateToPositionState;

                this._iPosition = position || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleRotateToPositionNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var positionAttribute = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleRotateToPositionNode.POSITION_INDEX, positionAttribute.index);

                var code = "";
                var len = animationRegisterCache.rotationRegisters.length;
                var i/*int*/ ;
                if (animationRegisterCache.hasBillboard) {
                    var temp1 = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp1, 1);
                    var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp2, 1);
                    var temp3 = animationRegisterCache.getFreeVertexVectorTemp();

                    var rotationMatrixRegister = animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.setRegisterIndex(this, ParticleRotateToPositionNode.MATRIX_INDEX, rotationMatrixRegister.index);
                    animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.getFreeVertexConstant();

                    animationRegisterCache.removeVertexTempUsage(temp1);
                    animationRegisterCache.removeVertexTempUsage(temp2);

                    //process the position
                    code += "sub " + temp1 + ".xyz," + positionAttribute + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";
                    code += "m33 " + temp1 + ".xyz," + temp1 + ".xyz," + rotationMatrixRegister + "\n";

                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp3 + ".xy," + temp1 + ".xy\n";
                    code += "nrm " + temp3 + ".xyz," + temp3 + ".xyz\n";

                    //temp3.x=cos,temp3.y=sin
                    //only process z axis
                    code += "mov " + temp2 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp2 + ".x," + temp3 + ".y\n";
                    code += "mov " + temp2 + ".y," + temp3 + ".x\n";
                    code += "mov " + temp1 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp1 + ".x," + temp3 + ".x\n";
                    code += "neg " + temp1 + ".y," + temp3 + ".y\n";
                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp3 + ".z," + animationRegisterCache.vertexOneConst + "\n";
                    code += "m33 " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                    for (i = 0; i < len; i++)
                        code += "m33 " + animationRegisterCache.rotationRegisters[i] + ".xyz," + animationRegisterCache.rotationRegisters[i] + "," + temp1 + "\n";
                } else {
                    var nrmDirection = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(nrmDirection, 1);

                    var temp = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp, 1);
                    var cos = new ShaderRegisterElement(temp.regName, temp.index, 0);
                    var sin = new ShaderRegisterElement(temp.regName, temp.index, 1);
                    var o_temp = new ShaderRegisterElement(temp.regName, temp.index, 2);
                    var tempSingle = new ShaderRegisterElement(temp.regName, temp.index, 3);

                    var R = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(R, 1);

                    animationRegisterCache.removeVertexTempUsage(nrmDirection);
                    animationRegisterCache.removeVertexTempUsage(temp);
                    animationRegisterCache.removeVertexTempUsage(R);

                    code += "sub " + nrmDirection + ".xyz," + positionAttribute + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";
                    code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";

                    code += "mov " + sin + "," + nrmDirection + ".y\n";
                    code += "mul " + cos + "," + sin + "," + sin + "\n";
                    code += "sub " + cos + "," + animationRegisterCache.vertexOneConst + "," + cos + "\n";
                    code += "sqt " + cos + "," + cos + "\n";

                    code += "mul " + R + ".x," + cos + "," + animationRegisterCache.scaleAndRotateTarget + ".y\n";
                    code += "mul " + R + ".y," + sin + "," + animationRegisterCache.scaleAndRotateTarget + ".z\n";
                    code += "mul " + R + ".z," + sin + "," + animationRegisterCache.scaleAndRotateTarget + ".y\n";
                    code += "mul " + R + ".w," + cos + "," + animationRegisterCache.scaleAndRotateTarget + ".z\n";

                    code += "sub " + animationRegisterCache.scaleAndRotateTarget + ".y," + R + ".x," + R + ".y\n";
                    code += "add " + animationRegisterCache.scaleAndRotateTarget + ".z," + R + ".z," + R + ".w\n";

                    code += "abs " + R + ".y," + nrmDirection + ".y\n";
                    code += "sge " + R + ".z," + R + ".y," + animationRegisterCache.vertexOneConst + "\n";
                    code += "mul " + R + ".x," + R + ".y," + nrmDirection + ".y\n";

                    //judgu if nrmDirection=(0,1,0);
                    code += "mov " + nrmDirection + ".y," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "dp3 " + sin + "," + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
                    code += "sge " + tempSingle + "," + animationRegisterCache.vertexZeroConst + "," + sin + "\n";

                    code += "mov " + nrmDirection + ".y," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";

                    code += "sub " + sin + "," + animationRegisterCache.vertexOneConst + "," + tempSingle + "\n";
                    code += "mul " + sin + "," + sin + "," + nrmDirection + ".x\n";

                    code += "mov " + cos + "," + nrmDirection + ".z\n";
                    code += "neg " + cos + "," + cos + "\n";
                    code += "sub " + o_temp + "," + animationRegisterCache.vertexOneConst + "," + cos + "\n";
                    code += "mul " + o_temp + "," + R + ".x," + tempSingle + "\n";
                    code += "add " + cos + "," + cos + "," + o_temp + "\n";

                    code += "mul " + R + ".x," + cos + "," + animationRegisterCache.scaleAndRotateTarget + ".x\n";
                    code += "mul " + R + ".y," + sin + "," + animationRegisterCache.scaleAndRotateTarget + ".z\n";
                    code += "mul " + R + ".z," + sin + "," + animationRegisterCache.scaleAndRotateTarget + ".x\n";
                    code += "mul " + R + ".w," + cos + "," + animationRegisterCache.scaleAndRotateTarget + ".z\n";

                    code += "sub " + animationRegisterCache.scaleAndRotateTarget + ".x," + R + ".x," + R + ".y\n";
                    code += "add " + animationRegisterCache.scaleAndRotateTarget + ".z," + R + ".z," + R + ".w\n";

                    for (i = 0; i < len; i++) {
                        //just repeat the calculate above
                        //because of the limited registers, no need to optimise
                        code += "sub " + nrmDirection + ".xyz," + positionAttribute + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";
                        code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
                        code += "mov " + sin + "," + nrmDirection + ".y\n";
                        code += "mul " + cos + "," + sin + "," + sin + "\n";
                        code += "sub " + cos + "," + animationRegisterCache.vertexOneConst + "," + cos + "\n";
                        code += "sqt " + cos + "," + cos + "\n";
                        code += "mul " + R + ".x," + cos + "," + animationRegisterCache.rotationRegisters[i] + ".y\n";
                        code += "mul " + R + ".y," + sin + "," + animationRegisterCache.rotationRegisters[i] + ".z\n";
                        code += "mul " + R + ".z," + sin + "," + animationRegisterCache.rotationRegisters[i] + ".y\n";
                        code += "mul " + R + ".w," + cos + "," + animationRegisterCache.rotationRegisters[i] + ".z\n";
                        code += "sub " + animationRegisterCache.rotationRegisters[i] + ".y," + R + ".x," + R + ".y\n";
                        code += "add " + animationRegisterCache.rotationRegisters[i] + ".z," + R + ".z," + R + ".w\n";
                        code += "abs " + R + ".y," + nrmDirection + ".y\n";
                        code += "sge " + R + ".z," + R + ".y," + animationRegisterCache.vertexOneConst + "\n";
                        code += "mul " + R + ".x," + R + ".y," + nrmDirection + ".y\n";
                        code += "mov " + nrmDirection + ".y," + animationRegisterCache.vertexZeroConst + "\n";
                        code += "dp3 " + sin + "," + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
                        code += "sge " + tempSingle + "," + animationRegisterCache.vertexZeroConst + "," + sin + "\n";
                        code += "mov " + nrmDirection + ".y," + animationRegisterCache.vertexZeroConst + "\n";
                        code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
                        code += "sub " + sin + "," + animationRegisterCache.vertexOneConst + "," + tempSingle + "\n";
                        code += "mul " + sin + "," + sin + "," + nrmDirection + ".x\n";
                        code += "mov " + cos + "," + nrmDirection + ".z\n";
                        code += "neg " + cos + "," + cos + "\n";
                        code += "sub " + o_temp + "," + animationRegisterCache.vertexOneConst + "," + cos + "\n";
                        code += "mul " + o_temp + "," + R + ".x," + tempSingle + "\n";
                        code += "add " + cos + "," + cos + "," + o_temp + "\n";
                        code += "mul " + R + ".x," + cos + "," + animationRegisterCache.rotationRegisters[i] + ".x\n";
                        code += "mul " + R + ".y," + sin + "," + animationRegisterCache.rotationRegisters[i] + ".z\n";
                        code += "mul " + R + ".z," + sin + "," + animationRegisterCache.rotationRegisters[i] + ".x\n";
                        code += "mul " + R + ".w," + cos + "," + animationRegisterCache.rotationRegisters[i] + ".z\n";
                        code += "sub " + animationRegisterCache.rotationRegisters[i] + ".x," + R + ".x," + R + ".y\n";
                        code += "add " + animationRegisterCache.rotationRegisters[i] + ".z," + R + ".z," + R + ".w\n";
                    }
                }
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleRotateToPositionNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleRotateToPositionNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var offset = param[ParticleRotateToPositionNode.POSITION_VECTOR3D];
                if (!offset)
                    throw (new Error("there is no " + ParticleRotateToPositionNode.POSITION_VECTOR3D + " in param!"));

                this._pOneData[0] = offset.x;
                this._pOneData[1] = offset.y;
                this._pOneData[2] = offset.z;
            };
            ParticleRotateToPositionNode.MATRIX_INDEX = 0;

            ParticleRotateToPositionNode.POSITION_INDEX = 1;

            ParticleRotateToPositionNode.POSITION_VECTOR3D = "RotateToPositionVector3D";
            return ParticleRotateToPositionNode;
        })(animators.ParticleNodeBase);
        animators.ParticleRotateToPositionNode = ParticleRotateToPositionNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to set the starting rotational velocity of a particle.
        */
        var ParticleRotationalVelocityNode = (function (_super) {
            __extends(ParticleRotationalVelocityNode, _super);
            /**
            * Creates a new <code>ParticleRotationalVelocityNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            */
            function ParticleRotationalVelocityNode(mode/*uint*/ , rotationalVelocity) {
                if (typeof rotationalVelocity === "undefined") { rotationalVelocity = null; }
                _super.call(this, "ParticleRotationalVelocity", mode, 4);

                this._pStateClass = animators.ParticleRotationalVelocityState;

                this._iRotationalVelocity = rotationalVelocity || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleRotationalVelocityNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var rotationRegister = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleRotationalVelocityNode.ROTATIONALVELOCITY_INDEX, rotationRegister.index);

                var nrmVel = animationRegisterCache.getFreeVertexVectorTemp();
                animationRegisterCache.addVertexTempUsages(nrmVel, 1);

                var xAxis = animationRegisterCache.getFreeVertexVectorTemp();
                animationRegisterCache.addVertexTempUsages(xAxis, 1);

                var temp = animationRegisterCache.getFreeVertexVectorTemp();
                animationRegisterCache.addVertexTempUsages(temp, 1);
                var Rtemp = new ShaderRegisterElement(temp.regName, temp.index);
                var R_rev = animationRegisterCache.getFreeVertexVectorTemp();
                R_rev = new ShaderRegisterElement(R_rev.regName, R_rev.index);

                var cos = new ShaderRegisterElement(Rtemp.regName, Rtemp.index, 3);
                var sin = new ShaderRegisterElement(R_rev.regName, R_rev.index, 3);

                animationRegisterCache.removeVertexTempUsage(nrmVel);
                animationRegisterCache.removeVertexTempUsage(xAxis);
                animationRegisterCache.removeVertexTempUsage(temp);

                var code = "";
                code += "mov " + nrmVel + ".xyz," + rotationRegister + ".xyz\n";
                code += "mov " + nrmVel + ".w," + animationRegisterCache.vertexZeroConst + "\n";

                code += "mul " + cos + "," + animationRegisterCache.vertexTime + "," + rotationRegister + ".w\n";

                code += "sin " + sin + "," + cos + "\n";
                code += "cos " + cos + "," + cos + "\n";

                code += "mul " + Rtemp + ".xyz," + sin + "," + nrmVel + ".xyz\n";

                code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";

                //nrmVel and xAxis are used as temp register
                code += "crs " + nrmVel + ".xyz," + Rtemp + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";

                code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";
                code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                code += "dp3 " + xAxis + ".w," + Rtemp + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";
                code += "neg " + nrmVel + ".w," + xAxis + ".w\n";

                code += "crs " + Rtemp + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";

                //use cos as R_rev.w
                code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
                code += "add " + Rtemp + ".xyz," + Rtemp + ".xyz," + xAxis + ".xyz\n";
                code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";

                code += "add " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + Rtemp + ".xyz," + xAxis + ".xyz\n";

                var len = animationRegisterCache.rotationRegisters.length;
                for (var i = 0; i < len; i++) {
                    code += "mov " + nrmVel + ".xyz," + rotationRegister + ".xyz\n";
                    code += "mov " + nrmVel + ".w," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mul " + cos + "," + animationRegisterCache.vertexTime + "," + rotationRegister + ".w\n";
                    code += "sin " + sin + "," + cos + "\n";
                    code += "cos " + cos + "," + cos + "\n";
                    code += "mul " + Rtemp + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                    code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                    code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";
                    code += "crs " + nrmVel + ".xyz," + Rtemp + ".xyz," + animationRegisterCache.rotationRegisters[i] + ".xyz\n";
                    code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterCache.rotationRegisters[i] + "\n";
                    code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                    code += "dp3 " + xAxis + ".w," + Rtemp + ".xyz," + animationRegisterCache.rotationRegisters[i] + "\n";
                    code += "neg " + nrmVel + ".w," + xAxis + ".w\n";
                    code += "crs " + Rtemp + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";
                    code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
                    code += "add " + Rtemp + ".xyz," + Rtemp + ".xyz," + xAxis + ".xyz\n";
                    code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";
                    code += "add " + animationRegisterCache.rotationRegisters[i] + "," + Rtemp + ".xyz," + xAxis + ".xyz\n";
                }
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleRotationalVelocityNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleRotationalVelocityNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                //(Vector3d.x,Vector3d.y,Vector3d.z) is rotation axis,Vector3d.w is cycle duration
                var rotate = param[ParticleRotationalVelocityNode.ROTATIONALVELOCITY_VECTOR3D];
                if (!rotate)
                    throw (new Error("there is no " + ParticleRotationalVelocityNode.ROTATIONALVELOCITY_VECTOR3D + " in param!"));

                if (rotate.length <= 0)
                    rotate.z = 1;
else
                    rotate.normalize();

                this._pOneData[0] = rotate.x;
                this._pOneData[1] = rotate.y;
                this._pOneData[2] = rotate.z;
                if (rotate.w <= 0)
                    throw (new Error("the cycle duration must greater than zero"));

                // it's used as angle/2 in agal
                this._pOneData[3] = Math.PI / rotate.w;
            };
            ParticleRotationalVelocityNode.ROTATIONALVELOCITY_INDEX = 0;

            ParticleRotationalVelocityNode.ROTATIONALVELOCITY_VECTOR3D = "RotationalVelocityVector3D";
            return ParticleRotationalVelocityNode;
        })(animators.ParticleNodeBase);
        animators.ParticleRotationalVelocityNode = ParticleRotationalVelocityNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the scale variation of a particle over time.
        */
        var ParticleScaleNode = (function (_super) {
            __extends(ParticleScaleNode, _super);
            /**
            * Creates a new <code>ParticleScaleNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] usesCycle       Defines whether the node uses the <code>cycleDuration</code> property in the shader to calculate the period of animation independent of particle duration. Defaults to false.
            * @param    [optional] usesPhase       Defines whether the node uses the <code>cyclePhase</code> property in the shader to calculate a starting offset to the animation cycle. Defaults to false.
            * @param    [optional] minScale        Defines the default min scale transform of the node, when in global mode. Defaults to 1.
            * @param    [optional] maxScale        Defines the default max color transform of the node, when in global mode. Defaults to 1.
            * @param    [optional] cycleDuration   Defines the default duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
            * @param    [optional] cyclePhase      Defines the default phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
            */
            function ParticleScaleNode(mode/*uint*/ , usesCycle, usesPhase, minScale, maxScale, cycleDuration, cyclePhase) {
                if (typeof minScale === "undefined") { minScale = 1; }
                if (typeof maxScale === "undefined") { maxScale = 1; }
                if (typeof cycleDuration === "undefined") { cycleDuration = 1; }
                if (typeof cyclePhase === "undefined") { cyclePhase = 0; }
                _super.call(this, "ParticleScale", mode, (usesCycle && usesPhase) ? 4 : ((usesCycle || usesPhase) ? 3 : 2), 3);

                this._pStateClass = animators.ParticleScaleState;

                this._iUsesCycle = usesCycle;
                this._iUsesPhase = usesPhase;

                this._iMinScale = minScale;
                this._iMaxScale = maxScale;
                this._iCycleDuration = cycleDuration;
                this._iCyclePhase = cyclePhase;
            }
            /**
            * @inheritDoc
            */
            ParticleScaleNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var code = "";
                var temp = animationRegisterCache.getFreeVertexSingleTemp();

                var scaleRegister = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleScaleNode.SCALE_INDEX, scaleRegister.index);

                if (this._iUsesCycle) {
                    code += "mul " + temp + "," + animationRegisterCache.vertexTime + "," + scaleRegister + ".z\n";

                    if (this._iUsesPhase)
                        code += "add " + temp + "," + temp + "," + scaleRegister + ".w\n";

                    code += "sin " + temp + "," + temp + "\n";
                }

                code += "mul " + temp + "," + scaleRegister + ".y," + ((this._iUsesCycle) ? temp : animationRegisterCache.vertexLife) + "\n";
                code += "add " + temp + "," + scaleRegister + ".x," + temp + "\n";
                code += "mul " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp + "\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleScaleNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleScaleNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var scale = param[ParticleScaleNode.SCALE_VECTOR3D];
                if (!scale)
                    throw (new Error("there is no " + ParticleScaleNode.SCALE_VECTOR3D + " in param!"));

                if (this._iUsesCycle) {
                    this._pOneData[0] = (scale.x + scale.y) / 2;
                    this._pOneData[1] = Math.abs(scale.x - scale.y) / 2;
                    if (scale.z <= 0)
                        throw (new Error("the cycle duration must be greater than zero"));
                    this._pOneData[2] = Math.PI * 2 / scale.z;
                    if (this._iUsesPhase)
                        this._pOneData[3] = scale.w * Math.PI / 180;
                } else {
                    this._pOneData[0] = scale.x;
                    this._pOneData[1] = scale.y - scale.x;
                }
            };
            ParticleScaleNode.SCALE_INDEX = 0;

            ParticleScaleNode.SCALE_VECTOR3D = "ScaleVector3D";
            return ParticleScaleNode;
        })(animators.ParticleNodeBase);
        animators.ParticleScaleNode = ParticleScaleNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var ColorTransform = away.geom.ColorTransform;
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        var ParticleSegmentedColorNode = (function (_super) {
            __extends(ParticleSegmentedColorNode, _super);
            function ParticleSegmentedColorNode(usesMultiplier, usesOffset, numSegmentPoint/*int*/ , startColor, endColor, segmentPoints) {
                //because of the stage3d register limitation, it only support the global mode
                _super.call(this, "ParticleSegmentedColor", animators.ParticlePropertiesMode.GLOBAL, 0, animators.ParticleAnimationSet.COLOR_PRIORITY);

                this._pStateClass = animators.ParticleSegmentedColorState;

                if (numSegmentPoint > 4)
                    throw (new Error("the numSegmentPoint must be less or equal 4"));
                this._iUsesMultiplier = usesMultiplier;
                this._iUsesOffset = usesOffset;
                this._iNumSegmentPoint = numSegmentPoint;
                this._iStartColor = startColor;
                this._iEndColor = endColor;
                this._iSegmentPoints = segmentPoints;
            }
            /**
            * @inheritDoc
            */
            ParticleSegmentedColorNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                if (this._iUsesMultiplier)
                    particleAnimationSet.hasColorMulNode = true;
                if (this._iUsesOffset)
                    particleAnimationSet.hasColorAddNode = true;
            };

            /**
            * @inheritDoc
            */
            ParticleSegmentedColorNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var code = "";
                if (animationRegisterCache.needFragmentAnimation) {
                    var accMultiplierColor;

                    if (this._iUsesMultiplier) {
                        accMultiplierColor = animationRegisterCache.getFreeVertexVectorTemp();
                        animationRegisterCache.addVertexTempUsages(accMultiplierColor, 1);
                    }

                    var tempColor = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(tempColor, 1);

                    var temp = animationRegisterCache.getFreeVertexVectorTemp();
                    var accTime = new ShaderRegisterElement(temp.regName, temp.index, 0);
                    var tempTime = new ShaderRegisterElement(temp.regName, temp.index, 1);

                    if (this._iUsesMultiplier)
                        animationRegisterCache.removeVertexTempUsage(accMultiplierColor);

                    animationRegisterCache.removeVertexTempUsage(tempColor);

                    //for saving all the life values (at most 4)
                    var lifeTimeRegister = animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.setRegisterIndex(this, ParticleSegmentedColorNode.TIME_DATA_INDEX, lifeTimeRegister.index);

                    var i/*int*/ ;

                    var startMulValue;
                    var deltaMulValues;
                    if (this._iUsesMultiplier) {
                        startMulValue = animationRegisterCache.getFreeVertexConstant();
                        animationRegisterCache.setRegisterIndex(this, ParticleSegmentedColorNode.START_MULTIPLIER_INDEX, startMulValue.index);
                        deltaMulValues = new Array();
                        for (i = 0; i < this._iNumSegmentPoint + 1; i++)
                            deltaMulValues.push(animationRegisterCache.getFreeVertexConstant());
                    }

                    var startOffsetValue;
                    var deltaOffsetValues;
                    if (this._iUsesOffset) {
                        startOffsetValue = animationRegisterCache.getFreeVertexConstant();
                        animationRegisterCache.setRegisterIndex(this, ParticleSegmentedColorNode.START_OFFSET_INDEX, startOffsetValue.index);
                        deltaOffsetValues = new Array();
                        for (i = 0; i < this._iNumSegmentPoint + 1; i++)
                            deltaOffsetValues.push(animationRegisterCache.getFreeVertexConstant());
                    }

                    if (this._iUsesMultiplier)
                        code += "mov " + accMultiplierColor + "," + startMulValue + "\n";
                    if (this._iUsesOffset)
                        code += "add " + animationRegisterCache.colorAddTarget + "," + animationRegisterCache.colorAddTarget + "," + startOffsetValue + "\n";

                    for (i = 0; i < this._iNumSegmentPoint; i++) {
                        switch (i) {
                            case 0:
                                code += "min " + tempTime + "," + animationRegisterCache.vertexLife + "," + lifeTimeRegister + ".x\n";
                                break;
                            case 1:
                                code += "sub " + accTime + "," + animationRegisterCache.vertexLife + "," + lifeTimeRegister + ".x\n";
                                code += "max " + tempTime + "," + accTime + "," + animationRegisterCache.vertexZeroConst + "\n";
                                code += "min " + tempTime + "," + tempTime + "," + lifeTimeRegister + ".y\n";
                                break;
                            case 2:
                                code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".y\n";
                                code += "max " + tempTime + "," + accTime + "," + animationRegisterCache.vertexZeroConst + "\n";
                                code += "min " + tempTime + "," + tempTime + "," + lifeTimeRegister + ".z\n";
                                break;
                            case 3:
                                code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".z\n";
                                code += "max " + tempTime + "," + accTime + "," + animationRegisterCache.vertexZeroConst + "\n";
                                code += "min " + tempTime + "," + tempTime + "," + lifeTimeRegister + ".w\n";
                                break;
                        }
                        if (this._iUsesMultiplier) {
                            code += "mul " + tempColor + "," + tempTime + "," + deltaMulValues[i] + "\n";
                            code += "add " + accMultiplierColor + "," + accMultiplierColor + "," + tempColor + "\n";
                        }
                        if (this._iUsesOffset) {
                            code += "mul " + tempColor + "," + tempTime + "," + deltaOffsetValues[i] + "\n";
                            code += "add " + animationRegisterCache.colorAddTarget + "," + animationRegisterCache.colorAddTarget + "," + tempColor + "\n";
                        }
                    }

                    if (this._iNumSegmentPoint == 0)
                        tempTime = animationRegisterCache.vertexLife;
else {
                        switch (this._iNumSegmentPoint) {
                            case 1:
                                code += "sub " + accTime + "," + animationRegisterCache.vertexLife + "," + lifeTimeRegister + ".x\n";
                                break;
                            case 2:
                                code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".y\n";
                                break;
                            case 3:
                                code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".z\n";
                                break;
                            case 4:
                                code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".w\n";
                                break;
                        }
                        code += "max " + tempTime + "," + accTime + "," + animationRegisterCache.vertexZeroConst + "\n";
                    }
                    if (this._iUsesMultiplier) {
                        code += "mul " + tempColor + "," + tempTime + "," + deltaMulValues[this._iNumSegmentPoint] + "\n";
                        code += "add " + accMultiplierColor + "," + accMultiplierColor + "," + tempColor + "\n";
                        code += "mul " + animationRegisterCache.colorMulTarget + "," + animationRegisterCache.colorMulTarget + "," + accMultiplierColor + "\n";
                    }
                    if (this._iUsesOffset) {
                        code += "mul " + tempColor + "," + tempTime + "," + deltaOffsetValues[this._iNumSegmentPoint] + "\n";
                        code += "add " + animationRegisterCache.colorAddTarget + "," + animationRegisterCache.colorAddTarget + "," + tempColor + "\n";
                    }
                }
                return code;
            };
            ParticleSegmentedColorNode.START_MULTIPLIER_INDEX = 0;

            ParticleSegmentedColorNode.START_OFFSET_INDEX = 1;

            ParticleSegmentedColorNode.TIME_DATA_INDEX = 2;
            return ParticleSegmentedColorNode;
        })(animators.ParticleNodeBase);
        animators.ParticleSegmentedColorNode = ParticleSegmentedColorNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used when a spritesheet texture is required to animate the particle.
        * NB: to enable use of this node, the <code>repeat</code> property on the material has to be set to true.
        */
        var ParticleSpriteSheetNode = (function (_super) {
            __extends(ParticleSpriteSheetNode, _super);
            /**
            * Creates a new <code>ParticleSpriteSheetNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] numColumns      Defines the number of columns in the spritesheet, when in global mode. Defaults to 1.
            * @param    [optional] numRows         Defines the number of rows in the spritesheet, when in global mode. Defaults to 1.
            * @param    [optional] cycleDuration   Defines the default cycle duration in seconds, when in global mode. Defaults to 1.
            * @param    [optional] cyclePhase      Defines the default cycle phase, when in global mode. Defaults to 0.
            * @param    [optional] totalFrames     Defines the total number of frames used by the spritesheet, when in global mode. Defaults to the number defined by numColumns and numRows.
            * @param    [optional] looping         Defines whether the spritesheet animation is set to loop indefinitely. Defaults to true.
            */
            function ParticleSpriteSheetNode(mode/*uint*/ , usesCycle, usesPhase, numColumns, numRows, cycleDuration, cyclePhase, totalFrames) {
                if (typeof numColumns === "undefined") { numColumns = 1; }
                if (typeof numRows === "undefined") { numRows = 1; }
                if (typeof cycleDuration === "undefined") { cycleDuration = 1; }
                if (typeof cyclePhase === "undefined") { cyclePhase = 0; }
                if (typeof totalFrames === "undefined") { totalFrames = Number.MAX_VALUE; }
                _super.call(this, "ParticleSpriteSheet", mode, usesCycle ? (usesPhase ? 3 : 2) : 1, animators.ParticleAnimationSet.POST_PRIORITY + 1);

                this._pStateClass = animators.ParticleSpriteSheetState;

                this._iUsesCycle = usesCycle;
                this._iUsesPhase = usesPhase;

                this._iNumColumns = numColumns;
                this._iNumRows = numRows;
                this._iCyclePhase = cyclePhase;
                this._iCycleDuration = cycleDuration;
                this._iTotalFrames = Math.min(totalFrames, numColumns * numRows);
            }
            Object.defineProperty(ParticleSpriteSheetNode.prototype, "numColumns", {
                get: /**
                * Defines the number of columns in the spritesheet, when in global mode. Defaults to 1. Read only.
                */
                function () {
                    return this._iNumColumns;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleSpriteSheetNode.prototype, "numRows", {
                get: /**
                * Defines the number of rows in the spritesheet, when in global mode. Defaults to 1. Read only.
                */
                function () {
                    return this._iNumRows;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleSpriteSheetNode.prototype, "totalFrames", {
                get: /**
                * Defines the total number of frames used by the spritesheet, when in global mode. Defaults to the number defined by numColumns and numRows. Read only.
                */
                function () {
                    return this._iTotalFrames;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            ParticleSpriteSheetNode.prototype.getAGALUVCode = function (pass, animationRegisterCache) {
                //get 2 vc
                var uvParamConst1 = animationRegisterCache.getFreeVertexConstant();
                var uvParamConst2 = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleSpriteSheetNode.UV_INDEX_0, uvParamConst1.index);
                animationRegisterCache.setRegisterIndex(this, ParticleSpriteSheetNode.UV_INDEX_1, uvParamConst2.index);

                var uTotal = new ShaderRegisterElement(uvParamConst1.regName, uvParamConst1.index, 0);
                var uStep = new ShaderRegisterElement(uvParamConst1.regName, uvParamConst1.index, 1);
                var vStep = new ShaderRegisterElement(uvParamConst1.regName, uvParamConst1.index, 2);

                var uSpeed = new ShaderRegisterElement(uvParamConst2.regName, uvParamConst2.index, 0);
                var cycle = new ShaderRegisterElement(uvParamConst2.regName, uvParamConst2.index, 1);
                var phaseTime = new ShaderRegisterElement(uvParamConst2.regName, uvParamConst2.index, 2);

                var temp = animationRegisterCache.getFreeVertexVectorTemp();
                var time = new ShaderRegisterElement(temp.regName, temp.index, 0);
                var vOffset = new ShaderRegisterElement(temp.regName, temp.index, 1);
                temp = new ShaderRegisterElement(temp.regName, temp.index, 2);
                var temp2 = new ShaderRegisterElement(temp.regName, temp.index, 3);

                var u = new ShaderRegisterElement(animationRegisterCache.uvTarget.regName, animationRegisterCache.uvTarget.index, 0);
                var v = new ShaderRegisterElement(animationRegisterCache.uvTarget.regName, animationRegisterCache.uvTarget.index, 1);

                var code = "";

                //scale uv
                code += "mul " + u + "," + u + "," + uStep + "\n";
                if (this._iNumRows > 1)
                    code += "mul " + v + "," + v + "," + vStep + "\n";

                if (this._iUsesCycle) {
                    if (this._iUsesPhase)
                        code += "add " + time + "," + animationRegisterCache.vertexTime + "," + phaseTime + "\n";
else
                        code += "mov " + time + "," + animationRegisterCache.vertexTime + "\n";
                    code += "div " + time + "," + time + "," + cycle + "\n";
                    code += "frc " + time + "," + time + "\n";
                    code += "mul " + time + "," + time + "," + cycle + "\n";
                    code += "mul " + temp + "," + time + "," + uSpeed + "\n";
                } else
                    code += "mul " + temp.toString() + "," + animationRegisterCache.vertexLife + "," + uTotal + "\n";

                if (this._iNumRows > 1) {
                    code += "frc " + temp2 + "," + temp + "\n";
                    code += "sub " + vOffset + "," + temp + "," + temp2 + "\n";
                    code += "mul " + vOffset + "," + vOffset + "," + vStep + "\n";
                    code += "add " + v + "," + v + "," + vOffset + "\n";
                }

                code += "div " + temp2 + "," + temp + "," + uStep + "\n";
                code += "frc " + temp + "," + temp2 + "\n";
                code += "sub " + temp2 + "," + temp2 + "," + temp + "\n";
                code += "mul " + temp + "," + temp2 + "," + uStep + "\n";

                if (this._iNumRows > 1)
                    code += "frc " + temp + "," + temp + "\n";
                code += "add " + u + "," + u + "," + temp + "\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleSpriteSheetNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleSpriteSheetNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                particleAnimationSet.hasUVNode = true;
            };

            /**
            * @inheritDoc
            */
            ParticleSpriteSheetNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                if (this._iUsesCycle) {
                    var uvCycle = param[ParticleSpriteSheetNode.UV_VECTOR3D];
                    if (!uvCycle)
                        throw (new Error("there is no " + ParticleSpriteSheetNode.UV_VECTOR3D + " in param!"));
                    if (uvCycle.x <= 0)
                        throw (new Error("the cycle duration must be greater than zero"));
                    var uTotal = this._iTotalFrames / this._iNumColumns;
                    this._pOneData[0] = uTotal / uvCycle.x;
                    this._pOneData[1] = uvCycle.x;
                    if (this._iUsesPhase)
                        this._pOneData[2] = uvCycle.y;
                }
            };
            ParticleSpriteSheetNode.UV_INDEX_0 = 0;

            ParticleSpriteSheetNode.UV_INDEX_1 = 1;

            ParticleSpriteSheetNode.UV_VECTOR3D = "UVVector3D";
            return ParticleSpriteSheetNode;
        })(animators.ParticleNodeBase);
        animators.ParticleSpriteSheetNode = ParticleSpriteSheetNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used as the base node for timekeeping inside a particle. Automatically added to a particle animation set on instatiation.
        */
        var ParticleTimeNode = (function (_super) {
            __extends(ParticleTimeNode, _super);
            /**
            * Creates a new <code>ParticleTimeNode</code>
            *
            * @param    [optional] usesDuration    Defines whether the node uses the <code>duration</code> data in the static properties to determine how long a particle is visible for. Defaults to false.
            * @param    [optional] usesDelay       Defines whether the node uses the <code>delay</code> data in the static properties to determine how long a particle is hidden for. Defaults to false. Requires <code>usesDuration</code> to be true.
            * @param    [optional] usesLooping     Defines whether the node creates a looping timeframe for each particle determined by the <code>startTime</code>, <code>duration</code> and <code>delay</code> data in the static properties function. Defaults to false. Requires <code>usesLooping</code> to be true.
            */
            function ParticleTimeNode(usesDuration, usesLooping, usesDelay) {
                if (typeof usesDuration === "undefined") { usesDuration = false; }
                if (typeof usesLooping === "undefined") { usesLooping = false; }
                if (typeof usesDelay === "undefined") { usesDelay = false; }
                this._pStateClass = animators.ParticleTimeState;

                this._iUsesDuration = usesDuration;
                this._iUsesLooping = usesLooping;
                this._iUsesDelay = usesDelay;

                _super.call(this, "ParticleTime", animators.ParticlePropertiesMode.LOCAL_STATIC, 4, 0);
            }
            /**
            * @inheritDoc
            */
            ParticleTimeNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var timeStreamRegister = animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleTimeNode.TIME_STREAM_INDEX, timeStreamRegister.index);
                var timeConst = animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.setRegisterIndex(this, ParticleTimeNode.TIME_CONSTANT_INDEX, timeConst.index);

                var code = "";
                code += "sub " + animationRegisterCache.vertexTime + "," + timeConst + "," + timeStreamRegister + ".x\n";

                //if time=0,set the position to zero.
                var temp = animationRegisterCache.getFreeVertexSingleTemp();
                code += "sge " + temp + "," + animationRegisterCache.vertexTime + "," + animationRegisterCache.vertexZeroConst + "\n";
                code += "mul " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp + "\n";
                if (this._iUsesDuration) {
                    if (this._iUsesLooping) {
                        var div = animationRegisterCache.getFreeVertexSingleTemp();
                        if (this._iUsesDelay) {
                            code += "div " + div + "," + animationRegisterCache.vertexTime + "," + timeStreamRegister + ".z\n";
                            code += "frc " + div + "," + div + "\n";
                            code += "mul " + animationRegisterCache.vertexTime + "," + div + "," + timeStreamRegister + ".z\n";
                            code += "slt " + div + "," + animationRegisterCache.vertexTime + "," + timeStreamRegister + ".y\n";
                            code += "mul " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + div + "\n";
                        } else {
                            code += "mul " + div + "," + animationRegisterCache.vertexTime + "," + timeStreamRegister + ".w\n";
                            code += "frc " + div + "," + div + "\n";
                            code += "mul " + animationRegisterCache.vertexTime + "," + div + "," + timeStreamRegister + ".y\n";
                        }
                    } else {
                        var sge = animationRegisterCache.getFreeVertexSingleTemp();
                        code += "sge " + sge + "," + timeStreamRegister + ".y," + animationRegisterCache.vertexTime + "\n";
                        code += "mul " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + sge + "\n";
                    }
                }
                code += "mul " + animationRegisterCache.vertexLife + "," + animationRegisterCache.vertexTime + "," + timeStreamRegister + ".w\n";
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleTimeNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleTimeNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                this._pOneData[0] = param.startTime;
                this._pOneData[1] = param.duration;
                this._pOneData[2] = param.delay + param.duration;
                this._pOneData[3] = 1 / param.duration;
            };
            ParticleTimeNode.TIME_STREAM_INDEX = 0;

            ParticleTimeNode.TIME_CONSTANT_INDEX = 1;
            return ParticleTimeNode;
        })(animators.ParticleNodeBase);
        animators.ParticleTimeNode = ParticleTimeNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the UV offset and scale of a particle over time.
        */
        var ParticleUVNode = (function (_super) {
            __extends(ParticleUVNode, _super);
            /**
            * Creates a new <code>ParticleTimeNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] cycle           Defines whether the time track is in loop mode. Defaults to false.
            * @param    [optional] scale           Defines whether the time track is in loop mode. Defaults to false.
            * @param    [optional] axis            Defines whether the time track is in loop mode. Defaults to false.
            */
            function ParticleUVNode(mode/*uint*/ , cycle, scale, axis) {
                if (typeof cycle === "undefined") { cycle = 1; }
                if (typeof scale === "undefined") { scale = 1; }
                if (typeof axis === "undefined") { axis = "x"; }
                //because of the stage3d register limitation, it only support the global mode
                _super.call(this, "ParticleUV", animators.ParticlePropertiesMode.GLOBAL, 4, animators.ParticleAnimationSet.POST_PRIORITY + 1);

                this._pStateClass = animators.ParticleUVState;

                this._cycle = cycle;
                this._scale = scale;
                this._axis = axis;

                this.updateUVData();
            }
            Object.defineProperty(ParticleUVNode.prototype, "cycle", {
                get: /**
                *
                */
                function () {
                    return this._cycle;
                },
                set: function (value) {
                    this._cycle = value;

                    this.updateUVData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleUVNode.prototype, "scale", {
                get: /**
                *
                */
                function () {
                    return this._scale;
                },
                set: function (value) {
                    this._scale = value;

                    this.updateUVData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleUVNode.prototype, "axis", {
                get: /**
                *
                */
                function () {
                    return this._axis;
                },
                set: function (value) {
                    this._axis = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ParticleUVNode.prototype.getAGALUVCode = function (pass, animationRegisterCache) {
                var code = "";

                if (animationRegisterCache.needUVAnimation) {
                    var uvConst = animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.setRegisterIndex(this, ParticleUVNode.UV_INDEX, uvConst.index);

                    var axisIndex = this._axis == "x" ? 0 : this._axis == "y" ? 1 : 2;
                    var target = new ShaderRegisterElement(animationRegisterCache.uvTarget.regName, animationRegisterCache.uvTarget.index, axisIndex);

                    var sin = animationRegisterCache.getFreeVertexSingleTemp();

                    if (this._scale != 1)
                        code += "mul " + target + "," + target + "," + uvConst + ".y\n";

                    code += "mul " + sin + "," + animationRegisterCache.vertexTime + "," + uvConst + ".x\n";
                    code += "sin " + sin + "," + sin + "\n";
                    code += "add " + target + "," + target + "," + sin + "\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleUVNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            ParticleUVNode.prototype.updateUVData = function () {
                this._iUvData = new Vector3D(Math.PI * 2 / this._cycle, this._scale, 0, 0);
            };

            /**
            * @inheritDoc
            */
            ParticleUVNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                particleAnimationSet.hasUVNode = true;
            };
            ParticleUVNode.UV_INDEX = 0;

            ParticleUVNode.U_AXIS = "x";

            ParticleUVNode.V_AXIS = "y";
            return ParticleUVNode;
        })(animators.ParticleNodeBase);
        animators.ParticleUVNode = ParticleUVNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to set the starting velocity of a particle.
        */
        var ParticleVelocityNode = (function (_super) {
            __extends(ParticleVelocityNode, _super);
            /**
            * Creates a new <code>ParticleVelocityNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] velocity        Defines the default velocity vector of the node, used when in global mode.
            */
            function ParticleVelocityNode(mode/*uint*/ , velocity) {
                if (typeof velocity === "undefined") { velocity = null; }
                _super.call(this, "ParticleVelocity", mode, 3);

                this._pStateClass = animators.ParticleVelocityState;

                this._iVelocity = velocity || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleVelocityNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var velocityValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleVelocityNode.VELOCITY_INDEX, velocityValue.index);

                var distance = animationRegisterCache.getFreeVertexVectorTemp();
                var code = "";
                code += "mul " + distance + "," + animationRegisterCache.vertexTime + "," + velocityValue + "\n";
                code += "add " + animationRegisterCache.positionTarget + ".xyz," + distance + "," + animationRegisterCache.positionTarget + ".xyz\n";

                if (animationRegisterCache.needVelocity)
                    code += "add " + animationRegisterCache.velocityTarget + ".xyz," + velocityValue + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleVelocityNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleVelocityNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var _tempVelocity = param[ParticleVelocityNode.VELOCITY_VECTOR3D];
                if (!_tempVelocity)
                    throw new Error("there is no " + ParticleVelocityNode.VELOCITY_VECTOR3D + " in param!");

                this._pOneData[0] = _tempVelocity.x;
                this._pOneData[1] = _tempVelocity.y;
                this._pOneData[2] = _tempVelocity.z;
            };
            ParticleVelocityNode.VELOCITY_INDEX = 0;

            ParticleVelocityNode.VELOCITY_VECTOR3D = "VelocityVector3D";
            return ParticleVelocityNode;
        })(animators.ParticleNodeBase);
        animators.ParticleVelocityNode = ParticleVelocityNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * A skeleton animation node that uses two animation node inputs to blend a lineraly interpolated output of a skeleton pose.
        */
        var SkeletonBinaryLERPNode = (function (_super) {
            __extends(SkeletonBinaryLERPNode, _super);
            /**
            * Creates a new <code>SkeletonBinaryLERPNode</code> object.
            */
            function SkeletonBinaryLERPNode() {
                _super.call(this);

                this._pStateClass = animators.SkeletonBinaryLERPState;
            }
            /**
            * @inheritDoc
            */
            SkeletonBinaryLERPNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };
            return SkeletonBinaryLERPNode;
        })(animators.AnimationNodeBase);
        animators.SkeletonBinaryLERPNode = SkeletonBinaryLERPNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        /**
        * A skeleton animation node containing time-based animation data as individual skeleton poses.
        */
        var SkeletonClipNode = (function (_super) {
            __extends(SkeletonClipNode, _super);
            /**
            * Creates a new <code>SkeletonClipNode</code> object.
            */
            function SkeletonClipNode() {
                _super.call(this);
                this._frames = new Array();
                /**
                * Determines whether to use SLERP equations (true) or LERP equations (false) in the calculation
                * of the output skeleton pose. Defaults to false.
                */
                this.highQuality = false;

                this._pStateClass = animators.SkeletonClipState;
            }
            Object.defineProperty(SkeletonClipNode.prototype, "frames", {
                get: /**
                * Returns a vector of skeleton poses representing the pose of each animation frame in the clip.
                */
                function () {
                    return this._frames;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Adds a skeleton pose frame to the internal timeline of the animation node.
            *
            * @param skeletonPose The skeleton pose object to add to the timeline of the node.
            * @param duration The specified duration of the frame in milliseconds.
            */
            SkeletonClipNode.prototype.addFrame = function (skeletonPose, duration/*number /*uint*/ ) {
                this._frames.push(skeletonPose);
                this._pDurations.push(duration);

                this._pNumFrames = this._pDurations.length;

                this._pStitchDirty = true;
            };

            /**
            * @inheritDoc
            */
            SkeletonClipNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            SkeletonClipNode.prototype._pUpdateStitch = function () {
                _super.prototype._pUpdateStitch.call(this);

                var i = this._pNumFrames - 1;
                var p1, p2, delta;
                while (i--) {
                    this._pTotalDuration += this._pDurations[i];
                    p1 = this._frames[i].jointPoses[0].translation;
                    p2 = this._frames[i + 1].jointPoses[0].translation;
                    delta = p2.subtract(p1);
                    this._pTotalDelta.x += delta.x;
                    this._pTotalDelta.y += delta.y;
                    this._pTotalDelta.z += delta.z;
                }

                if (this._pStitchFinalFrame || !this._pLooping) {
                    this._pTotalDuration += this._pDurations[this._pNumFrames - 1];
                    p1 = this._frames[0].jointPoses[0].translation;
                    p2 = this._frames[1].jointPoses[0].translation;
                    delta = p2.subtract(p1);
                    this._pTotalDelta.x += delta.x;
                    this._pTotalDelta.y += delta.y;
                    this._pTotalDelta.z += delta.z;
                }
            };
            return SkeletonClipNode;
        })(animators.AnimationClipNodeBase);
        animators.SkeletonClipNode = SkeletonClipNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * A skeleton animation node that uses a difference input pose with a base input pose to blend a linearly interpolated output of a skeleton pose.
        */
        var SkeletonDifferenceNode = (function (_super) {
            __extends(SkeletonDifferenceNode, _super);
            /**
            * Creates a new <code>SkeletonAdditiveNode</code> object.
            */
            function SkeletonDifferenceNode() {
                _super.call(this);

                this._pStateClass = animators.SkeletonDifferenceState;
            }
            /**
            * @inheritDoc
            */
            SkeletonDifferenceNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };
            return SkeletonDifferenceNode;
        })(animators.AnimationNodeBase);
        animators.SkeletonDifferenceNode = SkeletonDifferenceNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * A skeleton animation node that uses four directional input poses with an input direction to blend a linearly interpolated output of a skeleton pose.
        */
        var SkeletonDirectionalNode = (function (_super) {
            __extends(SkeletonDirectionalNode, _super);
            function SkeletonDirectionalNode() {
                _super.call(this);

                this._pStateClass = animators.SkeletonDirectionalState;
            }
            /**
            * @inheritDoc
            */
            SkeletonDirectionalNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };
            return SkeletonDirectionalNode;
        })(animators.AnimationNodeBase);
        animators.SkeletonDirectionalNode = SkeletonDirectionalNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * A skeleton animation node that uses an n-dimensional array of animation node inputs to blend a lineraly interpolated output of a skeleton pose.
        */
        var SkeletonNaryLERPNode = (function (_super) {
            __extends(SkeletonNaryLERPNode, _super);
            /**
            * Creates a new <code>SkeletonNaryLERPNode</code> object.
            */
            function SkeletonNaryLERPNode() {
                _super.call(this);
                this._iInputs = new Array();

                this._pStateClass = animators.SkeletonNaryLERPState;
            }
            Object.defineProperty(SkeletonNaryLERPNode.prototype, "numInputs", {
                get: function () {
                    return this._numInputs;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns an integer representing the input index of the given skeleton animation node.
            *
            * @param input The skeleton animation node for with the input index is requested.
            */
            SkeletonNaryLERPNode.prototype.getInputIndex = function (input) {
                return this._iInputs.indexOf(input);
            };

            /**
            * Returns the skeleton animation node object that resides at the given input index.
            *
            * @param index The input index for which the skeleton animation node is requested.
            */
            SkeletonNaryLERPNode.prototype.getInputAt = function (index/*uint*/ ) {
                return this._iInputs[index];
            };

            /**
            * Adds a new skeleton animation node input to the animation node.
            */
            SkeletonNaryLERPNode.prototype.addInput = function (input) {
                this._iInputs[this._numInputs++] = input;
            };

            /**
            * @inheritDoc
            */
            SkeletonNaryLERPNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };
            return SkeletonNaryLERPNode;
        })(animators.AnimationNodeBase);
        animators.SkeletonNaryLERPNode = SkeletonNaryLERPNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * A vertex animation node containing time-based animation data as individual geometry obejcts.
        */
        var VertexClipNode = (function (_super) {
            __extends(VertexClipNode, _super);
            /**
            * Creates a new <code>VertexClipNode</code> object.
            */
            function VertexClipNode() {
                _super.call(this);
                this._frames = new Array();
                this._translations = new Array();

                this._pStateClass = away.animators.VertexClipState;
            }
            Object.defineProperty(VertexClipNode.prototype, "frames", {
                get: /**
                * Returns a vector of geometry frames representing the vertex values of each animation frame in the clip.
                */
                function () {
                    return this._frames;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Adds a geometry object to the internal timeline of the animation node.
            *
            * @param geometry The geometry object to add to the timeline of the node.
            * @param duration The specified duration of the frame in milliseconds.
            * @param translation The absolute translation of the frame, used in root delta calculations for mesh movement.
            */
            VertexClipNode.prototype.addFrame = function (geometry, duration/*uint*/ , translation) {
                if (typeof translation === "undefined") { translation = null; }
                this._frames.push(geometry);
                this._pDurations.push(duration);
                this._translations.push(translation || new away.geom.Vector3D());

                this._pNumFrames = this._pDurations.length;

                this._pStitchDirty = true;
            };

            /**
            * @inheritDoc
            */
            VertexClipNode.prototype._pUpdateStitch = function () {
                _super.prototype._pUpdateStitch.call(this);

                var i = this._pNumFrames - 1;
                var p1, p2, delta;
                while (i--) {
                    this._pTotalDuration += this._pDurations[i];
                    p1 = this._translations[i];
                    p2 = this._translations[i + 1];
                    delta = p2.subtract(p1);
                    this._pTotalDelta.x += delta.x;
                    this._pTotalDelta.y += delta.y;
                    this._pTotalDelta.z += delta.z;
                }

                if (this._pNumFrames > 1 && (this._pStitchFinalFrame || !this._pLooping)) {
                    this._pTotalDuration += this._pDurations[this._pNumFrames - 1];
                    p1 = this._translations[0];
                    p2 = this._translations[1];
                    delta = p2.subtract(p1);
                    this._pTotalDelta.x += delta.x;
                    this._pTotalDelta.y += delta.y;
                    this._pTotalDelta.z += delta.z;
                }
            };
            return VertexClipNode;
        })(animators.AnimationClipNodeBase);
        animators.VertexClipNode = VertexClipNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        *
        */
        var AnimationStateBase = (function () {
            function AnimationStateBase(animator, animationNode) {
                this._pRootDelta = new away.geom.Vector3D();
                this._pPositionDeltaDirty = true;
                this._pStartTime = 0;
                this._pAnimator = animator;
                this._pAnimationNode = animationNode;
            }
            Object.defineProperty(AnimationStateBase.prototype, "positionDelta", {
                get: /**
                * Returns a 3d vector representing the translation delta of the animating entity for the current timestep of animation
                */
                function () {
                    if (this._pPositionDeltaDirty) {
                        this._pUpdatePositionDelta();
                    }

                    return this._pRootDelta;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Resets the start time of the node to a  new value.
            *
            * @param startTime The absolute start time (in milliseconds) of the node's starting time.
            */
            AnimationStateBase.prototype.offset = function (startTime) {
                this._pStartTime = startTime;

                this._pPositionDeltaDirty = true;
            };

            /**
            * Updates the configuration of the node to its current state.
            *
            * @param time The absolute time (in milliseconds) of the animator's play head position.
            *
            * @see away.animators.AnimatorBase#update()
            */
            AnimationStateBase.prototype.update = function (time) {
                if (this._pTime == time - this._pStartTime) {
                    return;
                }

                this._pUpdateTime(time);
            };

            /**
            * Sets the animation phase of the node.
            *
            * @param value The phase value to use. 0 represents the beginning of an animation clip, 1 represents the end.
            */
            AnimationStateBase.prototype.phase = function (value) {
            };

            /**
            * Updates the node's internal playhead position.
            *
            * @param time The local time (in milliseconds) of the node's playhead position.
            */
            AnimationStateBase.prototype._pUpdateTime = function (time) {
                this._pTime = time - this._pStartTime;

                this._pPositionDeltaDirty = true;
            };

            /**
            * Updates the node's root delta position
            */
            AnimationStateBase.prototype._pUpdatePositionDelta = function () {
            };
            return AnimationStateBase;
        })();
        animators.AnimationStateBase = AnimationStateBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var StageGL = away.base.StageGL;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var RenderableBase = away.pool.RenderableBase;

        /**
        * ...
        */
        var ParticleStateBase = (function (_super) {
            __extends(ParticleStateBase, _super);
            function ParticleStateBase(animator, particleNode, needUpdateTime) {
                if (typeof needUpdateTime === "undefined") { needUpdateTime = false; }
                _super.call(this, animator, particleNode);
                this._pDynamicProperties = new Array();
                this._pDynamicPropertiesDirty = new Object();

                this._particleNode = particleNode;
                this._pNeedUpdateTime = needUpdateTime;
            }
            Object.defineProperty(ParticleStateBase.prototype, "needUpdateTime", {
                get: function () {
                    return this._pNeedUpdateTime;
                },
                enumerable: true,
                configurable: true
            });

            ParticleStateBase.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
            };

            ParticleStateBase.prototype._pUpdateDynamicProperties = function (animationSubGeometry) {
                this._pDynamicPropertiesDirty[animationSubGeometry._iUniqueId] = true;

                var animationParticles = animationSubGeometry.animationParticles;
                var vertexData = animationSubGeometry.vertexData;
                var totalLenOfOneVertex = animationSubGeometry.totalLenOfOneVertex;
                var dataLength = this._particleNode.dataLength;
                var dataOffset = this._particleNode._iDataOffset;
                var vertexLength/*uint*/ ;

                //			var particleOffset:number /*uint*/;
                var startingOffset/*uint*/ ;
                var vertexOffset/*uint*/ ;
                var data;
                var animationParticle;

                //			var numParticles:number /*uint*/ = _positions.length/dataLength;
                var numParticles = this._pDynamicProperties.length;
                var i = 0;
                var j = 0;
                var k = 0;

                while (i < numParticles) {
                    while (j < numParticles && (animationParticle = animationParticles[j]).index == i) {
                        data = this._pDynamicProperties[i];
                        vertexLength = animationParticle.numVertices * totalLenOfOneVertex;
                        startingOffset = animationParticle.startVertexIndex * totalLenOfOneVertex + dataOffset;

                        for (k = 0; k < vertexLength; k += totalLenOfOneVertex) {
                            vertexOffset = startingOffset + k;

                            for (k = 0; k < vertexLength; k += totalLenOfOneVertex) {
                                vertexOffset = startingOffset + k;
                                vertexData[vertexOffset++] = data.x;
                                vertexData[vertexOffset++] = data.y;
                                vertexData[vertexOffset++] = data.z;

                                if (dataLength == 4)
                                    vertexData[vertexOffset++] = data.w;
                            }
                            //loop through each value in the particle vertex
                            //						switch(dataLength) {
                            //							case 4:
                            //								vertexData[vertexOffset++] = _positions[particleOffset++];
                            //							case 3:
                            //								vertexData[vertexOffset++] = _positions[particleOffset++];
                            //							case 2:
                            //								vertexData[vertexOffset++] = _positions[particleOffset++];
                            //							case 1:
                            //								vertexData[vertexOffset++] = _positions[particleOffset++];
                            //						}
                        }
                        j++;
                    }
                    i++;
                }

                animationSubGeometry.invalidateBuffer();
            };
            return ParticleStateBase;
        })(animators.AnimationStateBase);
        animators.ParticleStateBase = ParticleStateBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        */
        var ParticleAccelerationState = (function (_super) {
            __extends(ParticleAccelerationState, _super);
            function ParticleAccelerationState(animator, particleAccelerationNode) {
                _super.call(this, animator, particleAccelerationNode);

                this._particleAccelerationNode = particleAccelerationNode;
                this._acceleration = this._particleAccelerationNode._acceleration;

                this.updateAccelerationData();
            }
            Object.defineProperty(ParticleAccelerationState.prototype, "acceleration", {
                get: /**
                * Defines the acceleration vector of the state, used when in global mode.
                */
                function () {
                    return this._acceleration;
                },
                set: function (value) {
                    this._acceleration.x = value.x;
                    this._acceleration.y = value.y;
                    this._acceleration.z = value.z;

                    this.updateAccelerationData();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ParticleAccelerationState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleAccelerationNode.ACCELERATION_INDEX);

                if (this._particleAccelerationNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC)
                    animationSubGeometry.activateVertexBuffer(index, this._particleAccelerationNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
else
                    animationRegisterCache.setVertexConst(index, this._halfAcceleration.x, this._halfAcceleration.y, this._halfAcceleration.z);
            };

            ParticleAccelerationState.prototype.updateAccelerationData = function () {
                if (this._particleAccelerationNode.mode == animators.ParticlePropertiesMode.GLOBAL)
                    this._halfAcceleration = new Vector3D(this._acceleration.x / 2, this._acceleration.y / 2, this._acceleration.z / 2);
            };
            return ParticleAccelerationState;
        })(animators.ParticleStateBase);
        animators.ParticleAccelerationState = ParticleAccelerationState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        */
        var ParticleBezierCurveState = (function (_super) {
            __extends(ParticleBezierCurveState, _super);
            function ParticleBezierCurveState(animator, particleBezierCurveNode) {
                _super.call(this, animator, particleBezierCurveNode);

                this._particleBezierCurveNode = particleBezierCurveNode;
                this._controlPoint = this._particleBezierCurveNode._iControlPoint;
                this._endPoint = this._particleBezierCurveNode._iEndPoint;
            }
            Object.defineProperty(ParticleBezierCurveState.prototype, "controlPoint", {
                get: /**
                * Defines the default control point of the node, used when in global mode.
                */
                function () {
                    return this._controlPoint;
                },
                set: function (value) {
                    this._controlPoint = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleBezierCurveState.prototype, "endPoint", {
                get: /**
                * Defines the default end point of the node, used when in global mode.
                */
                function () {
                    return this._endPoint;
                },
                set: function (value) {
                    this._endPoint = value;
                },
                enumerable: true,
                configurable: true
            });


            ParticleBezierCurveState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var controlIndex = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleBezierCurveNode.BEZIER_CONTROL_INDEX);
                var endIndex = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleBezierCurveNode.BEZIER_END_INDEX);

                if (this._particleBezierCurveNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                    animationSubGeometry.activateVertexBuffer(controlIndex, this._particleBezierCurveNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                    animationSubGeometry.activateVertexBuffer(endIndex, this._particleBezierCurveNode._iDataOffset + 3, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                } else {
                    animationRegisterCache.setVertexConst(controlIndex, this._controlPoint.x, this._controlPoint.y, this._controlPoint.z);
                    animationRegisterCache.setVertexConst(endIndex, this._endPoint.x, this._endPoint.y, this._endPoint.z);
                }
            };
            return ParticleBezierCurveState;
        })(animators.ParticleStateBase);
        animators.ParticleBezierCurveState = ParticleBezierCurveState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Matrix3D = away.geom.Matrix3D;
        var Orientation3D = away.geom.Orientation3D;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;
        var MathConsts = away.geom.MathConsts;

        /**
        * ...
        */
        var ParticleBillboardState = (function (_super) {
            __extends(ParticleBillboardState, _super);
            /**
            *
            */
            function ParticleBillboardState(animator, particleNode) {
                _super.call(this, animator, particleNode);
                this._matrix = new Matrix3D();

                this._billboardAxis = particleNode._iBillboardAxis;
            }
            ParticleBillboardState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var comps;
                if (this._billboardAxis) {
                    var pos = renderable.sourceEntity.sceneTransform.position;
                    var look = camera.sceneTransform.position.subtract(pos);
                    var right = look.crossProduct(this._billboardAxis);
                    right.normalize();
                    look = this.billboardAxis.crossProduct(right);
                    look.normalize();

                    //create a quick inverse projection matrix
                    this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
                    comps = this._matrix.decompose(Orientation3D.AXIS_ANGLE);
                    this._matrix.copyColumnFrom(0, right);
                    this._matrix.copyColumnFrom(1, this.billboardAxis);
                    this._matrix.copyColumnFrom(2, look);
                    this._matrix.copyColumnFrom(3, pos);
                    this._matrix.appendRotation(-comps[1].w * MathConsts.RADIANS_TO_DEGREES, comps[1]);
                } else {
                    //create a quick inverse projection matrix
                    this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
                    this._matrix.append(camera.inverseSceneTransform);

                    //decompose using axis angle rotations
                    comps = this._matrix.decompose(Orientation3D.AXIS_ANGLE);

                    //recreate the matrix with just the rotation data
                    this._matrix.identity();
                    this._matrix.appendRotation(-comps[1].w * MathConsts.RADIANS_TO_DEGREES, comps[1]);
                }

                //set a new matrix transform constant
                animationRegisterCache.setVertexConstFromMatrix(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleBillboardNode.MATRIX_INDEX), this._matrix);
            };

            Object.defineProperty(ParticleBillboardState.prototype, "billboardAxis", {
                get: /**
                * Defines the billboard axis.
                */
                function () {
                    return this.billboardAxis;
                },
                set: function (value) {
                    this.billboardAxis = value ? value.clone() : null;
                    if (this.billboardAxis)
                        this.billboardAxis.normalize();
                },
                enumerable: true,
                configurable: true
            });

            return ParticleBillboardState;
        })(animators.ParticleStateBase);
        animators.ParticleBillboardState = ParticleBillboardState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var ColorTransform = away.geom.ColorTransform;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        * @author ...
        */
        var ParticleColorState = (function (_super) {
            __extends(ParticleColorState, _super);
            function ParticleColorState(animator, particleColorNode) {
                _super.call(this, animator, particleColorNode);

                this._particleColorNode = particleColorNode;
                this._usesMultiplier = this._particleColorNode._iUsesMultiplier;
                this._usesOffset = this._particleColorNode._iUsesOffset;
                this._usesCycle = this._particleColorNode._iUsesCycle;
                this._usesPhase = this._particleColorNode._iUsesPhase;
                this._startColor = this._particleColorNode._iStartColor;
                this._endColor = this._particleColorNode._iEndColor;
                this._cycleDuration = this._particleColorNode._iCycleDuration;
                this._cyclePhase = this._particleColorNode._iCyclePhase;

                this.updateColorData();
            }
            Object.defineProperty(ParticleColorState.prototype, "startColor", {
                get: /**
                * Defines the start color transform of the state, when in global mode.
                */
                function () {
                    return this._startColor;
                },
                set: function (value) {
                    this._startColor = value;

                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleColorState.prototype, "endColor", {
                get: /**
                * Defines the end color transform of the state, when in global mode.
                */
                function () {
                    return this._endColor;
                },
                set: function (value) {
                    this._endColor = value;

                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleColorState.prototype, "cycleDuration", {
                get: /**
                * Defines the duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
                */
                function () {
                    return this._cycleDuration;
                },
                set: function (value) {
                    this._cycleDuration = value;

                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleColorState.prototype, "cyclePhase", {
                get: /**
                * Defines the phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
                */
                function () {
                    return this._cyclePhase;
                },
                set: function (value) {
                    this._cyclePhase = value;

                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            ParticleColorState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (animationRegisterCache.needFragmentAnimation) {
                    var dataOffset = this._particleColorNode._iDataOffset;
                    if (this._usesCycle)
                        animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.CYCLE_INDEX), this._cycleData.x, this._cycleData.y, this._cycleData.z, this._cycleData.w);

                    if (this._usesMultiplier) {
                        if (this._particleColorNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                            animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.START_MULTIPLIER_INDEX), dataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                            dataOffset += 4;
                            animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.DELTA_MULTIPLIER_INDEX), dataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                            dataOffset += 4;
                        } else {
                            animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.START_MULTIPLIER_INDEX), this._startMultiplierData.x, this._startMultiplierData.y, this._startMultiplierData.z, this._startMultiplierData.w);
                            animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.DELTA_MULTIPLIER_INDEX), this._deltaMultiplierData.x, this._deltaMultiplierData.y, this._deltaMultiplierData.z, this._deltaMultiplierData.w);
                        }
                    }
                    if (this._usesOffset) {
                        if (this._particleColorNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                            animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.START_OFFSET_INDEX), dataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                            dataOffset += 4;
                            animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.DELTA_OFFSET_INDEX), dataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                            dataOffset += 4;
                        } else {
                            animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.START_OFFSET_INDEX), this._startOffsetData.x, this._startOffsetData.y, this._startOffsetData.z, this._startOffsetData.w);
                            animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.DELTA_OFFSET_INDEX), this._deltaOffsetData.x, this._deltaOffsetData.y, this._deltaOffsetData.z, this._deltaOffsetData.w);
                        }
                    }
                }
            };

            ParticleColorState.prototype.updateColorData = function () {
                if (this._usesCycle) {
                    if (this._cycleDuration <= 0)
                        throw (new Error("the cycle duration must be greater than zero"));
                    this._cycleData = new Vector3D(Math.PI * 2 / this._cycleDuration, this._cyclePhase * Math.PI / 180, 0, 0);
                }
                if (this._particleColorNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    if (this._usesCycle) {
                        if (this._usesMultiplier) {
                            this._startMultiplierData = new Vector3D((this._startColor.redMultiplier + this._endColor.redMultiplier) / 2, (this._startColor.greenMultiplier + this._endColor.greenMultiplier) / 2, (this._startColor.blueMultiplier + this._endColor.blueMultiplier) / 2, (this._startColor.alphaMultiplier + this._endColor.alphaMultiplier) / 2);
                            this._deltaMultiplierData = new Vector3D((this._endColor.redMultiplier - this._startColor.redMultiplier) / 2, (this._endColor.greenMultiplier - this._startColor.greenMultiplier) / 2, (this._endColor.blueMultiplier - this._startColor.blueMultiplier) / 2, (this._endColor.alphaMultiplier - this._startColor.alphaMultiplier) / 2);
                        }

                        if (this._usesOffset) {
                            this._startOffsetData = new Vector3D((this._startColor.redOffset + this._endColor.redOffset) / (255 * 2), (this._startColor.greenOffset + this._endColor.greenOffset) / (255 * 2), (this._startColor.blueOffset + this._endColor.blueOffset) / (255 * 2), (this._startColor.alphaOffset + this._endColor.alphaOffset) / (255 * 2));
                            this._deltaOffsetData = new Vector3D((this._endColor.redOffset - this._startColor.redOffset) / (255 * 2), (this._endColor.greenOffset - this._startColor.greenOffset) / (255 * 2), (this._endColor.blueOffset - this._startColor.blueOffset) / (255 * 2), (this._endColor.alphaOffset - this._startColor.alphaOffset) / (255 * 2));
                        }
                    } else {
                        if (this._usesMultiplier) {
                            this._startMultiplierData = new Vector3D(this._startColor.redMultiplier, this._startColor.greenMultiplier, this._startColor.blueMultiplier, this._startColor.alphaMultiplier);
                            this._deltaMultiplierData = new Vector3D((this._endColor.redMultiplier - this._startColor.redMultiplier), (this._endColor.greenMultiplier - this._startColor.greenMultiplier), (this._endColor.blueMultiplier - this._startColor.blueMultiplier), (this._endColor.alphaMultiplier - this._startColor.alphaMultiplier));
                        }

                        if (this._usesOffset) {
                            this._startOffsetData = new Vector3D(this._startColor.redOffset / 255, this._startColor.greenOffset / 255, this._startColor.blueOffset / 255, this._startColor.alphaOffset / 255);
                            this._deltaOffsetData = new Vector3D((this._endColor.redOffset - this._startColor.redOffset) / 255, (this._endColor.greenOffset - this._startColor.greenOffset) / 255, (this._endColor.blueOffset - this._startColor.blueOffset) / 255, (this._endColor.alphaOffset - this._startColor.alphaOffset) / 255);
                        }
                    }
                }
            };
            return ParticleColorState;
        })(animators.ParticleStateBase);
        animators.ParticleColorState = ParticleColorState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var DisplayObject = away.base.DisplayObject;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;
        var MathConsts = away.geom.MathConsts;

        /**
        * ...
        */
        var ParticleFollowState = (function (_super) {
            __extends(ParticleFollowState, _super);
            function ParticleFollowState(animator, particleFollowNode) {
                _super.call(this, animator, particleFollowNode, true);
                this._targetPos = new Vector3D();
                this._targetEuler = new Vector3D();
                //temporary vector3D for calculation
                this._temp = new Vector3D();

                this._particleFollowNode = particleFollowNode;
                this._smooth = particleFollowNode._iSmooth;
            }
            Object.defineProperty(ParticleFollowState.prototype, "followTarget", {
                get: function () {
                    return this._followTarget;
                },
                set: function (value) {
                    this._followTarget = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleFollowState.prototype, "smooth", {
                get: function () {
                    return this._smooth;
                },
                set: function (value) {
                    this._smooth = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ParticleFollowState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (this._followTarget) {
                    if (this._particleFollowNode._iUsesPosition) {
                        this._targetPos.x = this._followTarget.transform.position.x / renderable.sourceEntity.scaleX;
                        this._targetPos.y = this._followTarget.transform.position.y / renderable.sourceEntity.scaleY;
                        this._targetPos.z = this._followTarget.transform.position.z / renderable.sourceEntity.scaleZ;
                    }
                    if (this._particleFollowNode._iUsesRotation) {
                        this._targetEuler.x = this._followTarget.rotationX;
                        this._targetEuler.y = this._followTarget.rotationY;
                        this._targetEuler.z = this._followTarget.rotationZ;
                        this._targetEuler.scaleBy(MathConsts.DEGREES_TO_RADIANS);
                    }
                }

                if (!this._prePos)
                    this._prePos = this._targetPos.clone();
                if (!this._preEuler)
                    this._preEuler = this._targetEuler.clone();

                var currentTime = this._pTime / 1000;
                var previousTime = animationSubGeometry.previousTime;
                var deltaTime = currentTime - previousTime;

                var needProcess = previousTime != currentTime;

                if (this._particleFollowNode._iUsesPosition && this._particleFollowNode._iUsesRotation) {
                    if (needProcess)
                        this.processPositionAndRotation(currentTime, deltaTime, animationSubGeometry);

                    animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleFollowNode.FOLLOW_POSITION_INDEX), this._particleFollowNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                    animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleFollowNode.FOLLOW_ROTATION_INDEX), this._particleFollowNode._iDataOffset + 3, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                } else if (this._particleFollowNode._iUsesPosition) {
                    if (needProcess)
                        this.processPosition(currentTime, deltaTime, animationSubGeometry);

                    animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleFollowNode.FOLLOW_POSITION_INDEX), this._particleFollowNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                } else if (this._particleFollowNode._iUsesRotation) {
                    if (needProcess)
                        this.precessRotation(currentTime, deltaTime, animationSubGeometry);

                    animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleFollowNode.FOLLOW_ROTATION_INDEX), this._particleFollowNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                }

                this._prePos.copyFrom(this._targetPos);
                this._targetEuler.copyFrom(this._targetEuler);
                animationSubGeometry.previousTime = currentTime;
            };

            ParticleFollowState.prototype.processPosition = function (currentTime, deltaTime, animationSubGeometry) {
                var data = animationSubGeometry.animationParticles;
                var vertexData = animationSubGeometry.vertexData;

                var changed = false;
                var len = data.length;
                var interpolatedPos;
                var posVelocity;
                if (this._smooth) {
                    posVelocity = this._prePos.subtract(this._targetPos);
                    posVelocity.scaleBy(1 / deltaTime);
                } else
                    interpolatedPos = this._targetPos;
                for (var i = 0; i < len; i++) {
                    var k = (currentTime - data[i].startTime) / data[i].totalTime;
                    var t = (k - Math.floor(k)) * data[i].totalTime;
                    if (t - deltaTime <= 0) {
                        var inc = data[i].startVertexIndex * animationSubGeometry.totalLenOfOneVertex + this._particleFollowNode._iDataOffset;

                        if (this._smooth) {
                            this._temp.copyFrom(posVelocity);
                            this._temp.scaleBy(t);
                            interpolatedPos = this._targetPos.add(this._temp);
                        }

                        if (vertexData[inc] != interpolatedPos.x || vertexData[inc + 1] != interpolatedPos.y || vertexData[inc + 2] != interpolatedPos.z) {
                            changed = true;
                            for (var j = 0; j < data[i].numVertices; j++) {
                                vertexData[inc++] = interpolatedPos.x;
                                vertexData[inc++] = interpolatedPos.y;
                                vertexData[inc++] = interpolatedPos.z;
                            }
                        }
                    }
                }
                if (changed)
                    animationSubGeometry.invalidateBuffer();
            };

            ParticleFollowState.prototype.precessRotation = function (currentTime, deltaTime, animationSubGeometry) {
                var data = animationSubGeometry.animationParticles;
                var vertexData = animationSubGeometry.vertexData;

                var changed = false;
                var len = data.length;

                var interpolatedRotation;
                var rotationVelocity;

                if (this._smooth) {
                    rotationVelocity = this._preEuler.subtract(this._targetEuler);
                    rotationVelocity.scaleBy(1 / deltaTime);
                } else
                    interpolatedRotation = this._targetEuler;

                for (var i = 0; i < len; i++) {
                    var k = (currentTime - data[i].startTime) / data[i].totalTime;
                    var t = (k - Math.floor(k)) * data[i].totalTime;
                    if (t - deltaTime <= 0) {
                        var inc = data[i].startVertexIndex * animationSubGeometry.totalLenOfOneVertex + this._particleFollowNode._iDataOffset;

                        if (this._smooth) {
                            this._temp.copyFrom(rotationVelocity);
                            this._temp.scaleBy(t);
                            interpolatedRotation = this._targetEuler.add(this._temp);
                        }

                        if (vertexData[inc] != interpolatedRotation.x || vertexData[inc + 1] != interpolatedRotation.y || vertexData[inc + 2] != interpolatedRotation.z) {
                            changed = true;
                            for (var j = 0; j < data[i].numVertices; j++) {
                                vertexData[inc++] = interpolatedRotation.x;
                                vertexData[inc++] = interpolatedRotation.y;
                                vertexData[inc++] = interpolatedRotation.z;
                            }
                        }
                    }
                }
                if (changed)
                    animationSubGeometry.invalidateBuffer();
            };

            ParticleFollowState.prototype.processPositionAndRotation = function (currentTime, deltaTime, animationSubGeometry) {
                var data = animationSubGeometry.animationParticles;
                var vertexData = animationSubGeometry.vertexData;

                var changed = false;
                var len = data.length;

                var interpolatedPos;
                var interpolatedRotation;

                var posVelocity;
                var rotationVelocity;
                if (this._smooth) {
                    posVelocity = this._prePos.subtract(this._targetPos);
                    posVelocity.scaleBy(1 / deltaTime);
                    rotationVelocity = this._preEuler.subtract(this._targetEuler);
                    rotationVelocity.scaleBy(1 / deltaTime);
                } else {
                    interpolatedPos = this._targetPos;
                    interpolatedRotation = this._targetEuler;
                }

                for (var i = 0; i < len; i++) {
                    var k = (currentTime - data[i].startTime) / data[i].totalTime;
                    var t = (k - Math.floor(k)) * data[i].totalTime;
                    if (t - deltaTime <= 0) {
                        var inc = data[i].startVertexIndex * animationSubGeometry.totalLenOfOneVertex + this._particleFollowNode._iDataOffset;
                        if (this._smooth) {
                            this._temp.copyFrom(posVelocity);
                            this._temp.scaleBy(t);
                            interpolatedPos = this._targetPos.add(this._temp);

                            this._temp.copyFrom(rotationVelocity);
                            this._temp.scaleBy(t);
                            interpolatedRotation = this._targetEuler.add(this._temp);
                        }

                        if (vertexData[inc] != interpolatedPos.x || vertexData[inc + 1] != interpolatedPos.y || vertexData[inc + 2] != interpolatedPos.z || vertexData[inc + 3] != interpolatedRotation.x || vertexData[inc + 4] != interpolatedRotation.y || vertexData[inc + 5] != interpolatedRotation.z) {
                            changed = true;
                            for (var j = 0; j < data[i].numVertices; j++) {
                                vertexData[inc++] = interpolatedPos.x;
                                vertexData[inc++] = interpolatedPos.y;
                                vertexData[inc++] = interpolatedPos.z;
                                vertexData[inc++] = interpolatedRotation.x;
                                vertexData[inc++] = interpolatedRotation.y;
                                vertexData[inc++] = interpolatedRotation.z;
                            }
                        }
                    }
                }
                if (changed)
                    animationSubGeometry.invalidateBuffer();
            };
            return ParticleFollowState;
        })(animators.ParticleStateBase);
        animators.ParticleFollowState = ParticleFollowState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var ColorTransform = away.geom.ColorTransform;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        var ParticleInitialColorState = (function (_super) {
            __extends(ParticleInitialColorState, _super);
            function ParticleInitialColorState(animator, particleInitialColorNode) {
                _super.call(this, animator, particleInitialColorNode);

                this._particleInitialColorNode = particleInitialColorNode;
                this._usesMultiplier = particleInitialColorNode._iUsesMultiplier;
                this._usesOffset = particleInitialColorNode._iUsesOffset;
                this._initialColor = particleInitialColorNode._iInitialColor;

                this.updateColorData();
            }
            Object.defineProperty(ParticleInitialColorState.prototype, "initialColor", {
                get: /**
                * Defines the initial color transform of the state, when in global mode.
                */
                function () {
                    return this._initialColor;
                },
                set: function (value) {
                    this._initialColor = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ParticleInitialColorState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                // TODO: not used
                renderable = renderable;
                camera = camera;

                if (animationRegisterCache.needFragmentAnimation) {
                    if (this._particleInitialColorNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                        var dataOffset = this._particleInitialColorNode._iDataOffset;
                        if (this._usesMultiplier) {
                            animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleInitialColorNode.MULTIPLIER_INDEX), dataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                            dataOffset += 4;
                        }
                        if (this._usesOffset)
                            animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleInitialColorNode.OFFSET_INDEX), dataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                    } else {
                        if (this._usesMultiplier)
                            animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleInitialColorNode.MULTIPLIER_INDEX), this._multiplierData.x, this._multiplierData.y, this._multiplierData.z, this._multiplierData.w);
                        if (this._usesOffset)
                            animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleInitialColorNode.OFFSET_INDEX), this._offsetData.x, this._offsetData.y, this._offsetData.z, this._offsetData.w);
                    }
                }
            };

            ParticleInitialColorState.prototype.updateColorData = function () {
                if (this._particleInitialColorNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    if (this._usesMultiplier)
                        this._multiplierData = new Vector3D(this._initialColor.redMultiplier, this._initialColor.greenMultiplier, this._initialColor.blueMultiplier, this._initialColor.alphaMultiplier);
                    if (this._usesOffset)
                        this._offsetData = new Vector3D(this._initialColor.redOffset / 255, this._initialColor.greenOffset / 255, this._initialColor.blueOffset / 255, this._initialColor.alphaOffset / 255);
                }
            };
            return ParticleInitialColorState;
        })(animators.ParticleStateBase);
        animators.ParticleInitialColorState = ParticleInitialColorState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Matrix3D = away.geom.Matrix3D;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        */
        var ParticleOrbitState = (function (_super) {
            __extends(ParticleOrbitState, _super);
            function ParticleOrbitState(animator, particleOrbitNode) {
                _super.call(this, animator, particleOrbitNode);

                this._particleOrbitNode = particleOrbitNode;
                this._usesEulers = this._particleOrbitNode._iUsesEulers;
                this._usesCycle = this._particleOrbitNode._iUsesCycle;
                this._usesPhase = this._particleOrbitNode._iUsesPhase;
                this._eulers = this._particleOrbitNode._iEulers;
                this._radius = this._particleOrbitNode._iRadius;
                this._cycleDuration = this._particleOrbitNode._iCycleDuration;
                this._cyclePhase = this._particleOrbitNode._iCyclePhase;
                this.updateOrbitData();
            }
            Object.defineProperty(ParticleOrbitState.prototype, "radius", {
                get: /**
                * Defines the radius of the orbit when in global mode. Defaults to 100.
                */
                function () {
                    return this._radius;
                },
                set: function (value) {
                    this._radius = value;

                    this.updateOrbitData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleOrbitState.prototype, "cycleDuration", {
                get: /**
                * Defines the duration of the orbit in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
                */
                function () {
                    return this._cycleDuration;
                },
                set: function (value) {
                    this._cycleDuration = value;

                    this.updateOrbitData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleOrbitState.prototype, "cyclePhase", {
                get: /**
                * Defines the phase of the orbit in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
                */
                function () {
                    return this._cyclePhase;
                },
                set: function (value) {
                    this._cyclePhase = value;

                    this.updateOrbitData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleOrbitState.prototype, "eulers", {
                get: /**
                * Defines the euler rotation in degrees, applied to the orientation of the orbit when in global mode.
                */
                function () {
                    return this._eulers;
                },
                set: function (value) {
                    this._eulers = value;

                    this.updateOrbitData();
                },
                enumerable: true,
                configurable: true
            });


            ParticleOrbitState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleOrbitNode.ORBIT_INDEX);

                if (this._particleOrbitNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                    if (this._usesPhase)
                        animationSubGeometry.activateVertexBuffer(index, this._particleOrbitNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
else
                        animationSubGeometry.activateVertexBuffer(index, this._particleOrbitNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                } else
                    animationRegisterCache.setVertexConst(index, this._orbitData.x, this._orbitData.y, this._orbitData.z, this._orbitData.w);

                if (this._usesEulers)
                    animationRegisterCache.setVertexConstFromMatrix(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleOrbitNode.EULERS_INDEX), this._eulersMatrix);
            };

            ParticleOrbitState.prototype.updateOrbitData = function () {
                if (this._usesEulers) {
                    this._eulersMatrix = new Matrix3D();
                    this._eulersMatrix.appendRotation(this._eulers.x, Vector3D.X_AXIS);
                    this._eulersMatrix.appendRotation(this._eulers.y, Vector3D.Y_AXIS);
                    this._eulersMatrix.appendRotation(this._eulers.z, Vector3D.Z_AXIS);
                }
                if (this._particleOrbitNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    this._orbitData = new Vector3D(this._radius, 0, this._radius * Math.PI * 2, this._cyclePhase * Math.PI / 180);
                    if (this._usesCycle) {
                        if (this._cycleDuration <= 0)
                            throw (new Error("the cycle duration must be greater than zero"));
                        this._orbitData.y = Math.PI * 2 / this._cycleDuration;
                    } else
                        this._orbitData.y = Math.PI * 2;
                }
            };
            return ParticleOrbitState;
        })(animators.ParticleStateBase);
        animators.ParticleOrbitState = ParticleOrbitState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        */
        var ParticleOscillatorState = (function (_super) {
            __extends(ParticleOscillatorState, _super);
            function ParticleOscillatorState(animator, particleOscillatorNode) {
                _super.call(this, animator, particleOscillatorNode);

                this._particleOscillatorNode = particleOscillatorNode;
                this._oscillator = this._particleOscillatorNode._iOscillator;

                this.updateOscillatorData();
            }
            Object.defineProperty(ParticleOscillatorState.prototype, "oscillator", {
                get: /**
                * Defines the default oscillator axis (x, y, z) and cycleDuration (w) of the state, used when in global mode.
                */
                function () {
                    return this._oscillator;
                },
                set: function (value) {
                    this._oscillator = value;

                    this.updateOscillatorData();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ParticleOscillatorState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleOscillatorNode.OSCILLATOR_INDEX);

                if (this._particleOscillatorNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC)
                    animationSubGeometry.activateVertexBuffer(index, this._particleOscillatorNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
else
                    animationRegisterCache.setVertexConst(index, this._oscillatorData.x, this._oscillatorData.y, this._oscillatorData.z, this._oscillatorData.w);
            };

            ParticleOscillatorState.prototype.updateOscillatorData = function () {
                if (this._particleOscillatorNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    if (this._oscillator.w <= 0)
                        throw (new Error("the cycle duration must greater than zero"));

                    if (this._oscillatorData == null)
                        this._oscillatorData = new Vector3D();

                    this._oscillatorData.x = this._oscillator.x;
                    this._oscillatorData.y = this._oscillator.y;
                    this._oscillatorData.z = this._oscillator.z;
                    this._oscillatorData.w = Math.PI * 2 / this._oscillator.w;
                }
            };
            return ParticleOscillatorState;
        })(animators.ParticleStateBase);
        animators.ParticleOscillatorState = ParticleOscillatorState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        * @author ...
        */
        var ParticlePositionState = (function (_super) {
            __extends(ParticlePositionState, _super);
            function ParticlePositionState(animator, particlePositionNode) {
                _super.call(this, animator, particlePositionNode);

                this._particlePositionNode = particlePositionNode;
                this._position = this._particlePositionNode._iPosition;
            }
            Object.defineProperty(ParticlePositionState.prototype, "position", {
                get: /**
                * Defines the position of the particle when in global mode. Defaults to 0,0,0.
                */
                function () {
                    return this._position;
                },
                set: function (value) {
                    this._position = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            *
            */
            ParticlePositionState.prototype.getPositions = function () {
                return this._pDynamicProperties;
            };

            ParticlePositionState.prototype.setPositions = function (value) {
                this._pDynamicProperties = value;

                this._pDynamicPropertiesDirty = new Object();
            };

            /**
            * @inheritDoc
            */
            ParticlePositionState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (this._particlePositionNode.mode == animators.ParticlePropertiesMode.LOCAL_DYNAMIC && !this._pDynamicPropertiesDirty[animationSubGeometry._iUniqueId])
                    this._pUpdateDynamicProperties(animationSubGeometry);

                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticlePositionNode.POSITION_INDEX);

                if (this._particlePositionNode.mode == animators.ParticlePropertiesMode.GLOBAL)
                    animationRegisterCache.setVertexConst(index, this._position.x, this._position.y, this._position.z);
else
                    animationSubGeometry.activateVertexBuffer(index, this._particlePositionNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
            };
            return ParticlePositionState;
        })(animators.ParticleStateBase);
        animators.ParticlePositionState = ParticlePositionState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var Matrix3D = away.geom.Matrix3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        */
        var ParticleRotateToHeadingState = (function (_super) {
            __extends(ParticleRotateToHeadingState, _super);
            function ParticleRotateToHeadingState(animator, particleNode) {
                _super.call(this, animator, particleNode);
                this._matrix = new Matrix3D();
            }
            ParticleRotateToHeadingState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (animationRegisterCache.hasBillboard) {
                    this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
                    this._matrix.append(camera.inverseSceneTransform);
                    animationRegisterCache.setVertexConstFromMatrix(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleRotateToHeadingNode.MATRIX_INDEX), this._matrix);
                }
            };
            return ParticleRotateToHeadingState;
        })(animators.ParticleStateBase);
        animators.ParticleRotateToHeadingState = ParticleRotateToHeadingState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var Matrix3D = away.geom.Matrix3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        */
        var ParticleRotateToPositionState = (function (_super) {
            __extends(ParticleRotateToPositionState, _super);
            function ParticleRotateToPositionState(animator, particleRotateToPositionNode) {
                _super.call(this, animator, particleRotateToPositionNode);
                this._matrix = new Matrix3D();

                this._particleRotateToPositionNode = particleRotateToPositionNode;
                this._position = this._particleRotateToPositionNode._iPosition;
            }
            Object.defineProperty(ParticleRotateToPositionState.prototype, "position", {
                get: /**
                * Defines the position of the point the particle will rotate to face when in global mode. Defaults to 0,0,0.
                */
                function () {
                    return this._position;
                },
                set: function (value) {
                    this._position = value;
                },
                enumerable: true,
                configurable: true
            });


            ParticleRotateToPositionState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleRotateToPositionNode.POSITION_INDEX);

                if (animationRegisterCache.hasBillboard) {
                    this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
                    this._matrix.append(camera.inverseSceneTransform);
                    animationRegisterCache.setVertexConstFromMatrix(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleRotateToPositionNode.MATRIX_INDEX), this._matrix);
                }

                if (this._particleRotateToPositionNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    this._offset = renderable.sourceEntity.inverseSceneTransform.transformVector(this._position);
                    animationRegisterCache.setVertexConst(index, this._offset.x, this._offset.y, this._offset.z);
                } else
                    animationSubGeometry.activateVertexBuffer(index, this._particleRotateToPositionNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
            };
            return ParticleRotateToPositionState;
        })(animators.ParticleStateBase);
        animators.ParticleRotateToPositionState = ParticleRotateToPositionState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        */
        var ParticleRotationalVelocityState = (function (_super) {
            __extends(ParticleRotationalVelocityState, _super);
            function ParticleRotationalVelocityState(animator, particleRotationNode) {
                _super.call(this, animator, particleRotationNode);

                this._particleRotationalVelocityNode = particleRotationNode;
                this._rotationalVelocity = this._particleRotationalVelocityNode._iRotationalVelocity;

                this.updateRotationalVelocityData();
            }
            Object.defineProperty(ParticleRotationalVelocityState.prototype, "rotationalVelocity", {
                get: /**
                * Defines the default rotationalVelocity of the state, used when in global mode.
                */
                function () {
                    return this._rotationalVelocity;
                },
                set: function (value) {
                    this._rotationalVelocity = value;

                    this.updateRotationalVelocityData();
                },
                enumerable: true,
                configurable: true
            });


            /**
            *
            */
            ParticleRotationalVelocityState.prototype.getRotationalVelocities = function () {
                return this._pDynamicProperties;
            };

            ParticleRotationalVelocityState.prototype.setRotationalVelocities = function (value) {
                this._pDynamicProperties = value;

                this._pDynamicPropertiesDirty = new Object();
            };

            /**
            * @inheritDoc
            */
            ParticleRotationalVelocityState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (this._particleRotationalVelocityNode.mode == animators.ParticlePropertiesMode.LOCAL_DYNAMIC && !this._pDynamicPropertiesDirty[animationSubGeometry._iUniqueId])
                    this._pUpdateDynamicProperties(animationSubGeometry);

                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleRotationalVelocityNode.ROTATIONALVELOCITY_INDEX);

                if (this._particleRotationalVelocityNode.mode == animators.ParticlePropertiesMode.GLOBAL)
                    animationRegisterCache.setVertexConst(index, this._rotationalVelocityData.x, this._rotationalVelocityData.y, this._rotationalVelocityData.z, this._rotationalVelocityData.w);
else
                    animationSubGeometry.activateVertexBuffer(index, this._particleRotationalVelocityNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
            };

            ParticleRotationalVelocityState.prototype.updateRotationalVelocityData = function () {
                if (this._particleRotationalVelocityNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    if (this._rotationalVelocity.w <= 0)
                        throw (new Error("the cycle duration must greater than zero"));
                    var rotation = this._rotationalVelocity.clone();

                    if (rotation.length <= 0)
                        rotation.z = 1;
else
                        rotation.normalize();

                    // w is used as angle/2 in agal
                    this._rotationalVelocityData = new Vector3D(rotation.x, rotation.y, rotation.z, Math.PI / rotation.w);
                }
            };
            return ParticleRotationalVelocityState;
        })(animators.ParticleStateBase);
        animators.ParticleRotationalVelocityState = ParticleRotationalVelocityState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        */
        var ParticleScaleState = (function (_super) {
            __extends(ParticleScaleState, _super);
            function ParticleScaleState(animator, particleScaleNode) {
                _super.call(this, animator, particleScaleNode);

                this._particleScaleNode = particleScaleNode;
                this._usesCycle = this._particleScaleNode._iUsesCycle;
                this._usesPhase = this._particleScaleNode._iUsesPhase;
                this._minScale = this._particleScaleNode._iMinScale;
                this._maxScale = this._particleScaleNode._iMaxScale;
                this._cycleDuration = this._particleScaleNode._iCycleDuration;
                this._cyclePhase = this._particleScaleNode._iCyclePhase;

                this.updateScaleData();
            }
            Object.defineProperty(ParticleScaleState.prototype, "minScale", {
                get: /**
                * Defines the end scale of the state, when in global mode. Defaults to 1.
                */
                function () {
                    return this._minScale;
                },
                set: function (value) {
                    this._minScale = value;

                    this.updateScaleData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleScaleState.prototype, "maxScale", {
                get: /**
                * Defines the end scale of the state, when in global mode. Defaults to 1.
                */
                function () {
                    return this._maxScale;
                },
                set: function (value) {
                    this._maxScale = value;

                    this.updateScaleData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleScaleState.prototype, "cycleDuration", {
                get: /**
                * Defines the duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
                */
                function () {
                    return this._cycleDuration;
                },
                set: function (value) {
                    this._cycleDuration = value;

                    this.updateScaleData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleScaleState.prototype, "cyclePhase", {
                get: /**
                * Defines the phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
                */
                function () {
                    return this._cyclePhase;
                },
                set: function (value) {
                    this._cyclePhase = value;

                    this.updateScaleData();
                },
                enumerable: true,
                configurable: true
            });


            ParticleScaleState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleScaleNode.SCALE_INDEX);

                if (this._particleScaleNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                    if (this._usesCycle) {
                        if (this._usesPhase)
                            animationSubGeometry.activateVertexBuffer(index, this._particleScaleNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
else
                            animationSubGeometry.activateVertexBuffer(index, this._particleScaleNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                    } else
                        animationSubGeometry.activateVertexBuffer(index, this._particleScaleNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_2);
                } else
                    animationRegisterCache.setVertexConst(index, this._scaleData.x, this._scaleData.y, this._scaleData.z, this._scaleData.w);
            };

            ParticleScaleState.prototype.updateScaleData = function () {
                if (this._particleScaleNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    if (this._usesCycle) {
                        if (this._cycleDuration <= 0)
                            throw (new Error("the cycle duration must be greater than zero"));
                        this._scaleData = new Vector3D((this._minScale + this._maxScale) / 2, Math.abs(this._minScale - this._maxScale) / 2, Math.PI * 2 / this._cycleDuration, this._cyclePhase * Math.PI / 180);
                    } else
                        this._scaleData = new Vector3D(this._minScale, this._maxScale - this._minScale, 0, 0);
                }
            };
            return ParticleScaleState;
        })(animators.ParticleStateBase);
        animators.ParticleScaleState = ParticleScaleState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var ColorTransform = away.geom.ColorTransform;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        var ParticleSegmentedColorState = (function (_super) {
            __extends(ParticleSegmentedColorState, _super);
            function ParticleSegmentedColorState(animator, particleSegmentedColorNode) {
                _super.call(this, animator, particleSegmentedColorNode);

                this._usesMultiplier = particleSegmentedColorNode._iUsesMultiplier;
                this._usesOffset = particleSegmentedColorNode._iUsesOffset;
                this._startColor = particleSegmentedColorNode._iStartColor;
                this._endColor = particleSegmentedColorNode._iEndColor;
                this._segmentPoints = particleSegmentedColorNode._iSegmentPoints;
                this._numSegmentPoint = particleSegmentedColorNode._iNumSegmentPoint;
                this.updateColorData();
            }
            Object.defineProperty(ParticleSegmentedColorState.prototype, "startColor", {
                get: /**
                * Defines the start color transform of the state, when in global mode.
                */
                function () {
                    return this._startColor;
                },
                set: function (value) {
                    this._startColor = value;

                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleSegmentedColorState.prototype, "endColor", {
                get: /**
                * Defines the end color transform of the state, when in global mode.
                */
                function () {
                    return this._endColor;
                },
                set: function (value) {
                    this._endColor = value;
                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleSegmentedColorState.prototype, "numSegmentPoint", {
                get: /**
                * Defines the number of segments.
                */
                function () {
                    return this._numSegmentPoint;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleSegmentedColorState.prototype, "segmentPoints", {
                get: /**
                * Defines the key points of color
                */
                function () {
                    return this._segmentPoints;
                },
                set: function (value) {
                    this._segmentPoints = value;
                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleSegmentedColorState.prototype, "usesMultiplier", {
                get: function () {
                    return this._usesMultiplier;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleSegmentedColorState.prototype, "usesOffset", {
                get: function () {
                    return this._usesOffset;
                },
                enumerable: true,
                configurable: true
            });

            ParticleSegmentedColorState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (animationRegisterCache.needFragmentAnimation) {
                    if (this._numSegmentPoint > 0)
                        animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleSegmentedColorNode.TIME_DATA_INDEX), this._timeLifeData[0], this._timeLifeData[1], this._timeLifeData[2], this._timeLifeData[3]);
                    if (this._usesMultiplier)
                        animationRegisterCache.setVertexConstFromArray(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleSegmentedColorNode.START_MULTIPLIER_INDEX), this._multiplierData);
                    if (this._usesOffset)
                        animationRegisterCache.setVertexConstFromArray(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleSegmentedColorNode.START_OFFSET_INDEX), this._offsetData);
                }
            };

            ParticleSegmentedColorState.prototype.updateColorData = function () {
                this._timeLifeData = new Array();
                this._multiplierData = new Array();
                this._offsetData = new Array();
                var i/*int*/ ;
                for (i = 0; i < this._numSegmentPoint; i++) {
                    if (i == 0)
                        this._timeLifeData.push(this._segmentPoints[i].life);
else
                        this._timeLifeData.push(this._segmentPoints[i].life - this._segmentPoints[i - 1].life);
                }
                if (this._numSegmentPoint == 0)
                    this._timeLifeData.push(1);
else
                    this._timeLifeData.push(1 - this._segmentPoints[i - 1].life);

                if (this._usesMultiplier) {
                    this._multiplierData.push(this._startColor.redMultiplier, this._startColor.greenMultiplier, this._startColor.blueMultiplier, this._startColor.alphaMultiplier);
                    for (i = 0; i < this._numSegmentPoint; i++) {
                        if (i == 0)
                            this._multiplierData.push((this._segmentPoints[i].color.redMultiplier - this._startColor.redMultiplier) / this._timeLifeData[i], (this._segmentPoints[i].color.greenMultiplier - this._startColor.greenMultiplier) / this._timeLifeData[i], (this._segmentPoints[i].color.blueMultiplier - this._startColor.blueMultiplier) / this._timeLifeData[i], (this._segmentPoints[i].color.alphaMultiplier - this._startColor.alphaMultiplier) / this._timeLifeData[i]);
else
                            this._multiplierData.push((this._segmentPoints[i].color.redMultiplier - this._segmentPoints[i - 1].color.redMultiplier) / this._timeLifeData[i], (this._segmentPoints[i].color.greenMultiplier - this._segmentPoints[i - 1].color.greenMultiplier) / this._timeLifeData[i], (this._segmentPoints[i].color.blueMultiplier - this._segmentPoints[i - 1].color.blueMultiplier) / this._timeLifeData[i], (this._segmentPoints[i].color.alphaMultiplier - this._segmentPoints[i - 1].color.alphaMultiplier) / this._timeLifeData[i]);
                    }
                    if (this._numSegmentPoint == 0)
                        this._multiplierData.push(this._endColor.redMultiplier - this._startColor.redMultiplier, this._endColor.greenMultiplier - this._startColor.greenMultiplier, this._endColor.blueMultiplier - this._startColor.blueMultiplier, this._endColor.alphaMultiplier - this._startColor.alphaMultiplier);
else
                        this._multiplierData.push((this._endColor.redMultiplier - this._segmentPoints[i - 1].color.redMultiplier) / this._timeLifeData[i], (this._endColor.greenMultiplier - this._segmentPoints[i - 1].color.greenMultiplier) / this._timeLifeData[i], (this._endColor.blueMultiplier - this._segmentPoints[i - 1].color.blueMultiplier) / this._timeLifeData[i], (this._endColor.alphaMultiplier - this._segmentPoints[i - 1].color.alphaMultiplier) / this._timeLifeData[i]);
                }

                if (this._usesOffset) {
                    this._offsetData.push(this._startColor.redOffset / 255, this._startColor.greenOffset / 255, this._startColor.blueOffset / 255, this._startColor.alphaOffset / 255);
                    for (i = 0; i < this._numSegmentPoint; i++) {
                        if (i == 0)
                            this._offsetData.push((this._segmentPoints[i].color.redOffset - this._startColor.redOffset) / this._timeLifeData[i] / 255, (this._segmentPoints[i].color.greenOffset - this._startColor.greenOffset) / this._timeLifeData[i] / 255, (this._segmentPoints[i].color.blueOffset - this._startColor.blueOffset) / this._timeLifeData[i] / 255, (this._segmentPoints[i].color.alphaOffset - this._startColor.alphaOffset) / this._timeLifeData[i] / 255);
else
                            this._offsetData.push((this._segmentPoints[i].color.redOffset - this._segmentPoints[i - 1].color.redOffset) / this._timeLifeData[i] / 255, (this._segmentPoints[i].color.greenOffset - this._segmentPoints[i - 1].color.greenOffset) / this._timeLifeData[i] / 255, (this._segmentPoints[i].color.blueOffset - this._segmentPoints[i - 1].color.blueOffset) / this._timeLifeData[i] / 255, (this._segmentPoints[i].color.alphaOffset - this._segmentPoints[i - 1].color.alphaOffset) / this._timeLifeData[i] / 255);
                    }
                    if (this._numSegmentPoint == 0)
                        this._offsetData.push((this._endColor.redOffset - this._startColor.redOffset) / 255, (this._endColor.greenOffset - this._startColor.greenOffset) / 255, (this._endColor.blueOffset - this._startColor.blueOffset) / 255, (this._endColor.alphaOffset - this._startColor.alphaOffset) / 255);
else
                        this._offsetData.push((this._endColor.redOffset - this._segmentPoints[i - 1].color.redOffset) / this._timeLifeData[i] / 255, (this._endColor.greenOffset - this._segmentPoints[i - 1].color.greenOffset) / this._timeLifeData[i] / 255, (this._endColor.blueOffset - this._segmentPoints[i - 1].color.blueOffset) / this._timeLifeData[i] / 255, (this._endColor.alphaOffset - this._segmentPoints[i - 1].color.alphaOffset) / this._timeLifeData[i] / 255);
                }

                //cut off the data
                this._timeLifeData.length = 4;
            };
            return ParticleSegmentedColorState;
        })(animators.ParticleStateBase);
        animators.ParticleSegmentedColorState = ParticleSegmentedColorState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        */
        var ParticleSpriteSheetState = (function (_super) {
            __extends(ParticleSpriteSheetState, _super);
            function ParticleSpriteSheetState(animator, particleSpriteSheetNode) {
                _super.call(this, animator, particleSpriteSheetNode);

                this._particleSpriteSheetNode = particleSpriteSheetNode;

                this._usesCycle = this._particleSpriteSheetNode._iUsesCycle;
                this._usesPhase = this._particleSpriteSheetNode._iUsesCycle;
                this._totalFrames = this._particleSpriteSheetNode._iTotalFrames;
                this._numColumns = this._particleSpriteSheetNode._iNumColumns;
                this._numRows = this._particleSpriteSheetNode._iNumRows;
                this._cycleDuration = this._particleSpriteSheetNode._iCycleDuration;
                this._cyclePhase = this._particleSpriteSheetNode._iCyclePhase;

                this.updateSpriteSheetData();
            }
            Object.defineProperty(ParticleSpriteSheetState.prototype, "cyclePhase", {
                get: /**
                * Defines the cycle phase, when in global mode. Defaults to zero.
                */
                function () {
                    return this._cyclePhase;
                },
                set: function (value) {
                    this._cyclePhase = value;

                    this.updateSpriteSheetData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleSpriteSheetState.prototype, "cycleDuration", {
                get: /**
                * Defines the cycle duration in seconds, when in global mode. Defaults to 1.
                */
                function () {
                    return this._cycleDuration;
                },
                set: function (value) {
                    this._cycleDuration = value;

                    this.updateSpriteSheetData();
                },
                enumerable: true,
                configurable: true
            });


            ParticleSpriteSheetState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (animationRegisterCache.needUVAnimation) {
                    animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleSpriteSheetNode.UV_INDEX_0), this._spriteSheetData[0], this._spriteSheetData[1], this._spriteSheetData[2], this._spriteSheetData[3]);
                    if (this._usesCycle) {
                        var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleSpriteSheetNode.UV_INDEX_1);
                        if (this._particleSpriteSheetNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                            if (this._usesPhase)
                                animationSubGeometry.activateVertexBuffer(index, this._particleSpriteSheetNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
else
                                animationSubGeometry.activateVertexBuffer(index, this._particleSpriteSheetNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_2);
                        } else
                            animationRegisterCache.setVertexConst(index, this._spriteSheetData[4], this._spriteSheetData[5]);
                    }
                }
            };

            ParticleSpriteSheetState.prototype.updateSpriteSheetData = function () {
                this._spriteSheetData = new Array(8);

                var uTotal = this._totalFrames / this._numColumns;

                this._spriteSheetData[0] = uTotal;
                this._spriteSheetData[1] = 1 / this._numColumns;
                this._spriteSheetData[2] = 1 / this._numRows;

                if (this._usesCycle) {
                    if (this._cycleDuration <= 0)
                        throw (new Error("the cycle duration must be greater than zero"));
                    this._spriteSheetData[4] = uTotal / this._cycleDuration;
                    this._spriteSheetData[5] = this._cycleDuration;
                    if (this._usesPhase)
                        this._spriteSheetData[6] = this._cyclePhase;
                }
            };
            return ParticleSpriteSheetState;
        })(animators.ParticleStateBase);
        animators.ParticleSpriteSheetState = ParticleSpriteSheetState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        */
        var ParticleTimeState = (function (_super) {
            __extends(ParticleTimeState, _super);
            function ParticleTimeState(animator, particleTimeNode) {
                _super.call(this, animator, particleTimeNode, true);

                this._particleTimeNode = particleTimeNode;
            }
            ParticleTimeState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleTimeNode.TIME_STREAM_INDEX), this._particleTimeNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);

                var particleTime = this._pTime / 1000;
                animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleTimeNode.TIME_CONSTANT_INDEX), particleTime, particleTime, particleTime, particleTime);
            };
            return ParticleTimeState;
        })(animators.ParticleStateBase);
        animators.ParticleTimeState = ParticleTimeState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        */
        var ParticleUVState = (function (_super) {
            __extends(ParticleUVState, _super);
            function ParticleUVState(animator, particleUVNode) {
                _super.call(this, animator, particleUVNode);

                this._particleUVNode = particleUVNode;
            }
            ParticleUVState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (animationRegisterCache.needUVAnimation) {
                    var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleUVNode.UV_INDEX);
                    var data = this._particleUVNode._iUvData;
                    animationRegisterCache.setVertexConst(index, data.x, data.y);
                }
            };
            return ParticleUVState;
        })(animators.ParticleStateBase);
        animators.ParticleUVState = ParticleUVState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var RenderableBase = away.pool.RenderableBase;
        var Camera = away.entities.Camera;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;
        var StageGL = away.base.StageGL;

        /**
        * ...
        */
        var ParticleVelocityState = (function (_super) {
            __extends(ParticleVelocityState, _super);
            function ParticleVelocityState(animator, particleVelocityNode) {
                _super.call(this, animator, particleVelocityNode);

                this._particleVelocityNode = particleVelocityNode;
                this._velocity = this._particleVelocityNode._iVelocity;
            }
            Object.defineProperty(ParticleVelocityState.prototype, "velocity", {
                get: /**
                * Defines the default velocity vector of the state, used when in global mode.
                */
                function () {
                    return this._velocity;
                },
                set: function (value) {
                    this._velocity = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            *
            */
            ParticleVelocityState.prototype.getVelocities = function () {
                return this._pDynamicProperties;
            };

            ParticleVelocityState.prototype.setVelocities = function (value) {
                this._pDynamicProperties = value;

                this._pDynamicPropertiesDirty = new Object();
            };

            ParticleVelocityState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (this._particleVelocityNode.mode == animators.ParticlePropertiesMode.LOCAL_DYNAMIC && !this._pDynamicPropertiesDirty[animationSubGeometry._iUniqueId])
                    this._pUpdateDynamicProperties(animationSubGeometry);

                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleVelocityNode.VELOCITY_INDEX);

                if (this._particleVelocityNode.mode == animators.ParticlePropertiesMode.GLOBAL)
                    animationRegisterCache.setVertexConst(index, this._velocity.x, this._velocity.y, this._velocity.z);
else
                    animationSubGeometry.activateVertexBuffer(index, this._particleVelocityNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
            };
            return ParticleVelocityState;
        })(animators.ParticleStateBase);
        animators.ParticleVelocityState = ParticleVelocityState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        *
        */
        var AnimationClipState = (function (_super) {
            __extends(AnimationClipState, _super);
            function AnimationClipState(animator, animationClipNode) {
                _super.call(this, animator, animationClipNode);
                this._pFramesDirty = true;

                this._animationClipNode = animationClipNode;
            }
            Object.defineProperty(AnimationClipState.prototype, "blendWeight", {
                get: /**
                * Returns a fractional value between 0 and 1 representing the blending ratio of the current playhead position
                * between the current frame (0) and next frame (1) of the animation.
                *
                * @see #currentFrame
                * @see #nextFrame
                */
                function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._pBlendWeight;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipState.prototype, "currentFrame", {
                get: /**
                * Returns the current frame of animation in the clip based on the internal playhead position.
                */
                function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._pCurrentFrame;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipState.prototype, "nextFrame", {
                get: /**
                * Returns the next frame of animation in the clip based on the internal playhead position.
                */
                function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._pNextFrame;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            AnimationClipState.prototype.update = function (time/*int*/ ) {
                if (!this._animationClipNode.looping) {
                    if (time > this._pStartTime + this._animationClipNode.totalDuration)
                        time = this._pStartTime + this._animationClipNode.totalDuration;
else if (time < this._pStartTime)
                        time = this._pStartTime;
                }

                if (this._pTime == time - this._pStartTime)
                    return;

                this._pUpdateTime(time);
            };

            /**
            * @inheritDoc
            */
            AnimationClipState.prototype.phase = function (value) {
                var time = value * this._animationClipNode.totalDuration + this._pStartTime;

                if (this._pTime == time - this._pStartTime)
                    return;

                this._pUpdateTime(time);
            };

            /**
            * @inheritDoc
            */
            AnimationClipState.prototype._pUpdateTime = function (time/*int*/ ) {
                this._pFramesDirty = true;

                this._pTimeDir = (time - this._pStartTime > this._pTime) ? 1 : -1;

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * Updates the nodes internal playhead to determine the current and next animation frame, and the blendWeight between the two.
            *
            * @see #currentFrame
            * @see #nextFrame
            * @see #blendWeight
            */
            AnimationClipState.prototype._pUpdateFrames = function () {
                this._pFramesDirty = false;

                var looping = this._animationClipNode.looping;
                var totalDuration = this._animationClipNode.totalDuration;
                var lastFrame = this._animationClipNode.lastFrame;
                var time = this._pTime;

                if (looping && (time >= totalDuration || time < 0)) {
                    time %= totalDuration;
                    if (time < 0)
                        time += totalDuration;
                }

                if (!looping && time >= totalDuration) {
                    this.notifyPlaybackComplete();
                    this._pCurrentFrame = lastFrame;
                    this._pNextFrame = lastFrame;
                    this._pBlendWeight = 0;
                } else if (!looping && time <= 0) {
                    this._pCurrentFrame = 0;
                    this._pNextFrame = 0;
                    this._pBlendWeight = 0;
                } else if (this._animationClipNode.fixedFrameRate) {
                    var t = time / totalDuration * lastFrame;
                    this._pCurrentFrame = Math.floor(t);
                    this._pBlendWeight = t - this._pCurrentFrame;
                    this._pNextFrame = this._pCurrentFrame + 1;
                } else {
                    this._pCurrentFrame = 0;
                    this._pNextFrame = 0;

                    var dur = 0/*uint*/ , frameTime;
                    var durations = this._animationClipNode.durations;

                    do {
                        frameTime = dur;
                        dur += durations[this._pNextFrame];
                        this._pCurrentFrame = this._pNextFrame++;
                    } while(time > dur);

                    if (this._pCurrentFrame == lastFrame) {
                        this._pCurrentFrame = 0;
                        this._pNextFrame = 1;
                    }

                    this._pBlendWeight = (time - frameTime) / durations[this._pCurrentFrame];
                }
            };

            AnimationClipState.prototype.notifyPlaybackComplete = function () {
                if (this._animationStatePlaybackComplete == null)
                    this._animationStatePlaybackComplete = new away.events.AnimationStateEvent(away.events.AnimationStateEvent.PLAYBACK_COMPLETE, this._pAnimator, this, this._animationClipNode);

                this._animationClipNode.dispatchEvent(this._animationStatePlaybackComplete);
            };
            return AnimationClipState;
        })(animators.AnimationStateBase);
        animators.AnimationClipState = AnimationClipState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        /**
        *
        */
        var SkeletonBinaryLERPState = (function (_super) {
            __extends(SkeletonBinaryLERPState, _super);
            function SkeletonBinaryLERPState(animator, skeletonAnimationNode) {
                _super.call(this, animator, skeletonAnimationNode);
                this._blendWeight = 0;
                this._skeletonPose = new animators.SkeletonPose();
                this._skeletonPoseDirty = true;

                this._skeletonAnimationNode = skeletonAnimationNode;

                this._inputA = animator.getAnimationState(this._skeletonAnimationNode.inputA);
                this._inputB = animator.getAnimationState(this._skeletonAnimationNode.inputB);
            }
            Object.defineProperty(SkeletonBinaryLERPState.prototype, "blendWeight", {
                get: /**
                * Defines a fractional value between 0 and 1 representing the blending ratio between inputA (0) and inputB (1),
                * used to produce the skeleton pose output.
                *
                * @see inputA
                * @see inputB
                */
                function () {
                    return this._blendWeight;
                },
                set: function (value) {
                    this._blendWeight = value;

                    this._pPositionDeltaDirty = true;
                    this._skeletonPoseDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SkeletonBinaryLERPState.prototype.phase = function (value) {
                this._skeletonPoseDirty = true;

                this._pPositionDeltaDirty = true;

                this._inputA.phase(value);
                this._inputB.phase(value);
            };

            /**
            * @inheritDoc
            */
            SkeletonBinaryLERPState.prototype._pUpdateTime = function (time/*int*/ ) {
                this._skeletonPoseDirty = true;

                this._inputA.update(time);
                this._inputB.update(time);

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
            */
            SkeletonBinaryLERPState.prototype.getSkeletonPose = function (skeleton) {
                if (this._skeletonPoseDirty)
                    this.updateSkeletonPose(skeleton);

                return this._skeletonPose;
            };

            /**
            * @inheritDoc
            */
            SkeletonBinaryLERPState.prototype._pUpdatePositionDelta = function () {
                this._pPositionDeltaDirty = false;

                var deltA = this._inputA.positionDelta;
                var deltB = this._inputB.positionDelta;

                this._pRootDelta.x = deltA.x + this._blendWeight * (deltB.x - deltA.x);
                this._pRootDelta.y = deltA.y + this._blendWeight * (deltB.y - deltA.y);
                this._pRootDelta.z = deltA.z + this._blendWeight * (deltB.z - deltA.z);
            };

            /**
            * Updates the output skeleton pose of the node based on the blendWeight value between input nodes.
            *
            * @param skeleton The skeleton used by the animator requesting the ouput pose.
            */
            SkeletonBinaryLERPState.prototype.updateSkeletonPose = function (skeleton) {
                this._skeletonPoseDirty = false;

                var endPose;
                var endPoses = this._skeletonPose.jointPoses;
                var poses1 = this._inputA.getSkeletonPose(skeleton).jointPoses;
                var poses2 = this._inputB.getSkeletonPose(skeleton).jointPoses;
                var pose1, pose2;
                var p1, p2;
                var tr;
                var numJoints = skeleton.numJoints;

                if (endPoses.length != numJoints)
                    endPoses.length = numJoints;

                for (var i = 0; i < numJoints; ++i) {
                    endPose = endPoses[i];

                    if (endPose == null)
                        endPose = endPoses[i] = new animators.JointPose();

                    pose1 = poses1[i];
                    pose2 = poses2[i];
                    p1 = pose1.translation;
                    p2 = pose2.translation;

                    endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._blendWeight);

                    tr = endPose.translation;
                    tr.x = p1.x + this._blendWeight * (p2.x - p1.x);
                    tr.y = p1.y + this._blendWeight * (p2.y - p1.y);
                    tr.z = p1.z + this._blendWeight * (p2.z - p1.z);
                }
            };
            return SkeletonBinaryLERPState;
        })(animators.AnimationStateBase);
        animators.SkeletonBinaryLERPState = SkeletonBinaryLERPState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        /**
        *
        */
        var SkeletonClipState = (function (_super) {
            __extends(SkeletonClipState, _super);
            function SkeletonClipState(animator, skeletonClipNode) {
                _super.call(this, animator, skeletonClipNode);
                this._rootPos = new Vector3D();
                this._skeletonPose = new animators.SkeletonPose();
                this._skeletonPoseDirty = true;

                this._skeletonClipNode = skeletonClipNode;
                this._frames = this._skeletonClipNode.frames;
            }
            Object.defineProperty(SkeletonClipState.prototype, "currentPose", {
                get: /**
                * Returns the current skeleton pose frame of animation in the clip based on the internal playhead position.
                */
                function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._currentPose;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkeletonClipState.prototype, "nextPose", {
                get: /**
                * Returns the next skeleton pose frame of animation in the clip based on the internal playhead position.
                */
                function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._nextPose;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
            */
            SkeletonClipState.prototype.getSkeletonPose = function (skeleton) {
                if (this._skeletonPoseDirty)
                    this.updateSkeletonPose(skeleton);

                return this._skeletonPose;
            };

            /**
            * @inheritDoc
            */
            SkeletonClipState.prototype._pUpdateTime = function (time/*int*/ ) {
                this._skeletonPoseDirty = true;

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * @inheritDoc
            */
            SkeletonClipState.prototype._pUpdateFrames = function () {
                _super.prototype._pUpdateFrames.call(this);

                this._currentPose = this._frames[this._pCurrentFrame];

                if (this._skeletonClipNode.looping && this._pNextFrame >= this._skeletonClipNode.lastFrame) {
                    this._nextPose = this._frames[0];
                    (this._pAnimator).dispatchCycleEvent();
                } else
                    this._nextPose = this._frames[this._pNextFrame];
            };

            /**
            * Updates the output skeleton pose of the node based on the internal playhead position.
            *
            * @param skeleton The skeleton used by the animator requesting the ouput pose.
            */
            SkeletonClipState.prototype.updateSkeletonPose = function (skeleton) {
                this._skeletonPoseDirty = false;

                if (!this._skeletonClipNode.totalDuration)
                    return;

                if (this._pFramesDirty)
                    this._pUpdateFrames();

                var currentPose = this._currentPose.jointPoses;
                var nextPose = this._nextPose.jointPoses;
                var numJoints = skeleton.numJoints;
                var p1, p2;
                var pose1, pose2;
                var endPoses = this._skeletonPose.jointPoses;
                var endPose;
                var tr;

                if (endPoses.length != numJoints)
                    endPoses.length = numJoints;

                if ((numJoints != currentPose.length) || (numJoints != nextPose.length))
                    throw new Error("joint counts don't match!");

                for (var i = 0; i < numJoints; ++i) {
                    endPose = endPoses[i];

                    if (endPose == null)
                        endPose = endPoses[i] = new animators.JointPose();

                    pose1 = currentPose[i];
                    pose2 = nextPose[i];
                    p1 = pose1.translation;
                    p2 = pose2.translation;

                    if (this._skeletonClipNode.highQuality)
                        endPose.orientation.slerp(pose1.orientation, pose2.orientation, this._pBlendWeight);
else
                        endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._pBlendWeight);

                    if (i > 0) {
                        tr = endPose.translation;
                        tr.x = p1.x + this._pBlendWeight * (p2.x - p1.x);
                        tr.y = p1.y + this._pBlendWeight * (p2.y - p1.y);
                        tr.z = p1.z + this._pBlendWeight * (p2.z - p1.z);
                    }
                }
            };

            /**
            * @inheritDoc
            */
            SkeletonClipState.prototype._pUpdatePositionDelta = function () {
                this._pPositionDeltaDirty = false;

                if (this._pFramesDirty)
                    this._pUpdateFrames();

                var p1, p2, p3;
                var totalDelta = this._skeletonClipNode.totalDelta;

                if ((this._pTimeDir > 0 && this._pNextFrame < this._pOldFrame) || (this._pTimeDir < 0 && this._pNextFrame > this._pOldFrame)) {
                    this._rootPos.x -= totalDelta.x * this._pTimeDir;
                    this._rootPos.y -= totalDelta.y * this._pTimeDir;
                    this._rootPos.z -= totalDelta.z * this._pTimeDir;
                }

                var dx = this._rootPos.x;
                var dy = this._rootPos.y;
                var dz = this._rootPos.z;

                if (this._skeletonClipNode.stitchFinalFrame && this._pNextFrame == this._skeletonClipNode.lastFrame) {
                    p1 = this._frames[0].jointPoses[0].translation;
                    p2 = this._frames[1].jointPoses[0].translation;
                    p3 = this._currentPose.jointPoses[0].translation;

                    this._rootPos.x = p3.x + p1.x + this._pBlendWeight * (p2.x - p1.x);
                    this._rootPos.y = p3.y + p1.y + this._pBlendWeight * (p2.y - p1.y);
                    this._rootPos.z = p3.z + p1.z + this._pBlendWeight * (p2.z - p1.z);
                } else {
                    p1 = this._currentPose.jointPoses[0].translation;
                    p2 = this._frames[this._pNextFrame].jointPoses[0].translation;
                    this._rootPos.x = p1.x + this._pBlendWeight * (p2.x - p1.x);
                    this._rootPos.y = p1.y + this._pBlendWeight * (p2.y - p1.y);
                    this._rootPos.z = p1.z + this._pBlendWeight * (p2.z - p1.z);
                }

                this._pRootDelta.x = this._rootPos.x - dx;
                this._pRootDelta.y = this._rootPos.y - dy;
                this._pRootDelta.z = this._rootPos.z - dz;

                this._pOldFrame = this._pNextFrame;
            };
            return SkeletonClipState;
        })(animators.AnimationClipState);
        animators.SkeletonClipState = SkeletonClipState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var Quaternion = away.geom.Quaternion;

        /**
        *
        */
        var SkeletonDifferenceState = (function (_super) {
            __extends(SkeletonDifferenceState, _super);
            function SkeletonDifferenceState(animator, skeletonAnimationNode) {
                _super.call(this, animator, skeletonAnimationNode);
                this._blendWeight = 0;
                this._skeletonPose = new animators.SkeletonPose();
                this._skeletonPoseDirty = true;

                this._skeletonAnimationNode = skeletonAnimationNode;

                this._baseInput = animator.getAnimationState(this._skeletonAnimationNode.baseInput);
                this._differenceInput = animator.getAnimationState(this._skeletonAnimationNode.differenceInput);
            }
            Object.defineProperty(SkeletonDifferenceState.prototype, "blendWeight", {
                get: /**
                * Defines a fractional value between 0 and 1 representing the blending ratio between the base input (0) and difference input (1),
                * used to produce the skeleton pose output.
                *
                * @see #baseInput
                * @see #differenceInput
                */
                function () {
                    return this._blendWeight;
                },
                set: function (value) {
                    this._blendWeight = value;

                    this._pPositionDeltaDirty = true;
                    this._skeletonPoseDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SkeletonDifferenceState.prototype.phase = function (value) {
                this._skeletonPoseDirty = true;

                this._pPositionDeltaDirty = true;

                this._baseInput.phase(value);
                this._baseInput.phase(value);
            };

            /**
            * @inheritDoc
            */
            SkeletonDifferenceState.prototype._pUpdateTime = function (time/*int*/ ) {
                this._skeletonPoseDirty = true;

                this._baseInput.update(time);
                this._differenceInput.update(time);

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
            */
            SkeletonDifferenceState.prototype.getSkeletonPose = function (skeleton) {
                if (this._skeletonPoseDirty)
                    this.updateSkeletonPose(skeleton);

                return this._skeletonPose;
            };

            /**
            * @inheritDoc
            */
            SkeletonDifferenceState.prototype._pUpdatePositionDelta = function () {
                this._pPositionDeltaDirty = false;

                var deltA = this._baseInput.positionDelta;
                var deltB = this._differenceInput.positionDelta;

                this.positionDelta.x = deltA.x + this._blendWeight * deltB.x;
                this.positionDelta.y = deltA.y + this._blendWeight * deltB.y;
                this.positionDelta.z = deltA.z + this._blendWeight * deltB.z;
            };

            /**
            * Updates the output skeleton pose of the node based on the blendWeight value between base input and difference input nodes.
            *
            * @param skeleton The skeleton used by the animator requesting the ouput pose.
            */
            SkeletonDifferenceState.prototype.updateSkeletonPose = function (skeleton) {
                this._skeletonPoseDirty = false;

                var endPose;
                var endPoses = this._skeletonPose.jointPoses;
                var basePoses = this._baseInput.getSkeletonPose(skeleton).jointPoses;
                var diffPoses = this._differenceInput.getSkeletonPose(skeleton).jointPoses;
                var base, diff;
                var basePos, diffPos;
                var tr;
                var numJoints = skeleton.numJoints;

                if (endPoses.length != numJoints)
                    endPoses.length = numJoints;

                for (var i = 0; i < numJoints; ++i) {
                    endPose = endPoses[i];

                    if (endPose == null)
                        endPose = endPoses[i] = new animators.JointPose();

                    base = basePoses[i];
                    diff = diffPoses[i];
                    basePos = base.translation;
                    diffPos = diff.translation;

                    SkeletonDifferenceState._tempQuat.multiply(diff.orientation, base.orientation);
                    endPose.orientation.lerp(base.orientation, SkeletonDifferenceState._tempQuat, this._blendWeight);

                    tr = endPose.translation;
                    tr.x = basePos.x + this._blendWeight * diffPos.x;
                    tr.y = basePos.y + this._blendWeight * diffPos.y;
                    tr.z = basePos.z + this._blendWeight * diffPos.z;
                }
            };
            SkeletonDifferenceState._tempQuat = new Quaternion();
            return SkeletonDifferenceState;
        })(animators.AnimationStateBase);
        animators.SkeletonDifferenceState = SkeletonDifferenceState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        /**
        *
        */
        var SkeletonDirectionalState = (function (_super) {
            __extends(SkeletonDirectionalState, _super);
            function SkeletonDirectionalState(animator, skeletonAnimationNode) {
                _super.call(this, animator, skeletonAnimationNode);
                this._skeletonPose = new animators.SkeletonPose();
                this._skeletonPoseDirty = true;
                this._blendWeight = 0;
                this._direction = 0;
                this._blendDirty = true;

                this._skeletonAnimationNode = skeletonAnimationNode;

                this._forward = animator.getAnimationState(this._skeletonAnimationNode.forward);
                this._backward = animator.getAnimationState(this._skeletonAnimationNode.backward);
                this._left = animator.getAnimationState(this._skeletonAnimationNode.left);
                this._right = animator.getAnimationState(this._skeletonAnimationNode.right);
            }

            Object.defineProperty(SkeletonDirectionalState.prototype, "direction", {
                get: function () {
                    return this._direction;
                },
                set: /**
                * Defines the direction in degrees of the aniamtion between the forwards (0), right(90) backwards (180) and left(270) input nodes,
                * used to produce the skeleton pose output.
                */
                function (value) {
                    if (this._direction == value)
                        return;

                    this._direction = value;

                    this._blendDirty = true;

                    this._skeletonPoseDirty = true;
                    this._pPositionDeltaDirty = true;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SkeletonDirectionalState.prototype.phase = function (value) {
                if (this._blendDirty)
                    this.updateBlend();

                this._skeletonPoseDirty = true;

                this._pPositionDeltaDirty = true;

                this._inputA.phase(value);
                this._inputB.phase(value);
            };

            /**
            * @inheritDoc
            */
            SkeletonDirectionalState.prototype._pUdateTime = function (time/*int*/ ) {
                if (this._blendDirty)
                    this.updateBlend();

                this._skeletonPoseDirty = true;

                this._inputA.update(time);
                this._inputB.update(time);

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
            */
            SkeletonDirectionalState.prototype.getSkeletonPose = function (skeleton) {
                if (this._skeletonPoseDirty)
                    this.updateSkeletonPose(skeleton);

                return this._skeletonPose;
            };

            /**
            * @inheritDoc
            */
            SkeletonDirectionalState.prototype._pUpdatePositionDelta = function () {
                this._pPositionDeltaDirty = false;

                if (this._blendDirty)
                    this.updateBlend();

                var deltA = this._inputA.positionDelta;
                var deltB = this._inputB.positionDelta;

                this.positionDelta.x = deltA.x + this._blendWeight * (deltB.x - deltA.x);
                this.positionDelta.y = deltA.y + this._blendWeight * (deltB.y - deltA.y);
                this.positionDelta.z = deltA.z + this._blendWeight * (deltB.z - deltA.z);
            };

            /**
            * Updates the output skeleton pose of the node based on the direction value between forward, backwards, left and right input nodes.
            *
            * @param skeleton The skeleton used by the animator requesting the ouput pose.
            */
            SkeletonDirectionalState.prototype.updateSkeletonPose = function (skeleton) {
                this._skeletonPoseDirty = false;

                if (this._blendDirty)
                    this.updateBlend();

                var endPose;
                var endPoses = this._skeletonPose.jointPoses;
                var poses1 = this._inputA.getSkeletonPose(skeleton).jointPoses;
                var poses2 = this._inputB.getSkeletonPose(skeleton).jointPoses;
                var pose1, pose2;
                var p1, p2;
                var tr;
                var numJoints = skeleton.numJoints;

                if (endPoses.length != numJoints)
                    endPoses.length = numJoints;

                for (var i = 0; i < numJoints; ++i) {
                    endPose = endPoses[i];

                    if (endPose == null)
                        endPose = endPoses[i] = new animators.JointPose();

                    pose1 = poses1[i];
                    pose2 = poses2[i];
                    p1 = pose1.translation;
                    p2 = pose2.translation;

                    endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._blendWeight);

                    tr = endPose.translation;
                    tr.x = p1.x + this._blendWeight * (p2.x - p1.x);
                    tr.y = p1.y + this._blendWeight * (p2.y - p1.y);
                    tr.z = p1.z + this._blendWeight * (p2.z - p1.z);
                }
            };

            /**
            * Updates the blend value for the animation output based on the direction value between forward, backwards, left and right input nodes.
            *
            * @private
            */
            SkeletonDirectionalState.prototype.updateBlend = function () {
                this._blendDirty = false;

                if (this._direction < 0 || this._direction > 360) {
                    this._direction %= 360;
                    if (this._direction < 0)
                        this._direction += 360;
                }

                if (this._direction < 90) {
                    this._inputA = this._forward;
                    this._inputB = this._right;
                    this._blendWeight = this._direction / 90;
                } else if (this._direction < 180) {
                    this._inputA = this._right;
                    this._inputB = this._backward;
                    this._blendWeight = (this._direction - 90) / 90;
                } else if (this._direction < 270) {
                    this._inputA = this._backward;
                    this._inputB = this._left;
                    this._blendWeight = (this._direction - 180) / 90;
                } else {
                    this._inputA = this._left;
                    this._inputB = this._forward;
                    this._blendWeight = (this._direction - 270) / 90;
                }
            };
            return SkeletonDirectionalState;
        })(animators.AnimationStateBase);
        animators.SkeletonDirectionalState = SkeletonDirectionalState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var Quaternion = away.geom.Quaternion;

        /**
        *
        */
        var SkeletonNaryLERPState = (function (_super) {
            __extends(SkeletonNaryLERPState, _super);
            function SkeletonNaryLERPState(animator, skeletonAnimationNode) {
                _super.call(this, animator, skeletonAnimationNode);
                this._skeletonPose = new animators.SkeletonPose();
                this._skeletonPoseDirty = true;
                this._blendWeights = new Array();
                this._inputs = new Array();

                this._skeletonAnimationNode = skeletonAnimationNode;

                var i = this._skeletonAnimationNode.numInputs;

                while (i--)
                    this._inputs[i] = animator.getAnimationState(this._skeletonAnimationNode._iInputs[i]);
            }
            /**
            * @inheritDoc
            */
            SkeletonNaryLERPState.prototype.phase = function (value) {
                this._skeletonPoseDirty = true;

                this._pPositionDeltaDirty = true;

                for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
                    if (this._blendWeights[j])
                        this._inputs[j].update(value);
                }
            };

            /**
            * @inheritDoc
            */
            SkeletonNaryLERPState.prototype._pUdateTime = function (time/*int*/ ) {
                for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
                    if (this._blendWeights[j])
                        this._inputs[j].update(time);
                }

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
            */
            SkeletonNaryLERPState.prototype.getSkeletonPose = function (skeleton) {
                if (this._skeletonPoseDirty)
                    this.updateSkeletonPose(skeleton);

                return this._skeletonPose;
            };

            /**
            * Returns the blend weight of the skeleton aniamtion node that resides at the given input index.
            *
            * @param index The input index for which the skeleton animation node blend weight is requested.
            */
            SkeletonNaryLERPState.prototype.getBlendWeightAt = function (index/*uint*/ ) {
                return this._blendWeights[index];
            };

            /**
            * Sets the blend weight of the skeleton aniamtion node that resides at the given input index.
            *
            * @param index The input index on which the skeleton animation node blend weight is to be set.
            * @param blendWeight The blend weight value to use for the given skeleton animation node index.
            */
            SkeletonNaryLERPState.prototype.setBlendWeightAt = function (index/*uint*/ , blendWeight) {
                this._blendWeights[index] = blendWeight;

                this._pPositionDeltaDirty = true;
                this._skeletonPoseDirty = true;
            };

            /**
            * @inheritDoc
            */
            SkeletonNaryLERPState.prototype._pUpdatePositionDelta = function () {
                this._pPositionDeltaDirty = false;

                var delta;
                var weight;

                this.positionDelta.x = 0;
                this.positionDelta.y = 0;
                this.positionDelta.z = 0;

                for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
                    weight = this._blendWeights[j];

                    if (weight) {
                        delta = this._inputs[j].positionDelta;
                        this.positionDelta.x += weight * delta.x;
                        this.positionDelta.y += weight * delta.y;
                        this.positionDelta.z += weight * delta.z;
                    }
                }
            };

            /**
            * Updates the output skeleton pose of the node based on the blend weight values given to the input nodes.
            *
            * @param skeleton The skeleton used by the animator requesting the ouput pose.
            */
            SkeletonNaryLERPState.prototype.updateSkeletonPose = function (skeleton) {
                this._skeletonPoseDirty = false;

                var weight;
                var endPoses = this._skeletonPose.jointPoses;
                var poses;
                var endPose, pose;
                var endTr, tr;
                var endQuat, q;
                var firstPose;
                var i/*uint*/ ;
                var w0, x0, y0, z0;
                var w1, x1, y1, z1;
                var numJoints = skeleton.numJoints;

                if (endPoses.length != numJoints)
                    endPoses.length = numJoints;

                for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
                    weight = this._blendWeights[j];

                    if (!weight)
                        continue;

                    poses = this._inputs[j].getSkeletonPose(skeleton).jointPoses;

                    if (!firstPose) {
                        firstPose = poses;
                        for (i = 0; i < numJoints; ++i) {
                            endPose = endPoses[i];

                            if (endPose == null)
                                endPose = endPoses[i] = new animators.JointPose();

                            pose = poses[i];
                            q = pose.orientation;
                            tr = pose.translation;

                            endQuat = endPose.orientation;

                            endQuat.x = weight * q.x;
                            endQuat.y = weight * q.y;
                            endQuat.z = weight * q.z;
                            endQuat.w = weight * q.w;

                            endTr = endPose.translation;
                            endTr.x = weight * tr.x;
                            endTr.y = weight * tr.y;
                            endTr.z = weight * tr.z;
                        }
                    } else {
                        for (i = 0; i < skeleton.numJoints; ++i) {
                            endPose = endPoses[i];
                            pose = poses[i];

                            q = firstPose[i].orientation;
                            x0 = q.x;
                            y0 = q.y;
                            z0 = q.z;
                            w0 = q.w;

                            q = pose.orientation;
                            tr = pose.translation;

                            x1 = q.x;
                            y1 = q.y;
                            z1 = q.z;
                            w1 = q.w;

                            if (x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1 < 0) {
                                x1 = -x1;
                                y1 = -y1;
                                z1 = -z1;
                                w1 = -w1;
                            }
                            endQuat = endPose.orientation;
                            endQuat.x += weight * x1;
                            endQuat.y += weight * y1;
                            endQuat.z += weight * z1;
                            endQuat.w += weight * w1;

                            endTr = endPose.translation;
                            endTr.x += weight * tr.x;
                            endTr.y += weight * tr.y;
                            endTr.z += weight * tr.z;
                        }
                    }
                }

                for (i = 0; i < skeleton.numJoints; ++i)
                    endPoses[i].orientation.normalize();
            };
            return SkeletonNaryLERPState;
        })(animators.AnimationStateBase);
        animators.SkeletonNaryLERPState = SkeletonNaryLERPState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        *
        */
        var VertexClipState = (function (_super) {
            __extends(VertexClipState, _super);
            function VertexClipState(animator, vertexClipNode) {
                _super.call(this, animator, vertexClipNode);

                this._vertexClipNode = vertexClipNode;
                this._frames = this._vertexClipNode.frames;
            }
            Object.defineProperty(VertexClipState.prototype, "currentGeometry", {
                get: /**
                * @inheritDoc
                */
                function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._currentGeometry;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(VertexClipState.prototype, "nextGeometry", {
                get: /**
                * @inheritDoc
                */
                function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._nextGeometry;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            VertexClipState.prototype._pUpdateFrames = function () {
                _super.prototype._pUpdateFrames.call(this);

                this._currentGeometry = this._frames[this._pCurrentFrame];

                if (this._vertexClipNode.looping && this._pNextFrame >= this._vertexClipNode.lastFrame) {
                    this._nextGeometry = this._frames[0];
                    (this._pAnimator).dispatchCycleEvent();
                } else
                    this._nextGeometry = this._frames[this._pNextFrame];
            };

            /**
            * @inheritDoc
            */
            VertexClipState.prototype._pUpdatePositionDelta = function () {
                //TODO:implement positiondelta functionality for vertex animations
            };
            return VertexClipState;
        })(animators.AnimationClipState);
        animators.VertexClipState = VertexClipState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var CrossfadeTransition = (function () {
            function CrossfadeTransition(blendSpeed) {
                this.blendSpeed = 0.5;
                this.blendSpeed = blendSpeed;
            }
            CrossfadeTransition.prototype.getAnimationNode = function (animator, startNode, endNode, startBlend/*int*/ ) {
                var crossFadeTransitionNode = new animators.CrossfadeTransitionNode();
                crossFadeTransitionNode.inputA = startNode;
                crossFadeTransitionNode.inputB = endNode;
                crossFadeTransitionNode.blendSpeed = this.blendSpeed;
                crossFadeTransitionNode.startBlend = startBlend;

                return crossFadeTransitionNode;
            };
            return CrossfadeTransition;
        })();
        animators.CrossfadeTransition = CrossfadeTransition;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * A skeleton animation node that uses two animation node inputs to blend a lineraly interpolated output of a skeleton pose.
        */
        var CrossfadeTransitionNode = (function (_super) {
            __extends(CrossfadeTransitionNode, _super);
            /**
            * Creates a new <code>CrossfadeTransitionNode</code> object.
            */
            function CrossfadeTransitionNode() {
                _super.call(this);

                this._pStateClass = animators.CrossfadeTransitionState;
            }
            return CrossfadeTransitionNode;
        })(animators.SkeletonBinaryLERPNode);
        animators.CrossfadeTransitionNode = CrossfadeTransitionNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        var AnimationStateEvent = away.events.AnimationStateEvent;

        /**
        *
        */
        var CrossfadeTransitionState = (function (_super) {
            __extends(CrossfadeTransitionState, _super);
            function CrossfadeTransitionState(animator, skeletonAnimationNode) {
                _super.call(this, animator, skeletonAnimationNode);

                this._crossfadeTransitionNode = skeletonAnimationNode;
            }
            /**
            * @inheritDoc
            */
            CrossfadeTransitionState.prototype._pUpdateTime = function (time/*int*/ ) {
                this.blendWeight = Math.abs(time - this._crossfadeTransitionNode.startBlend) / (1000 * this._crossfadeTransitionNode.blendSpeed);

                if (this.blendWeight >= 1) {
                    this.blendWeight = 1;

                    if (this._animationStateTransitionComplete == null)
                        this._animationStateTransitionComplete = new AnimationStateEvent(AnimationStateEvent.TRANSITION_COMPLETE, this._pAnimator, this, this._crossfadeTransitionNode);

                    this._crossfadeTransitionNode.dispatchEvent(this._animationStateTransitionComplete);
                }

                _super.prototype._pUpdateTime.call(this, time);
            };
            return CrossfadeTransitionState;
        })(animators.SkeletonBinaryLERPState);
        animators.CrossfadeTransitionState = CrossfadeTransitionState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (animators) {
        /**
        * Provides an abstract base class for data set classes that hold animation data for use in animator classes.
        *
        * @see away.animators.AnimatorBase
        */
        var AnimationSetBase = (function (_super) {
            __extends(AnimationSetBase, _super);
            function AnimationSetBase() {
                _super.call(this);
                this._animations = new Array();
                this._animationNames = new Array();
                this._animationDictionary = new Object();
            }
            /**
            * Retrieves a temporary GPU register that's still free.
            *
            * @param exclude An array of non-free temporary registers.
            * @param excludeAnother An additional register that's not free.
            * @return A temporary register that can be used.
            */
            AnimationSetBase.prototype._pFindTempReg = function (exclude, excludeAnother) {
                if (typeof excludeAnother === "undefined") { excludeAnother = null; }
                var i = 0;
                var reg;

                while (true) {
                    reg = "vt" + i;
                    if (exclude.indexOf(reg) == -1 && excludeAnother != reg)
                        return reg;
                    ++i;
                }

                // can't be reached
                return null;
            };

            Object.defineProperty(AnimationSetBase.prototype, "usesCPU", {
                get: /**
                * Indicates whether the properties of the animation data contained within the set combined with
                * the vertex registers aslready in use on shading materials allows the animation data to utilise
                * GPU calls.
                */
                function () {
                    return this._usesCPU;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Called by the material to reset the GPU indicator before testing whether register space in the shader
            * is available for running GPU-based animation code.
            *
            * @private
            */
            AnimationSetBase.prototype.resetGPUCompatibility = function () {
                this._usesCPU = false;
            };

            AnimationSetBase.prototype.cancelGPUCompatibility = function () {
                this._usesCPU = true;
            };

            Object.defineProperty(AnimationSetBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.ANIMATION_SET;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationSetBase.prototype, "animations", {
                get: /**
                * Returns a vector of animation state objects that make up the contents of the animation data set.
                */
                function () {
                    return this._animations;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationSetBase.prototype, "animationNames", {
                get: /**
                * Returns a vector of animation state objects that make up the contents of the animation data set.
                */
                function () {
                    return this._animationNames;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Check to determine whether a state is registered in the animation set under the given name.
            *
            * @param stateName The name of the animation state object to be checked.
            */
            AnimationSetBase.prototype.hasAnimation = function (name) {
                return this._animationDictionary[name] != null;
            };

            /**
            * Retrieves the animation state object registered in the animation data set under the given name.
            *
            * @param stateName The name of the animation state object to be retrieved.
            */
            AnimationSetBase.prototype.getAnimation = function (name) {
                return this._animationDictionary[name];
            };

            /**
            * Adds an animation state object to the aniamtion data set under the given name.
            *
            * @param stateName The name under which the animation state object will be stored.
            * @param animationState The animation state object to be staored in the set.
            */
            AnimationSetBase.prototype.addAnimation = function (node) {
                if (this._animationDictionary[node.name])
                    throw new away.errors.AnimationSetError("root node name '" + node.name + "' already exists in the set");

                this._animationDictionary[node.name] = node;

                this._animations.push(node);

                this._animationNames.push(node.name);
            };

            /**
            * Cleans up any resources used by the current object.
            */
            AnimationSetBase.prototype.dispose = function () {
            };
            return AnimationSetBase;
        })(away.library.NamedAssetBase);
        animators.AnimationSetBase = AnimationSetBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (animators) {
        var StageGL = away.base.StageGL;
        var Camera = away.entities.Camera;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var RenderableBase = away.pool.RenderableBase;

        /**
        * Dispatched when playback of an animation inside the animator object starts.
        *
        * @eventType away3d.events.AnimatorEvent
        */
        //[Event(name="start", type="away3d.events.AnimatorEvent")]
        /**
        * Dispatched when playback of an animation inside the animator object stops.
        *
        * @eventType away3d.events.AnimatorEvent
        */
        //[Event(name="stop", type="away3d.events.AnimatorEvent")]
        /**
        * Dispatched when playback of an animation reaches the end of an animation.
        *
        * @eventType away3d.events.AnimatorEvent
        */
        //[Event(name="cycle_complete", type="away3d.events.AnimatorEvent")]
        /**
        * Provides an abstract base class for animator classes that control animation output from a data set subtype of <code>AnimationSetBase</code>.
        *
        * @see away.animators.AnimationSetBase
        */
        var AnimatorBase = (function (_super) {
            __extends(AnimatorBase, _super);
            /**
            * Creates a new <code>AnimatorBase</code> object.
            *
            * @param animationSet The animation data set to be used by the animator object.
            */
            function AnimatorBase(animationSet) {
                _super.call(this);
                this._autoUpdate = true;
                this._time = 0;
                this._playbackSpeed = 1;
                this._pOwners = new Array();
                this._pAbsoluteTime = 0;
                this._animationStates = new Object();
                /**
                * Enables translation of the animated mesh from data returned per frame via the positionDelta property of the active animation node. Defaults to true.
                *
                * @see away.animators.IAnimationState#positionDelta
                */
                this.updatePosition = true;

                this._pAnimationSet = animationSet;

                this._broadcaster = new away.utils.RequestAnimationFrame(this.onEnterFrame, this);
            }
            AnimatorBase.prototype.getAnimationState = function (node) {
                var className = node.stateClass;
                var uID = node.id;

                if (this._animationStates[uID] == null)
                    this._animationStates[uID] = new className(this, node);

                return this._animationStates[uID];
            };

            AnimatorBase.prototype.getAnimationStateByName = function (name) {
                return this.getAnimationState(this._pAnimationSet.getAnimation(name));
            };

            Object.defineProperty(AnimatorBase.prototype, "absoluteTime", {
                get: /**
                * Returns the internal absolute time of the animator, calculated by the current time and the playback speed.
                *
                * @see #time
                * @see #playbackSpeed
                */
                function () {
                    return this._pAbsoluteTime;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "animationSet", {
                get: /**
                * Returns the animation data set in use by the animator.
                */
                function () {
                    return this._pAnimationSet;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "activeState", {
                get: /**
                * Returns the current active animation state.
                */
                function () {
                    return this._pActiveState;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "activeAnimation", {
                get: /**
                * Returns the current active animation node.
                */
                function () {
                    return this._pAnimationSet.getAnimation(this._pActiveAnimationName);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "activeAnimationName", {
                get: /**
                * Returns the current active animation node.
                */
                function () {
                    return this._pActiveAnimationName;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "autoUpdate", {
                get: /**
                * Determines whether the animators internal update mechanisms are active. Used in cases
                * where manual updates are required either via the <code>time</code> property or <code>update()</code> method.
                * Defaults to true.
                *
                * @see #time
                * @see #update()
                */
                function () {
                    return this._autoUpdate;
                },
                set: function (value) {
                    if (this._autoUpdate == value)
                        return;

                    this._autoUpdate = value;

                    if (this._autoUpdate)
                        this.start();
else
                        this.stop();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AnimatorBase.prototype, "time", {
                get: /**
                * Gets and sets the internal time clock of the animator.
                */
                function () {
                    return this._time;
                },
                set: function (value/*int*/ ) {
                    if (this._time == value)
                        return;

                    this.update(value);
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Sets the animation phase of the current active state's animation clip(s).
            *
            * @param value The phase value to use. 0 represents the beginning of an animation clip, 1 represents the end.
            */
            AnimatorBase.prototype.phase = function (value) {
                this._pActiveState.phase(value);
            };

            Object.defineProperty(AnimatorBase.prototype, "playbackSpeed", {
                get: /**
                * The amount by which passed time should be scaled. Used to slow down or speed up animations. Defaults to 1.
                */
                function () {
                    return this._playbackSpeed;
                },
                set: function (value) {
                    this._playbackSpeed = value;
                },
                enumerable: true,
                configurable: true
            });


            AnimatorBase.prototype.setRenderState = function (stageGL, renderable, vertexConstantOffset/*int*/ , vertexStreamOffset/*int*/ , camera) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Resumes the automatic playback clock controling the active state of the animator.
            */
            AnimatorBase.prototype.start = function () {
                if (this._isPlaying || !this._autoUpdate)
                    return;

                this._time = this._pAbsoluteTime = away.utils.getTimer();

                this._isPlaying = true;

                this._broadcaster.start();

                if (!this.hasEventListener(away.events.AnimatorEvent.START))
                    return;

                if (this._startEvent == null)
                    this._startEvent = new away.events.AnimatorEvent(away.events.AnimatorEvent.START, this);

                this.dispatchEvent(this._startEvent);
            };

            /**
            * Pauses the automatic playback clock of the animator, in case manual updates are required via the
            * <code>time</code> property or <code>update()</code> method.
            *
            * @see #time
            * @see #update()
            */
            AnimatorBase.prototype.stop = function () {
                if (!this._isPlaying)
                    return;

                this._isPlaying = false;

                this._broadcaster.stop();

                if (!this.hasEventListener(away.events.AnimatorEvent.STOP))
                    return;

                if (this._stopEvent == null)
                    this._stopEvent = new away.events.AnimatorEvent(away.events.AnimatorEvent.STOP, this);

                this.dispatchEvent(this._stopEvent);
            };

            /**
            * Provides a way to manually update the active state of the animator when automatic
            * updates are disabled.
            *
            * @see #stop()
            * @see #autoUpdate
            */
            AnimatorBase.prototype.update = function (time/*int*/ ) {
                var dt = (time - this._time) * this.playbackSpeed;

                this._pUpdateDeltaTime(dt);

                this._time = time;
            };

            AnimatorBase.prototype.reset = function (name, offset) {
                if (typeof offset === "undefined") { offset = 0; }
                this.getAnimationState(this._pAnimationSet.getAnimation(name)).offset(offset + this._pAbsoluteTime);
            };

            /**
            * Used by the mesh object to which the animator is applied, registers the owner for internal use.
            *
            * @private
            */
            AnimatorBase.prototype.addOwner = function (mesh) {
                this._pOwners.push(mesh);
            };

            /**
            * Used by the mesh object from which the animator is removed, unregisters the owner for internal use.
            *
            * @private
            */
            AnimatorBase.prototype.removeOwner = function (mesh) {
                this._pOwners.splice(this._pOwners.indexOf(mesh), 1);
            };

            /**
            * Internal abstract method called when the time delta property of the animator's contents requires updating.
            *
            * @private
            */
            AnimatorBase.prototype._pUpdateDeltaTime = function (dt) {
                this._pAbsoluteTime += dt;

                this._pActiveState.update(this._pAbsoluteTime);

                if (this.updatePosition)
                    this.applyPositionDelta();
            };

            /**
            * Enter frame event handler for automatically updating the active state of the animator.
            */
            AnimatorBase.prototype.onEnterFrame = function (event) {
                if (typeof event === "undefined") { event = null; }
                this.update(away.utils.getTimer());
            };

            AnimatorBase.prototype.applyPositionDelta = function () {
                var delta = this._pActiveState.positionDelta;
                var dist = delta.length;
                var len/*uint*/ ;
                if (dist > 0) {
                    len = this._pOwners.length;
                    for (var i = 0; i < len; ++i)
                        this._pOwners[i].translateLocal(delta, dist);
                }
            };

            /**
            *  for internal use.
            *
            * @private
            */
            AnimatorBase.prototype.dispatchCycleEvent = function () {
                if (this.hasEventListener(away.events.AnimatorEvent.CYCLE_COMPLETE)) {
                    if (this._cycleEvent == null)
                        this._cycleEvent = new away.events.AnimatorEvent(away.events.AnimatorEvent.CYCLE_COMPLETE, this);

                    this.dispatchEvent(this._cycleEvent);
                }
            };

            /**
            * @inheritDoc
            */
            AnimatorBase.prototype.clone = function () {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * @inheritDoc
            */
            AnimatorBase.prototype.dispose = function () {
            };

            /**
            * @inheritDoc
            */
            AnimatorBase.prototype.testGPUCompatibility = function (pass) {
                throw new away.errors.AbstractMethodError();
            };

            Object.defineProperty(AnimatorBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.ANIMATOR;
                },
                enumerable: true,
                configurable: true
            });
            return AnimatorBase;
        })(away.library.NamedAssetBase);
        animators.AnimatorBase = AnimatorBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (animators) {
        
        var ParticleGeometry = away.base.ParticleGeometry;
        var SubMesh = away.base.SubMesh;
        var ContextGL = away.gl.ContextGL;
        var Mesh = away.entities.Mesh;
        var StageGL = away.base.StageGL;
        var MaterialPassBase = away.materials.MaterialPassBase;

        /**
        * The animation data set used by particle-based animators, containing particle animation data.
        *
        * @see away.animators.ParticleAnimator
        */
        var ParticleAnimationSet = (function (_super) {
            __extends(ParticleAnimationSet, _super);
            /**
            * Creates a new <code>ParticleAnimationSet</code>
            *
            * @param    [optional] usesDuration    Defines whether the animation set uses the <code>duration</code> data in its static properties to determine how long a particle is visible for. Defaults to false.
            * @param    [optional] usesLooping     Defines whether the animation set uses a looping timeframe for each particle determined by the <code>startTime</code>, <code>duration</code> and <code>delay</code> data in its static properties function. Defaults to false. Requires <code>usesDuration</code> to be true.
            * @param    [optional] usesDelay       Defines whether the animation set uses the <code>delay</code> data in its static properties to determine how long a particle is hidden for. Defaults to false. Requires <code>usesLooping</code> to be true.
            */
            function ParticleAnimationSet(usesDuration, usesLooping, usesDelay) {
                if (typeof usesDuration === "undefined") { usesDuration = false; }
                if (typeof usesLooping === "undefined") { usesLooping = false; }
                if (typeof usesDelay === "undefined") { usesDelay = false; }
                _super.call(this);
                this._animationSubGeometries = new Object();
                this._particleNodes = new Array();
                this._localDynamicNodes = new Array();
                this._localStaticNodes = new Array();
                this._totalLenOfOneVertex = 0;

                //automatically add a particle time node to the set
                this.addAnimation(this._timeNode = new animators.ParticleTimeNode(usesDuration, usesLooping, usesDelay));
            }
            Object.defineProperty(ParticleAnimationSet.prototype, "particleNodes", {
                get: /**
                * Returns a vector of the particle animation nodes contained within the set.
                */
                function () {
                    return this._particleNodes;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.addAnimation = function (node) {
                var i/*int*/ ;
                var n = node;
                n._iProcessAnimationSetting(this);
                if (n.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                    n._iDataOffset = this._totalLenOfOneVertex;
                    this._totalLenOfOneVertex += n.dataLength;
                    this._localStaticNodes.push(n);
                } else if (n.mode == animators.ParticlePropertiesMode.LOCAL_DYNAMIC)
                    this._localDynamicNodes.push(n);

                for (i = this._particleNodes.length - 1; i >= 0; i--) {
                    if (this._particleNodes[i].priority <= n.priority)
                        break;
                }

                this._particleNodes.splice(i + 1, 0, n);

                _super.prototype.addAnimation.call(this, node);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.activate = function (stageGL, pass) {
                this._iAnimationRegisterCache = pass.animationRegisterCache;
            };

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.deactivate = function (stageGL, pass) {
                var context = stageGL.contextGL;
                var offset = this._iAnimationRegisterCache.vertexAttributesOffset;
                var used = this._iAnimationRegisterCache.numUsedStreams;
                for (var i = offset; i < used; i++)
                    context.setVertexBufferAt(i, null);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.getAGALVertexCode = function (pass, sourceRegisters, targetRegisters, profile) {
                //grab animationRegisterCache from the materialpassbase or create a new one if the first time
                this._iAnimationRegisterCache = pass.animationRegisterCache;

                if (this._iAnimationRegisterCache == null)
                    this._iAnimationRegisterCache = pass.animationRegisterCache = new animators.AnimationRegisterCache(profile);

                //reset animationRegisterCache
                this._iAnimationRegisterCache.vertexConstantOffset = pass.numUsedVertexConstants;
                this._iAnimationRegisterCache.vertexAttributesOffset = pass.numUsedStreams;
                this._iAnimationRegisterCache.varyingsOffset = pass.numUsedVaryings;
                this._iAnimationRegisterCache.fragmentConstantOffset = pass.numUsedFragmentConstants;
                this._iAnimationRegisterCache.hasUVNode = this.hasUVNode;
                this._iAnimationRegisterCache.needVelocity = this.needVelocity;
                this._iAnimationRegisterCache.hasBillboard = this.hasBillboard;
                this._iAnimationRegisterCache.sourceRegisters = sourceRegisters;
                this._iAnimationRegisterCache.targetRegisters = targetRegisters;
                this._iAnimationRegisterCache.needFragmentAnimation = pass.needFragmentAnimation;
                this._iAnimationRegisterCache.needUVAnimation = pass.needUVAnimation;
                this._iAnimationRegisterCache.hasColorAddNode = this.hasColorAddNode;
                this._iAnimationRegisterCache.hasColorMulNode = this.hasColorMulNode;
                this._iAnimationRegisterCache.reset();

                var code = "";

                code += this._iAnimationRegisterCache.getInitCode();

                var node;
                var i/*int*/ ;

                for (i = 0; i < this._particleNodes.length; i++) {
                    node = this._particleNodes[i];
                    if (node.priority < ParticleAnimationSet.POST_PRIORITY)
                        code += node.getAGALVertexCode(pass, this._iAnimationRegisterCache);
                }

                code += this._iAnimationRegisterCache.getCombinationCode();

                for (i = 0; i < this._particleNodes.length; i++) {
                    node = this._particleNodes[i];
                    if (node.priority >= ParticleAnimationSet.POST_PRIORITY && node.priority < ParticleAnimationSet.COLOR_PRIORITY)
                        code += node.getAGALVertexCode(pass, this._iAnimationRegisterCache);
                }

                code += this._iAnimationRegisterCache.initColorRegisters();

                for (i = 0; i < this._particleNodes.length; i++) {
                    node = this._particleNodes[i];
                    if (node.priority >= ParticleAnimationSet.COLOR_PRIORITY)
                        code += node.getAGALVertexCode(pass, this._iAnimationRegisterCache);
                }
                code += this._iAnimationRegisterCache.getColorPassCode();
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.getAGALUVCode = function (pass, UVSource, UVTarget) {
                var code = "";
                if (this.hasUVNode) {
                    this._iAnimationRegisterCache.setUVSourceAndTarget(UVSource, UVTarget);
                    code += "mov " + this._iAnimationRegisterCache.uvTarget + ".xy," + this._iAnimationRegisterCache.uvAttribute.toString() + "\n";
                    var node;
                    for (var i = 0; i < this._particleNodes.length; i++)
                        node = this._particleNodes[i];
                    code += node.getAGALUVCode(pass, this._iAnimationRegisterCache);
                    code += "mov " + this._iAnimationRegisterCache.uvVar.toString() + "," + this._iAnimationRegisterCache.uvTarget + ".xy\n";
                } else
                    code += "mov " + UVTarget + "," + UVSource + "\n";
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.getAGALFragmentCode = function (pass, shadedTarget, profile) {
                return this._iAnimationRegisterCache.getColorCombinationCode(shadedTarget);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.doneAGALCode = function (pass) {
                this._iAnimationRegisterCache.setDataLength();

                //set vertexZeroConst,vertexOneConst,vertexTwoConst
                this._iAnimationRegisterCache.setVertexConst(this._iAnimationRegisterCache.vertexZeroConst.index, 0, 1, 2, 0);
            };

            Object.defineProperty(ParticleAnimationSet.prototype, "usesCPU", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.cancelGPUCompatibility = function () {
            };

            ParticleAnimationSet.prototype.dispose = function () {
                for (var key in this._animationSubGeometries)
                    (this._animationSubGeometries[key]).dispose();

                _super.prototype.dispose.call(this);
            };

            /** @private */
            ParticleAnimationSet.prototype._iGenerateAnimationSubGeometries = function (mesh) {
                if (this.initParticleFunc == null)
                    throw (new Error("no initParticleFunc set"));

                var geometry = mesh.geometry;

                if (!geometry)
                    throw (new Error("Particle animation can only be performed on a ParticleGeometry object"));

                var i/*int*/ , j, k;
                var animationSubGeometry;
                var newAnimationSubGeometry = false;
                var subGeometry;
                var subMesh;
                var localNode;

                for (i = 0; i < mesh.subMeshes.length; i++) {
                    subMesh = mesh.subMeshes[i];
                    subGeometry = subMesh.subGeometry;
                    if (mesh.shareAnimationGeometry) {
                        animationSubGeometry = this._animationSubGeometries[subGeometry.id];

                        if (animationSubGeometry) {
                            subMesh.animationSubGeometry = animationSubGeometry;
                            continue;
                        }
                    }

                    animationSubGeometry = subMesh.animationSubGeometry = new animators.AnimationSubGeometry();
                    if (mesh.shareAnimationGeometry)
                        this._animationSubGeometries[subGeometry.id] = animationSubGeometry;

                    newAnimationSubGeometry = true;

                    //create the vertexData vector that will be used for local node data
                    animationSubGeometry.createVertexData(subGeometry.numVertices, this._totalLenOfOneVertex);
                }

                if (!newAnimationSubGeometry)
                    return;

                var particles = geometry.particles;
                var particlesLength = particles.length;
                var numParticles = geometry.numParticles;
                var particleProperties = new animators.ParticleProperties();
                var particle;

                var oneDataLen/*int*/ ;
                var oneDataOffset/*int*/ ;
                var counterForVertex/*int*/ ;
                var counterForOneData/*int*/ ;
                var oneData;
                var numVertices/*uint*/ ;
                var vertexData;
                var vertexLength/*uint*/ ;
                var startingOffset/*uint*/ ;
                var vertexOffset/*uint*/ ;

                //default values for particle param
                particleProperties.total = numParticles;
                particleProperties.startTime = 0;
                particleProperties.duration = 1000;
                particleProperties.delay = 0.1;

                i = 0;
                j = 0;
                while (i < numParticles) {
                    particleProperties.index = i;

                    //call the init on the particle parameters
                    this.initParticleFunc.call(this.initParticleScope, particleProperties);

                    for (k = 0; k < this._localStaticNodes.length; k++)
                        this._localStaticNodes[k]._iGeneratePropertyOfOneParticle(particleProperties);

                    while (j < particlesLength && (particle = particles[j]).particleIndex == i) {
                        for (k = 0; k < mesh.subMeshes.length; k++) {
                            subMesh = mesh.subMeshes[k];
                            if (subMesh.subGeometry == particle.subGeometry) {
                                animationSubGeometry = subMesh.animationSubGeometry;
                                break;
                            }
                        }
                        numVertices = particle.numVertices;
                        vertexData = animationSubGeometry.vertexData;
                        vertexLength = numVertices * this._totalLenOfOneVertex;
                        startingOffset = animationSubGeometry.numProcessedVertices * this._totalLenOfOneVertex;

                        for (k = 0; k < this._localStaticNodes.length; k++) {
                            localNode = this._localStaticNodes[k];
                            oneData = localNode.oneData;
                            oneDataLen = localNode.dataLength;
                            oneDataOffset = startingOffset + localNode._iDataOffset;

                            for (counterForVertex = 0; counterForVertex < vertexLength; counterForVertex += this._totalLenOfOneVertex) {
                                vertexOffset = oneDataOffset + counterForVertex;

                                for (counterForOneData = 0; counterForOneData < oneDataLen; counterForOneData++)
                                    vertexData[vertexOffset + counterForOneData] = oneData[counterForOneData];
                            }
                        }

                        if (this._localDynamicNodes.length)
                            animationSubGeometry.animationParticles.push(new animators.ParticleAnimationData(i, particleProperties.startTime, particleProperties.duration, particleProperties.delay, particle));

                        animationSubGeometry.numProcessedVertices += numVertices;

                        //next index
                        j++;
                    }

                    //next particle
                    i++;
                }
            };
            ParticleAnimationSet.POST_PRIORITY = 9;

            ParticleAnimationSet.COLOR_PRIORITY = 18;
            return ParticleAnimationSet;
        })(animators.AnimationSetBase);
        animators.ParticleAnimationSet = ParticleAnimationSet;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (animators) {
        
        var SubMesh = away.base.SubMesh;
        var StageGL = away.base.StageGL;
        var Camera = away.entities.Camera;
        var Vector3D = away.geom.Vector3D;
        var ContextGLProgramType = away.gl.ContextGLProgramType;
        var ContextGLVertexBufferFormat = away.gl.ContextGLVertexBufferFormat;
        var MaterialPassBase = away.materials.MaterialPassBase;
        var RenderableBase = away.pool.RenderableBase;

        /**
        * Provides an interface for assigning paricle-based animation data sets to mesh-based entity objects
        * and controlling the various available states of animation through an interative playhead that can be
        * automatically updated or manually triggered.
        *
        * Requires that the containing geometry of the parent mesh is particle geometry
        *
        * @see away.base.ParticleGeometry
        */
        var ParticleAnimator = (function (_super) {
            __extends(ParticleAnimator, _super);
            /**
            * Creates a new <code>ParticleAnimator</code> object.
            *
            * @param particleAnimationSet The animation data set containing the particle animations used by the animator.
            */
            function ParticleAnimator(particleAnimationSet) {
                _super.call(this, particleAnimationSet);
                this._animationParticleStates = new Array();
                this._animatorParticleStates = new Array();
                this._timeParticleStates = new Array();
                this._totalLenOfOneVertex = 0;
                this._animatorSubGeometries = new Object();
                this._particleAnimationSet = particleAnimationSet;

                var state;
                var node;

                for (var i = 0; i < this._particleAnimationSet.particleNodes.length; i++) {
                    node = this._particleAnimationSet.particleNodes[i];
                    state = this.getAnimationState(node);
                    if (node.mode == animators.ParticlePropertiesMode.LOCAL_DYNAMIC) {
                        this._animatorParticleStates.push(state);
                        node._iDataOffset = this._totalLenOfOneVertex;
                        this._totalLenOfOneVertex += node.dataLength;
                    } else
                        this._animationParticleStates.push(state);
                    if (state.needUpdateTime)
                        this._timeParticleStates.push(state);
                }
            }
            /**
            * @inheritDoc
            */
            ParticleAnimator.prototype.clone = function () {
                return new ParticleAnimator(this._particleAnimationSet);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimator.prototype.setRenderState = function (stageGL, renderable, vertexConstantOffset/*int*/ , vertexStreamOffset/*int*/ , camera) {
                var animationRegisterCache = this._particleAnimationSet._iAnimationRegisterCache;

                var subMesh = (renderable).subMesh;
                var state;
                var i;

                if (!subMesh)
                    throw (new Error("Must be subMesh"));

                if (!subMesh.animationSubGeometry)
                    this._particleAnimationSet._iGenerateAnimationSubGeometries(renderable.sourceEntity);

                var animationSubGeometry = subMesh.animationSubGeometry;

                for (i = 0; i < this._animationParticleStates.length; i++)
                    this._animationParticleStates[i].setRenderState(stageGL, renderable, animationSubGeometry, animationRegisterCache, camera);

                if (!subMesh.animatorSubGeometry && this._animatorParticleStates.length)
                    this.generateAnimatorSubGeometry(subMesh);

                var animatorSubGeometry = subMesh.animatorSubGeometry;

                for (i = 0; i < this._animatorParticleStates.length; i++)
                    this._animatorParticleStates[i].setRenderState(stageGL, renderable, animatorSubGeometry, animationRegisterCache, camera);

                stageGL.contextGL.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, animationRegisterCache.vertexConstantOffset, animationRegisterCache.vertexConstantData, animationRegisterCache.numVertexConstant);

                if (animationRegisterCache.numFragmentConstant > 0)
                    stageGL.contextGL.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, animationRegisterCache.fragmentConstantOffset, animationRegisterCache.fragmentConstantData, animationRegisterCache.numFragmentConstant);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimator.prototype.testGPUCompatibility = function (pass) {
            };

            /**
            * @inheritDoc
            */
            ParticleAnimator.prototype.start = function () {
                _super.prototype.start.call(this);

                for (var i = 0; i < this._timeParticleStates.length; i++)
                    this._timeParticleStates[i].offset(this._pAbsoluteTime);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimator.prototype._pUpdateDeltaTime = function (dt) {
                this._pAbsoluteTime += dt;

                for (var i = 0; i < this._timeParticleStates.length; i++)
                    this._timeParticleStates[i].update(this._pAbsoluteTime);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimator.prototype.resetTime = function (offset) {
                if (typeof offset === "undefined") { offset = 0; }
                for (var i = 0; i < this._timeParticleStates.length; i++)
                    this._timeParticleStates[i].offset(this._pAbsoluteTime + offset);
                this.update(this.time);
            };

            ParticleAnimator.prototype.dispose = function () {
                for (var key in this._animatorSubGeometries)
                    (this._animatorSubGeometries[key]).dispose();
            };

            ParticleAnimator.prototype.generateAnimatorSubGeometry = function (subMesh) {
                var subGeometry = subMesh.subGeometry;
                var animatorSubGeometry = subMesh.animatorSubGeometry = this._animatorSubGeometries[subGeometry.id] = new animators.AnimationSubGeometry();

                //create the vertexData vector that will be used for local state data
                animatorSubGeometry.createVertexData(subGeometry.numVertices, this._totalLenOfOneVertex);

                //pass the particles data to the animator subGeometry
                animatorSubGeometry.animationParticles = subMesh.animationSubGeometry.animationParticles;
            };
            return ParticleAnimator;
        })(animators.AnimatorBase);
        animators.ParticleAnimator = ParticleAnimator;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (animators) {
        var SkinnedSubGeometry = away.base.SkinnedSubGeometry;
        var SubMesh = away.base.SubMesh;
        var StageGL = away.base.StageGL;
        var Camera = away.entities.Camera;
        var AnimationStateEvent = away.events.AnimationStateEvent;
        var ContextGLProgramType = away.gl.ContextGLProgramType;
        var Quaternion = away.geom.Quaternion;
        var Vector3D = away.geom.Vector3D;
        var RenderableBase = away.pool.RenderableBase;
        var SubMeshRenderable = away.pool.SubMeshRenderable;
        var MaterialPassBase = away.materials.MaterialPassBase;

        /**
        * Provides an interface for assigning skeleton-based animation data sets to mesh-based entity objects
        * and controlling the various available states of animation through an interative playhead that can be
        * automatically updated or manually triggered.
        */
        var SkeletonAnimator = (function (_super) {
            __extends(SkeletonAnimator, _super);
            /**
            * Creates a new <code>SkeletonAnimator</code> object.
            *
            * @param skeletonAnimationSet The animation data set containing the skeleton animations used by the animator.
            * @param skeleton The skeleton object used for calculating the resulting global matrices for transforming skinned mesh data.
            * @param forceCPU Optional value that only allows the animator to perform calculation on the CPU. Defaults to false.
            */
            function SkeletonAnimator(animationSet, skeleton, forceCPU) {
                if (typeof forceCPU === "undefined") { forceCPU = false; }
                _super.call(this, animationSet);
                this._globalPose = new animators.SkeletonPose();
                this._subGeomAnimationStates = new Object();

                this._skeleton = skeleton;
                this._forceCPU = forceCPU;
                this._jointsPerVertex = animationSet.jointsPerVertex;

                this._numJoints = this._skeleton.numJoints;
                this._globalMatrices = new Array(this._numJoints * 12);

                var j = 0;
                for (var i = 0; i < this._numJoints; ++i) {
                    this._globalMatrices[j++] = 1;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 1;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 1;
                    this._globalMatrices[j++] = 0;
                }

                this._onTransitionCompleteDelegate = away.utils.Delegate.create(this, this.onTransitionComplete);
            }
            Object.defineProperty(SkeletonAnimator.prototype, "globalMatrices", {
                get: /**
                * returns the calculated global matrices of the current skeleton pose.
                *
                * @see #globalPose
                */
                function () {
                    if (this._globalPropertiesDirty)
                        this.updateGlobalProperties();

                    return this._globalMatrices;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkeletonAnimator.prototype, "globalPose", {
                get: /**
                * returns the current skeleton pose output from the animator.
                *
                * @see away.animators.data.SkeletonPose
                */
                function () {
                    if (this._globalPropertiesDirty)
                        this.updateGlobalProperties();

                    return this._globalPose;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkeletonAnimator.prototype, "skeleton", {
                get: /**
                * Returns the skeleton object in use by the animator - this defines the number and heirarchy of joints used by the
                * skinned geoemtry to which skeleon animator is applied.
                */
                function () {
                    return this._skeleton;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkeletonAnimator.prototype, "forceCPU", {
                get: /**
                * Indicates whether the skeleton animator is disabled by default for GPU rendering, something that allows the animator to perform calculation on the GPU.
                * Defaults to false.
                */
                function () {
                    return this._forceCPU;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkeletonAnimator.prototype, "useCondensedIndices", {
                get: /**
                * Offers the option of enabling GPU accelerated animation on skeletons larger than 32 joints
                * by condensing the number of joint index values required per mesh. Only applicable to
                * skeleton animations that utilise more than one mesh object. Defaults to false.
                */
                function () {
                    return this._useCondensedIndices;
                },
                set: function (value) {
                    this._useCondensedIndices = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SkeletonAnimator.prototype.clone = function () {
                /* The cast to SkeletonAnimationSet should never fail, as _animationSet can only be set
                through the constructor, which will only accept a SkeletonAnimationSet. */
                return new SkeletonAnimator(this._pAnimationSet, this._skeleton, this._forceCPU);
            };

            /**
            * Plays an animation state registered with the given name in the animation data set.
            *
            * @param name The data set name of the animation state to be played.
            * @param transition An optional transition object that determines how the animator will transition from the currently active animation state.
            * @param offset An option offset time (in milliseconds) that resets the state's internal clock to the absolute time of the animator plus the offset value. Required for non-looping animation states.
            */
            SkeletonAnimator.prototype.play = function (name, transition, offset) {
                if (typeof transition === "undefined") { transition = null; }
                if (typeof offset === "undefined") { offset = NaN; }
                if (this._pActiveAnimationName == name)
                    return;

                this._pActiveAnimationName = name;

                if (!this._pAnimationSet.hasAnimation(name))
                    throw new Error("Animation root node " + name + " not found!");

                if (transition && this._pActiveNode) {
                    //setup the transition
                    this._pActiveNode = transition.getAnimationNode(this, this._pActiveNode, this._pAnimationSet.getAnimation(name), this._pAbsoluteTime);
                    this._pActiveNode.addEventListener(AnimationStateEvent.TRANSITION_COMPLETE, this._onTransitionCompleteDelegate);
                } else
                    this._pActiveNode = this._pAnimationSet.getAnimation(name);

                this._pActiveState = this.getAnimationState(this._pActiveNode);

                if (this.updatePosition) {
                    //update straight away to reset position deltas
                    this._pActiveState.update(this._pAbsoluteTime);
                    this._pActiveState.positionDelta;
                }

                this._activeSkeletonState = this._pActiveState;

                this.start();

                if (!isNaN(offset))
                    this.reset(name, offset);
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimator.prototype.setRenderState = function (stageGL, renderable, vertexConstantOffset/*int*/ , vertexStreamOffset/*int*/ , camera) {
                if (this._globalPropertiesDirty)
                    this.updateGlobalProperties();

                var skinnedGeom = ((renderable).subMesh).subGeometry;

                // using condensed data
                var numCondensedJoints = skinnedGeom.numCondensedJoints;
                if (this._useCondensedIndices) {
                    if (skinnedGeom.numCondensedJoints == 0) {
                        skinnedGeom.iCondenseIndexData();
                        numCondensedJoints = skinnedGeom.numCondensedJoints;
                    }
                    this.updateCondensedMatrices(skinnedGeom.condensedIndexLookUp, numCondensedJoints);
                    stageGL.contextGL.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, vertexConstantOffset, this._condensedMatrices, numCondensedJoints * 3);
                } else {
                    if (this._pAnimationSet.usesCPU) {
                        var subGeomAnimState = this._subGeomAnimationStates[skinnedGeom.id];

                        if (subGeomAnimState == null)
                            subGeomAnimState = this._subGeomAnimationStates[skinnedGeom.id] = new SubGeomAnimationState(skinnedGeom);

                        if (subGeomAnimState.dirty) {
                            this.morphGeometry(subGeomAnimState, skinnedGeom);
                            subGeomAnimState.dirty = false;
                        }
                        skinnedGeom.updateAnimatedData(subGeomAnimState.animatedVertexData);
                        return;
                    }
                    stageGL.contextGL.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, vertexConstantOffset, this._globalMatrices, this._numJoints * 3);
                }

                skinnedGeom.activateJointIndexBuffer(vertexStreamOffset, stageGL);
                skinnedGeom.activateJointWeightsBuffer(vertexStreamOffset + 1, stageGL);
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimator.prototype.testGPUCompatibility = function (pass) {
                if (!this._useCondensedIndices && (this._forceCPU || this._jointsPerVertex > 4 || pass.numUsedVertexConstants + this._numJoints * 3 > 128))
                    this._pAnimationSet.cancelGPUCompatibility();
            };

            /**
            * Applies the calculated time delta to the active animation state node or state transition object.
            */
            SkeletonAnimator.prototype._pUpdateDeltaTime = function (dt) {
                _super.prototype._pUpdateDeltaTime.call(this, dt);

                //invalidate pose matrices
                this._globalPropertiesDirty = true;

                for (var key in this._subGeomAnimationStates)
                    (this._subGeomAnimationStates[key]).dirty = true;
            };

            SkeletonAnimator.prototype.updateCondensedMatrices = function (condensedIndexLookUp/*uint*/ , numJoints/*uint*/ ) {
                var i = 0, j = 0;
                var len/*uint*/ ;
                var srcIndex/*uint*/ ;

                this._condensedMatrices = new Array();

                do {
                    srcIndex = condensedIndexLookUp[i * 3] * 4;
                    len = srcIndex + 12;

                    while (srcIndex < len)
                        this._condensedMatrices[j++] = this._globalMatrices[srcIndex++];
                } while(++i < numJoints);
            };

            SkeletonAnimator.prototype.updateGlobalProperties = function () {
                this._globalPropertiesDirty = false;

                //get global pose
                this.localToGlobalPose(this._activeSkeletonState.getSkeletonPose(this._skeleton), this._globalPose, this._skeleton);

                // convert pose to matrix
                var mtxOffset = 0;
                var globalPoses = this._globalPose.jointPoses;
                var raw;
                var ox, oy, oz, ow;
                var xy2, xz2, xw2;
                var yz2, yw2, zw2;
                var n11, n12, n13;
                var n21, n22, n23;
                var n31, n32, n33;
                var m11, m12, m13, m14;
                var m21, m22, m23, m24;
                var m31, m32, m33, m34;
                var joints = this._skeleton.joints;
                var pose;
                var quat;
                var vec;
                var t;

                for (var i = 0; i < this._numJoints; ++i) {
                    pose = globalPoses[i];
                    quat = pose.orientation;
                    vec = pose.translation;
                    ox = quat.x;
                    oy = quat.y;
                    oz = quat.z;
                    ow = quat.w;

                    xy2 = (t = 2.0 * ox) * oy;
                    xz2 = t * oz;
                    xw2 = t * ow;
                    yz2 = (t = 2.0 * oy) * oz;
                    yw2 = t * ow;
                    zw2 = 2.0 * oz * ow;

                    yz2 = 2.0 * oy * oz;
                    yw2 = 2.0 * oy * ow;
                    zw2 = 2.0 * oz * ow;
                    ox *= ox;
                    oy *= oy;
                    oz *= oz;
                    ow *= ow;

                    n11 = (t = ox - oy) - oz + ow;
                    n12 = xy2 - zw2;
                    n13 = xz2 + yw2;
                    n21 = xy2 + zw2;
                    n22 = -t - oz + ow;
                    n23 = yz2 - xw2;
                    n31 = xz2 - yw2;
                    n32 = yz2 + xw2;
                    n33 = -ox - oy + oz + ow;

                    // prepend inverse bind pose
                    raw = joints[i].inverseBindPose;
                    m11 = raw[0];
                    m12 = raw[4];
                    m13 = raw[8];
                    m14 = raw[12];
                    m21 = raw[1];
                    m22 = raw[5];
                    m23 = raw[9];
                    m24 = raw[13];
                    m31 = raw[2];
                    m32 = raw[6];
                    m33 = raw[10];
                    m34 = raw[14];

                    this._globalMatrices[mtxOffset] = n11 * m11 + n12 * m21 + n13 * m31;
                    this._globalMatrices[mtxOffset + 1] = n11 * m12 + n12 * m22 + n13 * m32;
                    this._globalMatrices[mtxOffset + 2] = n11 * m13 + n12 * m23 + n13 * m33;
                    this._globalMatrices[mtxOffset + 3] = n11 * m14 + n12 * m24 + n13 * m34 + vec.x;
                    this._globalMatrices[mtxOffset + 4] = n21 * m11 + n22 * m21 + n23 * m31;
                    this._globalMatrices[mtxOffset + 5] = n21 * m12 + n22 * m22 + n23 * m32;
                    this._globalMatrices[mtxOffset + 6] = n21 * m13 + n22 * m23 + n23 * m33;
                    this._globalMatrices[mtxOffset + 7] = n21 * m14 + n22 * m24 + n23 * m34 + vec.y;
                    this._globalMatrices[mtxOffset + 8] = n31 * m11 + n32 * m21 + n33 * m31;
                    this._globalMatrices[mtxOffset + 9] = n31 * m12 + n32 * m22 + n33 * m32;
                    this._globalMatrices[mtxOffset + 10] = n31 * m13 + n32 * m23 + n33 * m33;
                    this._globalMatrices[mtxOffset + 11] = n31 * m14 + n32 * m24 + n33 * m34 + vec.z;

                    mtxOffset = mtxOffset + 12;
                }
            };

            /**
            * If the animation can't be performed on GPU, transform vertices manually
            * @param subGeom The subgeometry containing the weights and joint index data per vertex.
            * @param pass The material pass for which we need to transform the vertices
            */
            SkeletonAnimator.prototype.morphGeometry = function (state, subGeom) {
                var vertexData = subGeom.vertexData;
                var targetData = state.animatedVertexData;
                var jointIndices = subGeom.iJointIndexData;
                var jointWeights = subGeom.iJointWeightsData;
                var index = 0;
                var j = 0;
                var k/*uint*/ ;
                var vx, vy, vz;
                var nx, ny, nz;
                var tx, ty, tz;
                var len = vertexData.length;
                var weight;
                var vertX, vertY, vertZ;
                var normX, normY, normZ;
                var tangX, tangY, tangZ;
                var m11, m12, m13, m14;
                var m21, m22, m23, m24;
                var m31, m32, m33, m34;

                while (index < len) {
                    vertX = vertexData[index];
                    vertY = vertexData[index + 1];
                    vertZ = vertexData[index + 2];
                    normX = vertexData[index + 3];
                    normY = vertexData[index + 4];
                    normZ = vertexData[index + 5];
                    tangX = vertexData[index + 6];
                    tangY = vertexData[index + 7];
                    tangZ = vertexData[index + 8];
                    vx = 0;
                    vy = 0;
                    vz = 0;
                    nx = 0;
                    ny = 0;
                    nz = 0;
                    tx = 0;
                    ty = 0;
                    tz = 0;
                    k = 0;
                    while (k < this._jointsPerVertex) {
                        weight = jointWeights[j];
                        if (weight > 0) {
                            // implicit /3*12 (/3 because indices are multiplied by 3 for gpu matrix access, *12 because it's the matrix size)
                            var mtxOffset = jointIndices[j++] << 2;
                            m11 = this._globalMatrices[mtxOffset];
                            m12 = this._globalMatrices[mtxOffset + 1];
                            m13 = this._globalMatrices[mtxOffset + 2];
                            m14 = this._globalMatrices[mtxOffset + 3];
                            m21 = this._globalMatrices[mtxOffset + 4];
                            m22 = this._globalMatrices[mtxOffset + 5];
                            m23 = this._globalMatrices[mtxOffset + 6];
                            m24 = this._globalMatrices[mtxOffset + 7];
                            m31 = this._globalMatrices[mtxOffset + 8];
                            m32 = this._globalMatrices[mtxOffset + 9];
                            m33 = this._globalMatrices[mtxOffset + 10];
                            m34 = this._globalMatrices[mtxOffset + 11];
                            vx += weight * (m11 * vertX + m12 * vertY + m13 * vertZ + m14);
                            vy += weight * (m21 * vertX + m22 * vertY + m23 * vertZ + m24);
                            vz += weight * (m31 * vertX + m32 * vertY + m33 * vertZ + m34);
                            nx += weight * (m11 * normX + m12 * normY + m13 * normZ);
                            ny += weight * (m21 * normX + m22 * normY + m23 * normZ);
                            nz += weight * (m31 * normX + m32 * normY + m33 * normZ);
                            tx += weight * (m11 * tangX + m12 * tangY + m13 * tangZ);
                            ty += weight * (m21 * tangX + m22 * tangY + m23 * tangZ);
                            tz += weight * (m31 * tangX + m32 * tangY + m33 * tangZ);
                            ++k;
                        } else {
                            j += (this._jointsPerVertex - k);
                            k = this._jointsPerVertex;
                        }
                    }

                    targetData[index] = vx;
                    targetData[index + 1] = vy;
                    targetData[index + 2] = vz;
                    targetData[index + 3] = nx;
                    targetData[index + 4] = ny;
                    targetData[index + 5] = nz;
                    targetData[index + 6] = tx;
                    targetData[index + 7] = ty;
                    targetData[index + 8] = tz;

                    index = index + 13;
                }
            };

            /**
            * Converts a local hierarchical skeleton pose to a global pose
            * @param targetPose The SkeletonPose object that will contain the global pose.
            * @param skeleton The skeleton containing the joints, and as such, the hierarchical data to transform to global poses.
            */
            SkeletonAnimator.prototype.localToGlobalPose = function (sourcePose, targetPose, skeleton) {
                var globalPoses = targetPose.jointPoses;
                var globalJointPose;
                var joints = skeleton.joints;
                var len = sourcePose.numJointPoses;
                var jointPoses = sourcePose.jointPoses;
                var parentIndex/*int*/ ;
                var joint;
                var parentPose;
                var pose;
                var or;
                var tr;
                var t;
                var q;

                var x1, y1, z1, w1;
                var x2, y2, z2, w2;
                var x3, y3, z3;

                if (globalPoses.length != len)
                    globalPoses.length = len;

                for (var i = 0; i < len; ++i) {
                    globalJointPose = globalPoses[i];

                    if (globalJointPose == null)
                        globalJointPose = globalPoses[i] = new animators.JointPose();

                    joint = joints[i];
                    parentIndex = joint.parentIndex;
                    pose = jointPoses[i];

                    q = globalJointPose.orientation;
                    t = globalJointPose.translation;

                    if (parentIndex < 0) {
                        tr = pose.translation;
                        or = pose.orientation;
                        q.x = or.x;
                        q.y = or.y;
                        q.z = or.z;
                        q.w = or.w;
                        t.x = tr.x;
                        t.y = tr.y;
                        t.z = tr.z;
                    } else {
                        // append parent pose
                        parentPose = globalPoses[parentIndex];

                        // rotate point
                        or = parentPose.orientation;
                        tr = pose.translation;
                        x2 = or.x;
                        y2 = or.y;
                        z2 = or.z;
                        w2 = or.w;
                        x3 = tr.x;
                        y3 = tr.y;
                        z3 = tr.z;

                        w1 = -x2 * x3 - y2 * y3 - z2 * z3;
                        x1 = w2 * x3 + y2 * z3 - z2 * y3;
                        y1 = w2 * y3 - x2 * z3 + z2 * x3;
                        z1 = w2 * z3 + x2 * y3 - y2 * x3;

                        // append parent translation
                        tr = parentPose.translation;
                        t.x = -w1 * x2 + x1 * w2 - y1 * z2 + z1 * y2 + tr.x;
                        t.y = -w1 * y2 + x1 * z2 + y1 * w2 - z1 * x2 + tr.y;
                        t.z = -w1 * z2 - x1 * y2 + y1 * x2 + z1 * w2 + tr.z;

                        // append parent orientation
                        x1 = or.x;
                        y1 = or.y;
                        z1 = or.z;
                        w1 = or.w;
                        or = pose.orientation;
                        x2 = or.x;
                        y2 = or.y;
                        z2 = or.z;
                        w2 = or.w;

                        q.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
                        q.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
                        q.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
                        q.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
                    }
                }
            };

            SkeletonAnimator.prototype.onTransitionComplete = function (event) {
                if (event.type == AnimationStateEvent.TRANSITION_COMPLETE) {
                    event.animationNode.removeEventListener(AnimationStateEvent.TRANSITION_COMPLETE, this._onTransitionCompleteDelegate);

                    if (this._pActiveState == event.animationState) {
                        this._pActiveNode = this._pAnimationSet.getAnimation(this._pActiveAnimationName);
                        this._pActiveState = this.getAnimationState(this._pActiveNode);
                        this._activeSkeletonState = this._pActiveState;
                    }
                }
            };
            return SkeletonAnimator;
        })(animators.AnimatorBase);
        animators.SkeletonAnimator = SkeletonAnimator;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));

var CompactSubGeometry = away.base.CompactSubGeometry;

var SubGeomAnimationState = (function () {
    function SubGeomAnimationState(subGeom) {
        this.dirty = true;
        this.animatedVertexData = subGeom.vertexData.concat();
    }
    return SubGeomAnimationState;
})();
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (animators) {
        var ContextGL = away.gl.ContextGL;
        var StageGL = away.base.StageGL;
        var MaterialPassBase = away.materials.MaterialPassBase;

        /**
        * The animation data set used by skeleton-based animators, containing skeleton animation data.
        *
        * @see away.animators.SkeletonAnimator
        */
        var SkeletonAnimationSet = (function (_super) {
            __extends(SkeletonAnimationSet, _super);
            /**
            * Creates a new <code>SkeletonAnimationSet</code> object.
            *
            * @param jointsPerVertex Sets the amount of skeleton joints that can be linked to a single vertex via skinned weight values. For GPU-base animation, the maximum allowed value is 4. Defaults to 4.
            */
            function SkeletonAnimationSet(jointsPerVertex) {
                if (typeof jointsPerVertex === "undefined") { jointsPerVertex = 4; }
                _super.call(this);

                this._jointsPerVertex = jointsPerVertex;
            }
            Object.defineProperty(SkeletonAnimationSet.prototype, "jointsPerVertex", {
                get: /**
                * Returns the amount of skeleton joints that can be linked to a single vertex via skinned weight values. For GPU-base animation, the
                * maximum allowed value is 4.
                */
                function () {
                    return this._jointsPerVertex;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SkeletonAnimationSet.prototype.getAGALVertexCode = function (pass, sourceRegisters, targetRegisters, profile) {
                var len = sourceRegisters.length;

                var indexOffset0 = pass.numUsedVertexConstants;
                var indexOffset1 = indexOffset0 + 1;
                var indexOffset2 = indexOffset0 + 2;
                var indexStream = "va" + pass.numUsedStreams;
                var weightStream = "va" + (pass.numUsedStreams + 1);
                var indices = [indexStream + ".x", indexStream + ".y", indexStream + ".z", indexStream + ".w"];
                var weights = [weightStream + ".x", weightStream + ".y", weightStream + ".z", weightStream + ".w"];
                var temp1 = this._pFindTempReg(targetRegisters);
                var temp2 = this._pFindTempReg(targetRegisters, temp1);
                var dot = "dp4";
                var code = "";

                for (var i = 0; i < len; ++i) {
                    var src = sourceRegisters[i];

                    for (var j = 0; j < this._jointsPerVertex; ++j) {
                        code += dot + " " + temp1 + ".x, " + src + ", vc[" + indices[j] + "+" + indexOffset0 + "]		\n" + dot + " " + temp1 + ".y, " + src + ", vc[" + indices[j] + "+" + indexOffset1 + "]    	\n" + dot + " " + temp1 + ".z, " + src + ", vc[" + indices[j] + "+" + indexOffset2 + "]		\n" + "mov " + temp1 + ".w, " + src + ".w		\n" + "mul " + temp1 + ", " + temp1 + ", " + weights[j] + "\n";

                        if (j == 0)
                            code += "mov " + temp2 + ", " + temp1 + "\n";
else
                            code += "add " + temp2 + ", " + temp2 + ", " + temp1 + "\n";
                    }

                    // switch to dp3 once positions have been transformed, from now on, it should only be vectors instead of points
                    dot = "dp3";
                    code += "mov " + targetRegisters[i] + ", " + temp2 + "\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimationSet.prototype.activate = function (stageGL, pass) {
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimationSet.prototype.deactivate = function (stageGL, pass) {
                var streamOffset = pass.numUsedStreams;
                var context = stageGL.contextGL;
                context.setVertexBufferAt(streamOffset, null);
                context.setVertexBufferAt(streamOffset + 1, null);
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimationSet.prototype.getAGALFragmentCode = function (pass, shadedTarget, profile) {
                return "";
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimationSet.prototype.getAGALUVCode = function (pass, UVSource, UVTarget) {
                return "mov " + UVTarget + "," + UVSource + "\n";
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimationSet.prototype.doneAGALCode = function (pass) {
            };
            return SkeletonAnimationSet;
        })(animators.AnimationSetBase);
        animators.SkeletonAnimationSet = SkeletonAnimationSet;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (animators) {
        /**
        * The animation data set used by vertex-based animators, containing vertex animation state data.
        *
        * @see away.animators.VertexAnimator
        */
        var VertexAnimationSet = (function (_super) {
            __extends(VertexAnimationSet, _super);
            /**
            * Creates a new <code>VertexAnimationSet</code> object.
            *
            * @param numPoses The number of poses made available at once to the GPU animation code.
            * @param blendMode Optional value for setting the animation mode of the vertex animator object.
            *
            * @see away3d.animators.data.VertexAnimationMode
            */
            function VertexAnimationSet(numPoses, blendMode) {
                if (typeof numPoses === "undefined") { numPoses = 2; }
                if (typeof blendMode === "undefined") { blendMode = "absolute"; }
                _super.call(this);
                this._streamIndices = new Object();
                this._useNormals = new Object();
                this._useTangents = new Object();
                this._numPoses = numPoses;
                this._blendMode = blendMode;
            }
            Object.defineProperty(VertexAnimationSet.prototype, "numPoses", {
                get: /**
                * Returns the number of poses made available at once to the GPU animation code.
                */
                function () {
                    return this._numPoses;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(VertexAnimationSet.prototype, "blendMode", {
                get: /**
                * Returns the active blend mode of the vertex animator object.
                */
                function () {
                    return this._blendMode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(VertexAnimationSet.prototype, "useNormals", {
                get: /**
                * Returns whether or not normal data is used in last set GPU pass of the vertex shader.
                */
                function () {
                    return this._uploadNormals;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.getAGALVertexCode = function (pass, sourceRegisters, targetRegisters, profile) {
                if (this._blendMode == away.animators.VertexAnimationMode.ABSOLUTE)
                    return this.getAbsoluteAGALCode(pass, sourceRegisters, targetRegisters);
else
                    return this.getAdditiveAGALCode(pass, sourceRegisters, targetRegisters);
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.activate = function (stageGL, pass) {
                var uID = pass._iUniqueId;
                this._uploadNormals = this._useNormals[uID];
                this._uploadTangents = this._useTangents[uID];
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.deactivate = function (stageGL, pass) {
                var uID = pass._iUniqueId;
                var index = this._streamIndices[uID];
                var context = stageGL.contextGL;
                context.setVertexBufferAt(index, null);
                if (this._uploadNormals)
                    context.setVertexBufferAt(index + 1, null);
                if (this._uploadTangents)
                    context.setVertexBufferAt(index + 2, null);
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.getAGALFragmentCode = function (pass, shadedTarget, profile) {
                return "";
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.getAGALUVCode = function (pass, UVSource, UVTarget) {
                return "mov " + UVTarget + "," + UVSource + "\n";
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.doneAGALCode = function (pass) {
            };

            /**
            * Generates the vertex AGAL code for absolute blending.
            */
            VertexAnimationSet.prototype.getAbsoluteAGALCode = function (pass, sourceRegisters, targetRegisters) {
                var code = "";
                var uID = pass._iUniqueId;
                var temp1 = this._pFindTempReg(targetRegisters);
                var temp2 = this._pFindTempReg(targetRegisters, temp1);
                var regs = new Array("x", "y", "z", "w");
                var len = sourceRegisters.length;
                var constantReg = "vc" + pass.numUsedVertexConstants;
                var useTangents = this._useTangents[uID] = (len > 2);
                this._useNormals[uID] = (len > 1);

                if (len > 2)
                    len = 2;
                var streamIndex = this._streamIndices[uID] = pass.numUsedStreams;

                for (var i = 0; i < len; ++i) {
                    code += "mul " + temp1 + ", " + sourceRegisters[i] + ", " + constantReg + "." + regs[0] + "\n";

                    for (var j = 1; j < this._numPoses; ++j) {
                        code += "mul " + temp2 + ", va" + streamIndex + ", " + constantReg + "." + regs[j] + "\n";

                        if (j < this._numPoses - 1)
                            code += "add " + temp1 + ", " + temp1 + ", " + temp2 + "\n";

                        ++streamIndex;
                    }

                    code += "add " + targetRegisters[i] + ", " + temp1 + ", " + temp2 + "\n";
                }

                if (useTangents) {
                    code += "dp3 " + temp1 + ".x, " + sourceRegisters[2] + ", " + targetRegisters[1] + "\n" + "mul " + temp1 + ", " + targetRegisters[1] + ", " + temp1 + ".x			 \n" + "sub " + targetRegisters[2] + ", " + sourceRegisters[2] + ", " + temp1 + "\n";
                }
                return code;
            };

            /**
            * Generates the vertex AGAL code for additive blending.
            */
            VertexAnimationSet.prototype.getAdditiveAGALCode = function (pass, sourceRegisters, targetRegisters) {
                var code = "";
                var uID = pass._iUniqueId;
                var len = sourceRegisters.length;
                var regs = ["x", "y", "z", "w"];
                var temp1 = this._pFindTempReg(targetRegisters);
                var k/*uint*/ ;
                var useTangents = this._useTangents[uID] = (len > 2);
                var useNormals = this._useNormals[uID] = (len > 1);
                var streamIndex = this._streamIndices[uID] = pass.numUsedStreams;

                if (len > 2)
                    len = 2;

                code += "mov  " + targetRegisters[0] + ", " + sourceRegisters[0] + "\n";
                if (useNormals)
                    code += "mov " + targetRegisters[1] + ", " + sourceRegisters[1] + "\n";

                for (var i = 0; i < len; ++i) {
                    for (var j = 0; j < this._numPoses; ++j) {
                        code += "mul " + temp1 + ", va" + (streamIndex + k) + ", vc" + pass.numUsedVertexConstants + "." + regs[j] + "\n" + "add " + targetRegisters[i] + ", " + targetRegisters[i] + ", " + temp1 + "\n";
                        k++;
                    }
                }

                if (useTangents) {
                    code += "dp3 " + temp1 + ".x, " + sourceRegisters[2] + ", " + targetRegisters[1] + "\n" + "mul " + temp1 + ", " + targetRegisters[1] + ", " + temp1 + ".x			 \n" + "sub " + targetRegisters[2] + ", " + sourceRegisters[2] + ", " + temp1 + "\n";
                }

                return code;
            };
            return VertexAnimationSet;
        })(animators.AnimationSetBase);
        animators.VertexAnimationSet = VertexAnimationSet;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (animators) {
        
        var SubMesh = away.base.SubMesh;
        var Geometry = away.base.Geometry;
        var StageGL = away.base.StageGL;
        var RenderableBase = away.pool.RenderableBase;
        var SubMeshRenderable = away.pool.SubMeshRenderable;

        /**
        * Provides an interface for assigning vertex-based animation data sets to mesh-based entity objects
        * and controlling the various available states of animation through an interative playhead that can be
        * automatically updated or manually triggered.
        */
        var VertexAnimator = (function (_super) {
            __extends(VertexAnimator, _super);
            /**
            * Creates a new <code>VertexAnimator</code> object.
            *
            * @param vertexAnimationSet The animation data set containing the vertex animations used by the animator.
            */
            function VertexAnimator(vertexAnimationSet) {
                _super.call(this, vertexAnimationSet);
                this._poses = new Array();
                this._weights = Array(1, 0, 0, 0);

                this._vertexAnimationSet = vertexAnimationSet;
                this._numPoses = vertexAnimationSet.numPoses;
                this._blendMode = vertexAnimationSet.blendMode;
            }
            /**
            * @inheritDoc
            */
            VertexAnimator.prototype.clone = function () {
                return new VertexAnimator(this._vertexAnimationSet);
            };

            /**
            * Plays a sequence with a given name. If the sequence is not found, it may not be loaded yet, and it will retry every frame.
            * @param sequenceName The name of the clip to be played.
            */
            VertexAnimator.prototype.play = function (name, transition, offset) {
                if (typeof transition === "undefined") { transition = null; }
                if (typeof offset === "undefined") { offset = NaN; }
                if (this._pActiveAnimationName == name)
                    return;

                this._pActiveAnimationName = name;

                if (!this._pAnimationSet.hasAnimation(name))
                    throw new Error("Animation root node " + name + " not found!");

                this._pActiveNode = this._pAnimationSet.getAnimation(name);

                this._pActiveState = this.getAnimationState(this._pActiveNode);

                if (this.updatePosition) {
                    //update straight away to reset position deltas
                    this._pActiveState.update(this._pAbsoluteTime);
                    this._pActiveState.positionDelta;
                }

                this._activeVertexState = this._pActiveState;

                this.start();

                if (!isNaN(offset))
                    this.reset(name, offset);
            };

            /**
            * @inheritDoc
            */
            VertexAnimator.prototype._pUpdateDeltaTime = function (dt) {
                _super.prototype._pUpdateDeltaTime.call(this, dt);

                this._poses[0] = this._activeVertexState.currentGeometry;
                this._poses[1] = this._activeVertexState.nextGeometry;
                this._weights[0] = 1 - (this._weights[1] = this._activeVertexState.blendWeight);
            };

            /**
            * @inheritDoc
            */
            VertexAnimator.prototype.setRenderState = function (stageGL, renderable, vertexConstantOffset/*int*/ , vertexStreamOffset/*int*/ , camera) {
                if (!this._poses.length) {
                    this.setNullPose(stageGL, renderable, vertexConstantOffset, vertexStreamOffset);
                    return;
                }

                // this type of animation can only be SubMesh
                var subMesh = (renderable).subMesh;
                var subGeom;
                var i/*uint*/ ;
                var len = this._numPoses;

                stageGL.contextGL.setProgramConstantsFromArray(away.gl.ContextGLProgramType.VERTEX, vertexConstantOffset, this._weights, 1);

                if (this._blendMode == animators.VertexAnimationMode.ABSOLUTE) {
                    i = 1;
                    subGeom = this._poses[0].subGeometries[subMesh._iIndex];

                    if (subGeom)
                        renderable.subGeometry = subGeom;
                } else
                    i = 0;

                for (; i < len; ++i) {
                    subGeom = this._poses[i].subGeometries[subMesh._iIndex] || renderable.subGeometry;

                    subGeom.activateVertexBuffer(vertexStreamOffset++, stageGL);

                    if (this._vertexAnimationSet.useNormals)
                        subGeom.activateVertexNormalBuffer(vertexStreamOffset++, stageGL);
                }
            };

            VertexAnimator.prototype.setNullPose = function (stageGL, renderable, vertexConstantOffset/*int*/ , vertexStreamOffset/*int*/ ) {
                stageGL.contextGL.setProgramConstantsFromArray(away.gl.ContextGLProgramType.VERTEX, vertexConstantOffset, this._weights, 1);

                if (this._blendMode == animators.VertexAnimationMode.ABSOLUTE) {
                    var len = this._numPoses;
                    for (var i = 1; i < len; ++i) {
                        renderable.subGeometry.activateVertexBuffer(vertexStreamOffset++, stageGL);

                        if (this._vertexAnimationSet.useNormals)
                            renderable.subGeometry.activateVertexNormalBuffer(vertexStreamOffset++, stageGL);
                    }
                }
                // todo: set temp data for additive?
            };

            /**
            * Verifies if the animation will be used on cpu. Needs to be true for all passes for a material to be able to use it on gpu.
            * Needs to be called if gpu code is potentially required.
            */
            VertexAnimator.prototype.testGPUCompatibility = function (pass) {
            };
            return VertexAnimator;
        })(animators.AnimatorBase);
        animators.VertexAnimator = VertexAnimator;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (parsers) {
        var Mesh = away.entities.Mesh;
        var DefaultMaterialManager = away.materials.DefaultMaterialManager;
        var BasicSpecularMethod = away.materials.BasicSpecularMethod;
        var ColorMaterial = away.materials.ColorMaterial;
        var ColorMultiPassMaterial = away.materials.ColorMultiPassMaterial;
        var MaterialBase = away.materials.MaterialBase;
        var TextureMaterial = away.materials.TextureMaterial;
        var TextureMultiPassMaterial = away.materials.TextureMultiPassMaterial;
        var URLLoaderDataFormat = away.net.URLLoaderDataFormat;

        /**
        * OBJParser provides a parser for the OBJ data type.
        */
        var OBJParser = (function (_super) {
            __extends(OBJParser, _super);
            /**
            * Creates a new OBJParser object.
            * @param uri The url or id of the data or file to be parsed.
            * @param extra The holder for extra contextual data that the parser might need.
            */
            function OBJParser(scale) {
                if (typeof scale === "undefined") { scale = 1; }
                _super.call(this, URLLoaderDataFormat.TEXT);
                this._mtlLibLoaded = true;
                this._activeMaterialID = "";
                this._scale = scale;
            }
            Object.defineProperty(OBJParser.prototype, "scale", {
                set: /**
                * Scaling factor applied directly to vertices data
                * @param value The scaling factor.
                */
                function (value) {
                    this._scale = value;
                },
                enumerable: true,
                configurable: true
            });

            OBJParser.supportsType = /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            function (extension) {
                extension = extension.toLowerCase();
                return extension == "obj";
            };

            OBJParser.supportsData = /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            function (data) {
                var content = parsers.ParserUtils.toString(data);
                var hasV = false;
                var hasF = false;

                if (content) {
                    hasV = content.indexOf("\nv ") != -1;
                    hasF = content.indexOf("\nf ") != -1;
                }

                return hasV && hasF;
            };

            /**
            * @inheritDoc
            */
            OBJParser.prototype._iResolveDependency = function (resourceDependency) {
                if (resourceDependency.id == 'mtl') {
                    var str = parsers.ParserUtils.toString(resourceDependency.data);
                    this.parseMtl(str);
                } else {
                    var asset;

                    if (resourceDependency.assets.length != 1) {
                        return;
                    }

                    asset = resourceDependency.assets[0];

                    if (asset.assetType == away.library.AssetType.TEXTURE) {
                        var lm = new LoadedMaterial();
                        lm.materialID = resourceDependency.id;
                        lm.texture = asset;

                        this._materialLoaded.push(lm);

                        if (this._meshes.length > 0) {
                            this.applyMaterial(lm);
                        }
                    }
                }
            };

            /**
            * @inheritDoc
            */
            OBJParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
                if (resourceDependency.id == "mtl") {
                    this._mtlLib = false;
                    this._mtlLibLoaded = false;
                } else {
                    var lm = new LoadedMaterial();
                    lm.materialID = resourceDependency.id;
                    this._materialLoaded.push(lm);
                }

                if (this._meshes.length > 0)
                    this.applyMaterial(lm);
            };

            /**
            * @inheritDoc
            */
            OBJParser.prototype._pProceedParsing = function () {
                var line;
                var creturn = String.fromCharCode(10);
                var trunk;

                if (!this._startedParsing) {
                    this._textData = this._pGetTextData();

                    // Merge linebreaks that are immediately preceeded by
                    // the "escape" backward slash into single lines.
                    this._textData = this._textData.replace(/\\[\r\n]+\s*/gm, ' ');
                }

                if (this._textData.indexOf(creturn) == -1)
                    creturn = String.fromCharCode(13);

                if (!this._startedParsing) {
                    this._startedParsing = true;
                    this._vertices = new Array();
                    this._vertexNormals = new Array();
                    this._materialIDs = new Array();
                    this._materialLoaded = new Array();
                    this._meshes = new Array();
                    this._uvs = new Array();
                    this._stringLength = this._textData.length;
                    this._charIndex = this._textData.indexOf(creturn, 0);
                    this._oldIndex = 0;
                    this._objects = new Array();
                    this._objectIndex = 0;
                }

                while (this._charIndex < this._stringLength && this._pHasTime()) {
                    this._charIndex = this._textData.indexOf(creturn, this._oldIndex);

                    if (this._charIndex == -1)
                        this._charIndex = this._stringLength;

                    line = this._textData.substring(this._oldIndex, this._charIndex);
                    line = line.split('\r').join("");
                    line = line.replace("  ", " ");
                    trunk = line.split(" ");
                    this._oldIndex = this._charIndex + 1;
                    this.parseLine(trunk);

                    if (this.parsingPaused) {
                        return parsers.ParserBase.MORE_TO_PARSE;
                    }
                }

                if (this._charIndex >= this._stringLength) {
                    if (this._mtlLib && !this._mtlLibLoaded) {
                        return parsers.ParserBase.MORE_TO_PARSE;
                    }

                    this.translate();
                    this.applyMaterials();

                    return parsers.ParserBase.PARSING_DONE;
                }

                return parsers.ParserBase.MORE_TO_PARSE;
            };

            /**
            * Parses a single line in the OBJ file.
            */
            OBJParser.prototype.parseLine = function (trunk) {
                switch (trunk[0]) {
                    case "mtllib":
                        this._mtlLib = true;
                        this._mtlLibLoaded = false;
                        this.loadMtl(trunk[1]);

                        break;

                    case "g":
                        this.createGroup(trunk);

                        break;

                    case "o":
                        this.createObject(trunk);

                        break;

                    case "usemtl":
                        if (this._mtlLib) {
                            if (!trunk[1])
                                trunk[1] = "def000";

                            this._materialIDs.push(trunk[1]);
                            this._activeMaterialID = trunk[1];

                            if (this._currentGroup)
                                this._currentGroup.materialID = this._activeMaterialID;
                        }

                        break;

                    case "v":
                        this.parseVertex(trunk);

                        break;

                    case "vt":
                        this.parseUV(trunk);

                        break;

                    case "vn":
                        this.parseVertexNormal(trunk);

                        break;

                    case "f":
                        this.parseFace(trunk);
                }
            };

            /**
            * Converts the parsed data into an Away3D scenegraph structure
            */
            OBJParser.prototype.translate = function () {
                for (var objIndex = 0; objIndex < this._objects.length; ++objIndex) {
                    var groups = this._objects[objIndex].groups;
                    var numGroups = groups.length;
                    var materialGroups;
                    var numMaterialGroups;
                    var geometry;
                    var mesh;

                    var m;
                    var sm;
                    var bmMaterial;

                    for (var g = 0; g < numGroups; ++g) {
                        geometry = new away.base.Geometry();
                        materialGroups = groups[g].materialGroups;
                        numMaterialGroups = materialGroups.length;

                        for (m = 0; m < numMaterialGroups; ++m)
                            this.translateMaterialGroup(materialGroups[m], geometry);

                        if (geometry.subGeometries.length == 0)
                            continue;

                        // Finalize and force type-based name
                        this._pFinalizeAsset(geometry);

                        if (this.materialMode < 2)
                            bmMaterial = new TextureMaterial(DefaultMaterialManager.getDefaultTexture());
else
                            bmMaterial = new TextureMultiPassMaterial(DefaultMaterialManager.getDefaultTexture());

                        //bmMaterial = new TextureMaterial(DefaultMaterialManager.getDefaultTexture());
                        mesh = new Mesh(geometry, bmMaterial);

                        if (this._objects[objIndex].name) {
                            // this is a full independent object ('o' tag in OBJ file)
                            mesh.name = this._objects[objIndex].name;
                        } else if (groups[g].name) {
                            // this is a group so the sub groups contain the actual mesh object names ('g' tag in OBJ file)
                            mesh.name = groups[g].name;
                        } else {
                            // No name stored. Use empty string which will force it
                            // to be overridden by finalizeAsset() to type default.
                            mesh.name = "";
                        }

                        this._meshes.push(mesh);

                        if (groups[g].materialID != "")
                            bmMaterial.name = groups[g].materialID + "~" + mesh.name;
else
                            bmMaterial.name = this._lastMtlID + "~" + mesh.name;

                        if (mesh.subMeshes.length > 1) {
                            for (sm = 1; sm < mesh.subMeshes.length; ++sm)
                                mesh.subMeshes[sm].material = bmMaterial;
                        }

                        this._pFinalizeAsset(mesh);
                    }
                }
            };

            /**
            * Translates an obj's material group to a subgeometry.
            * @param materialGroup The material group data to convert.
            * @param geometry The Geometry to contain the converted SubGeometry.
            */
            OBJParser.prototype.translateMaterialGroup = function (materialGroup, geometry) {
                var faces = materialGroup.faces;
                var face;
                var numFaces = faces.length;
                var numVerts;
                var subs;

                var vertices = new Array();
                var uvs = new Array();
                var normals = new Array();
                var indices = new Array();

                this._realIndices = [];
                this._vertexIndex = 0;

                var j;
                for (var i = 0; i < numFaces; ++i) {
                    face = faces[i];
                    numVerts = face.indexIds.length - 1;

                    for (j = 1; j < numVerts; ++j) {
                        this.translateVertexData(face, j, vertices, uvs, indices, normals);
                        this.translateVertexData(face, 0, vertices, uvs, indices, normals);
                        this.translateVertexData(face, j + 1, vertices, uvs, indices, normals);
                    }
                }
                if (vertices.length > 0) {
                    subs = away.utils.GeometryUtils.fromVectors(vertices, indices, uvs, normals, null, null, null);
                    for (i = 0; i < subs.length; i++) {
                        geometry.addSubGeometry(subs[i]);
                    }
                }
            };

            OBJParser.prototype.translateVertexData = function (face, vertexIndex, vertices, uvs, indices/*uint*/ , normals) {
                var index;
                var vertex;
                var vertexNormal;
                var uv;

                if (!this._realIndices[face.indexIds[vertexIndex]]) {
                    index = this._vertexIndex;
                    this._realIndices[face.indexIds[vertexIndex]] = ++this._vertexIndex;
                    vertex = this._vertices[face.vertexIndices[vertexIndex] - 1];
                    vertices.push(vertex.x * this._scale, vertex.y * this._scale, vertex.z * this._scale);

                    if (face.normalIndices.length > 0) {
                        vertexNormal = this._vertexNormals[face.normalIndices[vertexIndex] - 1];
                        normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
                    }

                    if (face.uvIndices.length > 0) {
                        try  {
                            uv = this._uvs[face.uvIndices[vertexIndex] - 1];
                            uvs.push(uv.u, uv.v);
                        } catch (e) {
                            switch (vertexIndex) {
                                case 0:
                                    uvs.push(0, 1);
                                    break;
                                case 1:
                                    uvs.push(.5, 0);
                                    break;
                                case 2:
                                    uvs.push(1, 1);
                            }
                        }
                    }
                } else {
                    index = this._realIndices[face.indexIds[vertexIndex]] - 1;
                }

                indices.push(index);
            };

            /**
            * Creates a new object group.
            * @param trunk The data block containing the object tag and its parameters
            */
            OBJParser.prototype.createObject = function (trunk) {
                this._currentGroup = null;
                this._currentMaterialGroup = null;
                this._objects.push(this._currentObject = new ObjectGroup());

                if (trunk)
                    this._currentObject.name = trunk[1];
            };

            /**
            * Creates a new group.
            * @param trunk The data block containing the group tag and its parameters
            */
            OBJParser.prototype.createGroup = function (trunk) {
                if (!this._currentObject)
                    this.createObject(null);
                this._currentGroup = new Group();

                this._currentGroup.materialID = this._activeMaterialID;

                if (trunk)
                    this._currentGroup.name = trunk[1];
                this._currentObject.groups.push(this._currentGroup);

                this.createMaterialGroup(null);
            };

            /**
            * Creates a new material group.
            * @param trunk The data block containing the material tag and its parameters
            */
            OBJParser.prototype.createMaterialGroup = function (trunk) {
                this._currentMaterialGroup = new MaterialGroup();
                if (trunk)
                    this._currentMaterialGroup.url = trunk[1];
                this._currentGroup.materialGroups.push(this._currentMaterialGroup);
            };

            /**
            * Reads the next vertex coordinates.
            * @param trunk The data block containing the vertex tag and its parameters
            */
            OBJParser.prototype.parseVertex = function (trunk) {
                //for the very rare cases of other delimiters/charcodes seen in some obj files
                var v1, v2, v3;
                if (trunk.length > 4) {
                    var nTrunk = [];
                    var val;

                    for (var i = 1; i < trunk.length; ++i) {
                        val = parseFloat(trunk[i]);
                        if (!isNaN(val))
                            nTrunk.push(val);
                    }

                    v1 = nTrunk[0];
                    v2 = nTrunk[1];
                    v3 = -nTrunk[2];
                    this._vertices.push(new Vertex(v1, v2, v3));
                } else {
                    v1 = parseFloat(trunk[1]);
                    v2 = parseFloat(trunk[2]);
                    v3 = -parseFloat(trunk[3]);

                    this._vertices.push(new Vertex(v1, v2, v3));
                }
            };

            /**
            * Reads the next uv coordinates.
            * @param trunk The data block containing the uv tag and its parameters
            */
            OBJParser.prototype.parseUV = function (trunk) {
                if (trunk.length > 3) {
                    var nTrunk = [];
                    var val;
                    for (var i = 1; i < trunk.length; ++i) {
                        val = parseFloat(trunk[i]);
                        if (!isNaN(val))
                            nTrunk.push(val);
                    }
                    this._uvs.push(new UV(nTrunk[0], 1 - nTrunk[1]));
                } else {
                    this._uvs.push(new UV(parseFloat(trunk[1]), 1 - parseFloat(trunk[2])));
                }
            };

            /**
            * Reads the next vertex normal coordinates.
            * @param trunk The data block containing the vertex normal tag and its parameters
            */
            OBJParser.prototype.parseVertexNormal = function (trunk) {
                if (trunk.length > 4) {
                    var nTrunk = [];
                    var val;
                    for (var i = 1; i < trunk.length; ++i) {
                        val = parseFloat(trunk[i]);
                        if (!isNaN(val))
                            nTrunk.push(val);
                    }
                    this._vertexNormals.push(new Vertex(nTrunk[0], nTrunk[1], -nTrunk[2]));
                } else {
                    this._vertexNormals.push(new Vertex(parseFloat(trunk[1]), parseFloat(trunk[2]), -parseFloat(trunk[3])));
                }
            };

            /**
            * Reads the next face's indices.
            * @param trunk The data block containing the face tag and its parameters
            */
            OBJParser.prototype.parseFace = function (trunk) {
                var len = trunk.length;
                var face = new FaceData();

                if (!this._currentGroup) {
                    this.createGroup(null);
                }

                var indices;
                for (var i = 1; i < len; ++i) {
                    if (trunk[i] == "") {
                        continue;
                    }

                    indices = trunk[i].split("/");
                    face.vertexIndices.push(this.parseIndex(parseInt(indices[0]), this._vertices.length));

                    if (indices[1] && String(indices[1]).length > 0)
                        face.uvIndices.push(this.parseIndex(parseInt(indices[1]), this._uvs.length));

                    if (indices[2] && String(indices[2]).length > 0)
                        face.normalIndices.push(this.parseIndex(parseInt(indices[2]), this._vertexNormals.length));

                    face.indexIds.push(trunk[i]);
                }

                this._currentMaterialGroup.faces.push(face);
            };

            /**
            * This is a hack around negative face coords
            */
            OBJParser.prototype.parseIndex = function (index, length) {
                if (index < 0)
                    return index + length + 1;
else
                    return index;
            };

            OBJParser.prototype.parseMtl = function (data) {
                var materialDefinitions = data.split('newmtl');
                var lines;
                var trunk;
                var j;

                var basicSpecularMethod;
                var useSpecular;
                var useColor;
                var diffuseColor;
                var ambientColor;
                var specularColor;
                var specular;
                var alpha;
                var mapkd;

                for (var i = 0; i < materialDefinitions.length; ++i) {
                    lines = (materialDefinitions[i].split('\r')).join("").split('\n');

                    if (lines.length == 1)
                        lines = materialDefinitions[i].split(String.fromCharCode(13));

                    diffuseColor = ambientColor = specularColor = 0xFFFFFF;
                    specular = 0;
                    useSpecular = false;
                    useColor = false;
                    alpha = 1;
                    mapkd = "";

                    for (j = 0; j < lines.length; ++j) {
                        lines[j] = lines[j].replace(/\s+$/, "");

                        if (lines[j].substring(0, 1) != "#" && (j == 0 || lines[j] != "")) {
                            trunk = lines[j].split(" ");

                            if (String(trunk[0]).charCodeAt(0) == 9 || String(trunk[0]).charCodeAt(0) == 32)
                                trunk[0] = trunk[0].substring(1, trunk[0].length);

                            if (j == 0) {
                                this._lastMtlID = trunk.join("");
                                this._lastMtlID = (this._lastMtlID == "") ? "def000" : this._lastMtlID;
                            } else {
                                switch (trunk[0]) {
                                    case "Ka":
                                        if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3])))
                                            ambientColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                        break;

                                    case "Ks":
                                        if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
                                            specularColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                            useSpecular = true;
                                        }
                                        break;

                                    case "Ns":
                                        if (trunk[1] && !isNaN(Number(trunk[1])))
                                            specular = Number(trunk[1]) * 0.001;
                                        if (specular == 0)
                                            useSpecular = false;
                                        break;

                                    case "Kd":
                                        if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
                                            diffuseColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                            useColor = true;
                                        }
                                        break;

                                    case "tr":
                                    case "d":
                                        if (trunk[1] && !isNaN(Number(trunk[1])))
                                            alpha = Number(trunk[1]);
                                        break;

                                    case "map_Kd":
                                        mapkd = this.parseMapKdString(trunk);
                                        mapkd = mapkd.replace(/\\/g, "/");
                                }
                            }
                        }
                    }

                    if (mapkd != "") {
                        if (useSpecular) {
                            basicSpecularMethod = new BasicSpecularMethod();
                            basicSpecularMethod.specularColor = specularColor;
                            basicSpecularMethod.specular = specular;

                            var specularData = new SpecularData();
                            specularData.alpha = alpha;
                            specularData.basicSpecularMethod = basicSpecularMethod;
                            specularData.materialID = this._lastMtlID;

                            if (!this._materialSpecularData)
                                this._materialSpecularData = new Array();

                            this._materialSpecularData.push(specularData);
                        }

                        this._pAddDependency(this._lastMtlID, new away.net.URLRequest(mapkd));
                    } else if (useColor && !isNaN(diffuseColor)) {
                        var lm = new LoadedMaterial();
                        lm.materialID = this._lastMtlID;

                        if (alpha == 0)
                            console.log("Warning: an alpha value of 0 was found in mtl color tag (Tr or d) ref:" + this._lastMtlID + ", mesh(es) using it will be invisible!");

                        var cm;

                        if (this.materialMode < 2) {
                            cm = new ColorMaterial(diffuseColor);

                            var colorMat = cm;

                            colorMat.alpha = alpha;
                            colorMat.ambientColor = ambientColor;
                            colorMat.repeat = true;

                            if (useSpecular) {
                                colorMat.specularColor = specularColor;
                                colorMat.specular = specular;
                            }
                        } else {
                            cm = new ColorMultiPassMaterial(diffuseColor);

                            var colorMultiMat = cm;

                            colorMultiMat.ambientColor = ambientColor;
                            colorMultiMat.repeat = true;

                            if (useSpecular) {
                                colorMultiMat.specularColor = specularColor;
                                colorMultiMat.specular = specular;
                            }
                        }

                        lm.cm = cm;

                        this._materialLoaded.push(lm);

                        if (this._meshes.length > 0)
                            this.applyMaterial(lm);
                    }
                }

                this._mtlLibLoaded = true;
            };

            OBJParser.prototype.parseMapKdString = function (trunk) {
                var url = "";
                var i;
                var breakflag;

                for (i = 1; i < trunk.length;) {
                    switch (trunk[i]) {
                        case "-blendu":
                        case "-blendv":
                        case "-cc":
                        case "-clamp":
                        case "-texres":
                            i += 2;
                            break;
                        case "-mm":
                            i += 3;
                            break;
                        case "-o":
                        case "-s":
                        case "-t":
                            i += 4;
                            continue;
                        default:
                            breakflag = true;
                            break;
                    }

                    if (breakflag)
                        break;
                }

                for (i; i < trunk.length; i++) {
                    url += trunk[i];
                    url += " ";
                }

                //Remove the extraneous space and/or newline from the right side
                url = url.replace(/\s+$/, "");

                return url;
            };

            OBJParser.prototype.loadMtl = function (mtlurl) {
                // Add raw-data dependency to queue and load dependencies now,
                // which will pause the parsing in the meantime.
                this._pAddDependency('mtl', new away.net.URLRequest(mtlurl), true);
                this._pPauseAndRetrieveDependencies();
            };

            OBJParser.prototype.applyMaterial = function (lm) {
                var decomposeID;
                var mesh;
                var mat;
                var j;
                var specularData;

                for (var i = 0; i < this._meshes.length; ++i) {
                    mesh = this._meshes[i];
                    decomposeID = mesh.material.name.split("~");

                    if (decomposeID[0] == lm.materialID) {
                        if (lm.cm) {
                            if (mesh.material)
                                mesh.material = null;
                            mesh.material = lm.cm;
                        } else if (lm.texture) {
                            if (this.materialMode < 2) {
                                mat = mesh.material;

                                var tm = mat;

                                tm.texture = lm.texture;
                                tm.ambientColor = lm.ambientColor;
                                tm.alpha = lm.alpha;
                                tm.repeat = true;

                                if (lm.specularMethod) {
                                    // By setting the specularMethod property to null before assigning
                                    // the actual method instance, we avoid having the properties of
                                    // the new method being overridden with the settings from the old
                                    // one, which is default behavior of the setter.
                                    tm.specularMethod = null;
                                    tm.specularMethod = lm.specularMethod;
                                } else if (this._materialSpecularData) {
                                    for (j = 0; j < this._materialSpecularData.length; ++j) {
                                        specularData = this._materialSpecularData[j];

                                        if (specularData.materialID == lm.materialID) {
                                            tm.specularMethod = null;
                                            tm.specularMethod = specularData.basicSpecularMethod;
                                            tm.ambientColor = specularData.ambientColor;
                                            tm.alpha = specularData.alpha;
                                            break;
                                        }
                                    }
                                }
                            } else {
                                mat = mesh.material;

                                var tmMult = mat;

                                tmMult.texture = lm.texture;
                                tmMult.ambientColor = lm.ambientColor;
                                tmMult.repeat = true;

                                if (lm.specularMethod) {
                                    // By setting the specularMethod property to null before assigning
                                    // the actual method instance, we avoid having the properties of
                                    // the new method being overridden with the settings from the old
                                    // one, which is default behavior of the setter.
                                    tmMult.specularMethod = null;
                                    tmMult.specularMethod = lm.specularMethod;
                                } else if (this._materialSpecularData) {
                                    for (j = 0; j < this._materialSpecularData.length; ++j) {
                                        specularData = this._materialSpecularData[j];

                                        if (specularData.materialID == lm.materialID) {
                                            tmMult.specularMethod = null;
                                            tmMult.specularMethod = specularData.basicSpecularMethod;
                                            tmMult.ambientColor = specularData.ambientColor;

                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        mesh.material.name = decomposeID[1] ? decomposeID[1] : decomposeID[0];
                        this._meshes.splice(i, 1);
                        --i;
                    }
                }

                if (lm.cm || mat)
                    this._pFinalizeAsset(lm.cm || mat);
            };

            OBJParser.prototype.applyMaterials = function () {
                if (this._materialLoaded.length == 0)
                    return;

                for (var i = 0; i < this._materialLoaded.length; ++i)
                    this.applyMaterial(this._materialLoaded[i]);
            };
            return OBJParser;
        })(parsers.ParserBase);
        parsers.OBJParser = OBJParser;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));

var BasicSpecularMethod = away.materials.BasicSpecularMethod;
var MaterialBase = away.materials.MaterialBase;
var Texture2DBase = away.textures.Texture2DBase;

var ObjectGroup = (function () {
    function ObjectGroup() {
        this.groups = new Array();
    }
    return ObjectGroup;
})();

var Group = (function () {
    function Group() {
        this.materialGroups = new Array();
    }
    return Group;
})();

var MaterialGroup = (function () {
    function MaterialGroup() {
        this.faces = new Array();
    }
    return MaterialGroup;
})();

var SpecularData = (function () {
    function SpecularData() {
        this.ambientColor = 0xFFFFFF;
        this.alpha = 1;
    }
    return SpecularData;
})();

var LoadedMaterial = (function () {
    function LoadedMaterial() {
        this.ambientColor = 0xFFFFFF;
        this.alpha = 1;
    }
    return LoadedMaterial;
})();

var FaceData = (function () {
    function FaceData() {
        this.vertexIndices = new Array();
        this.uvIndices = new Array();
        this.normalIndices = new Array();
        this.indexIds = new Array();
    }
    return FaceData;
})();

/**
* Texture coordinates value object.
*/
var UV = (function () {
    /**
    * Creates a new <code>UV</code> object.
    *
    * @param    u        [optional]    The horizontal coordinate of the texture value. Defaults to 0.
    * @param    v        [optional]    The vertical coordinate of the texture value. Defaults to 0.
    */
    function UV(u, v) {
        if (typeof u === "undefined") { u = 0; }
        if (typeof v === "undefined") { v = 0; }
        this._u = u;
        this._v = v;
    }
    Object.defineProperty(UV.prototype, "v", {
        get: /**
        * Defines the vertical coordinate of the texture value.
        */
        function () {
            return this._v;
        },
        set: function (value) {
            this._v = value;
        },
        enumerable: true,
        configurable: true
    });


    Object.defineProperty(UV.prototype, "u", {
        get: /**
        * Defines the horizontal coordinate of the texture value.
        */
        function () {
            return this._u;
        },
        set: function (value) {
            this._u = value;
        },
        enumerable: true,
        configurable: true
    });


    /**
    * returns a new UV value Object
    */
    UV.prototype.clone = function () {
        return new UV(this._u, this._v);
    };

    /**
    * returns the value object as a string for trace/debug purpose
    */
    UV.prototype.toString = function () {
        return this._u + "," + this._v;
    };
    return UV;
})();

var Vertex = (function () {
    /**
    * Creates a new <code>Vertex</code> value object.
    *
    * @param    x            [optional]    The x value. Defaults to 0.
    * @param    y            [optional]    The y value. Defaults to 0.
    * @param    z            [optional]    The z value. Defaults to 0.
    * @param    index        [optional]    The index value. Defaults is NaN.
    */
    function Vertex(x, y, z, index) {
        if (typeof x === "undefined") { x = 0; }
        if (typeof y === "undefined") { y = 0; }
        if (typeof z === "undefined") { z = 0; }
        if (typeof index === "undefined") { index = 0; }
        this._x = x;
        this._y = y;
        this._z = z;
        this._index = index;
    }

    Object.defineProperty(Vertex.prototype, "index", {
        get: function () {
            return this._index;
        },
        set: /**
        * To define/store the index of value object
        * @param    ind        The index
        */
        function (ind) {
            this._index = ind;
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(Vertex.prototype, "x", {
        get: /**
        * To define/store the x value of the value object
        * @param    value        The x value
        */
        function () {
            return this._x;
        },
        set: function (value) {
            this._x = value;
        },
        enumerable: true,
        configurable: true
    });


    Object.defineProperty(Vertex.prototype, "y", {
        get: /**
        * To define/store the y value of the value object
        * @param    value        The y value
        */
        function () {
            return this._y;
        },
        set: function (value) {
            this._y = value;
        },
        enumerable: true,
        configurable: true
    });


    Object.defineProperty(Vertex.prototype, "z", {
        get: /**
        * To define/store the z value of the value object
        * @param    value        The z value
        */
        function () {
            return this._z;
        },
        set: function (value) {
            this._z = value;
        },
        enumerable: true,
        configurable: true
    });


    /**
    * returns a new Vertex value Object
    */
    Vertex.prototype.clone = function () {
        return new Vertex(this._x, this._y, this._z);
    };
    return Vertex;
})();
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (parsers) {
        var AnimationSetBase = away.animators.AnimationSetBase;
        var AnimatorBase = away.animators.AnimatorBase;
        var JointPose = away.animators.JointPose;
        var Skeleton = away.animators.Skeleton;
        var SkeletonAnimationSet = away.animators.SkeletonAnimationSet;
        var SkeletonAnimator = away.animators.SkeletonAnimator;
        var SkeletonClipNode = away.animators.SkeletonClipNode;
        var SkeletonPose = away.animators.SkeletonPose;
        var SkeletonJoint = away.animators.SkeletonJoint;
        var VertexAnimationSet = away.animators.VertexAnimationSet;
        var VertexAnimator = away.animators.VertexAnimator;
        var VertexClipNode = away.animators.VertexClipNode;
        var CompactSubGeometry = away.base.CompactSubGeometry;
        var Geometry = away.base.Geometry;
        var BlendMode = away.base.BlendMode;
        var Mesh = away.entities.Mesh;
        var Matrix3D = away.geom.Matrix3D;
        var AssetType = away.library.AssetType;
        var DitheredShadowMapMethod = away.materials.DitheredShadowMapMethod;
        var FilteredShadowMapMethod = away.materials.FilteredShadowMapMethod;
        var FresnelSpecularMethod = away.materials.FresnelSpecularMethod;
        var HardShadowMapMethod = away.materials.HardShadowMapMethod;
        var PhongSpecularMethod = away.materials.PhongSpecularMethod;
        var MultiPassMaterialBase = away.materials.MultiPassMaterialBase;
        var NearShadowMapMethod = away.materials.NearShadowMapMethod;
        var SimpleShadowMapMethodBase = away.materials.SimpleShadowMapMethodBase;
        var SinglePassMaterialBase = away.materials.SinglePassMaterialBase;
        var SoftShadowMapMethod = away.materials.SoftShadowMapMethod;
        var URLLoaderDataFormat = away.net.URLLoaderDataFormat;

        /**
        * AWDParser provides a parser for the AWD data type.
        */
        var AWDParser = (function (_super) {
            __extends(AWDParser, _super);
            /**
            * Creates a new AWDParser object.
            * @param uri The url or id of the data or file to be parsed.
            * @param extra The holder for extra contextual data that the parser might need.
            */
            function AWDParser() {
                _super.call(this, URLLoaderDataFormat.ARRAY_BUFFER);
                //set to "true" to have some console.logs in the Console
                this._debug = false;
                this._startedParsing = false;
                this._texture_users = {};
                this._parsed_header = false;

                this._blocks = new Array();
                this._blocks[0] = new AWDBlock();
                this._blocks[0].data = null;

                this.blendModeDic = new Array();
                this.blendModeDic.push(BlendMode.NORMAL);
                this.blendModeDic.push(BlendMode.ADD);
                this.blendModeDic.push(BlendMode.ALPHA);
                this.blendModeDic.push(BlendMode.DARKEN);
                this.blendModeDic.push(BlendMode.DIFFERENCE);
                this.blendModeDic.push(BlendMode.ERASE);
                this.blendModeDic.push(BlendMode.HARDLIGHT);
                this.blendModeDic.push(BlendMode.INVERT);
                this.blendModeDic.push(BlendMode.LAYER);
                this.blendModeDic.push(BlendMode.LIGHTEN);
                this.blendModeDic.push(BlendMode.MULTIPLY);
                this.blendModeDic.push(BlendMode.NORMAL);
                this.blendModeDic.push(BlendMode.OVERLAY);
                this.blendModeDic.push(BlendMode.SCREEN);
                this.blendModeDic.push(BlendMode.SHADER);
                this.blendModeDic.push(BlendMode.OVERLAY);

                this._depthSizeDic = new Array();
                this._depthSizeDic.push(256);
                this._depthSizeDic.push(512);
                this._depthSizeDic.push(2048);
                this._depthSizeDic.push(1024);
                this._version = Array();
            }
            AWDParser.supportsType = /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            function (extension) {
                extension = extension.toLowerCase();
                return extension == "awd";
            };

            AWDParser.supportsData = /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            function (data) {
                return (away.parsers.ParserUtils.toString(data, 3) == 'AWD');
            };

            /**
            * @inheritDoc
            */
            AWDParser.prototype._iResolveDependency = function (resourceDependency) {
                if (resourceDependency.assets.length == 1) {
                    var isCubeTextureArray = resourceDependency.id.split("#");
                    var ressourceID = isCubeTextureArray[0];
                    var asset;
                    var thisBitmapTexture;
                    var block;

                    if (isCubeTextureArray.length == 1) {
                        asset = resourceDependency.assets[0];
                        if (asset) {
                            var mat;
                            var users;

                            block = this._blocks[resourceDependency.id];
                            block.data = asset;

                            // Reset name of texture to the one defined in the AWD file,
                            // as opposed to whatever the image parser came up with.
                            asset.resetAssetPath(block.name, null, true);
                            block.name = asset.name;

                            // Finalize texture asset to dispatch texture event, which was
                            // previously suppressed while the dependency was loaded.
                            this._pFinalizeAsset(asset);

                            if (this._debug) {
                                console.log("Successfully loaded Bitmap for texture");
                                console.log("Parsed texture: Name = " + block.name);
                            }
                        }
                    }

                    if (isCubeTextureArray.length > 1) {
                        thisBitmapTexture = resourceDependency.assets[0];

                        var tx = thisBitmapTexture;

                        this._cubeTextures[isCubeTextureArray[1]] = tx.htmlImageElement;
                        this._texture_users[ressourceID].push(1);

                        if (this._debug) {
                            console.log("Successfully loaded Bitmap " + this._texture_users[ressourceID].length + " / 6 for Cubetexture");
                        }
                        if (this._texture_users[ressourceID].length == this._cubeTextures.length) {
                            var posX = this._cubeTextures[0];
                            var negX = this._cubeTextures[1];
                            var posY = this._cubeTextures[2];
                            var negY = this._cubeTextures[3];
                            var posZ = this._cubeTextures[4];
                            var negZ = this._cubeTextures[5];

                            asset = new away.textures.ImageCubeTexture(posX, negX, posY, negY, posZ, negZ);
                            block = this._blocks[ressourceID];
                            block.data = asset;

                            // Reset name of texture to the one defined in the AWD file,
                            // as opposed to whatever the image parser came up with.
                            asset.resetAssetPath(block.name, null, true);
                            block.name = asset.name;

                            // Finalize texture asset to dispatch texture event, which was
                            // previously suppressed while the dependency was loaded.
                            this._pFinalizeAsset(asset);
                            if (this._debug) {
                                console.log("Parsed CubeTexture: Name = " + block.name);
                            }
                        }
                    }
                }
            };

            /**
            * @inheritDoc
            */
            AWDParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
                //not used - if a dependcy fails, the awaiting Texture or CubeTexture will never be finalized, and the default-bitmaps will be used.
                // this means, that if one Bitmap of a CubeTexture fails, the CubeTexture will have the DefaultTexture applied for all six Bitmaps.
            };

            /**
            * Resolve a dependency name
            *
            * @param resourceDependency The dependency to be resolved.
            */
            AWDParser.prototype._iResolveDependencyName = function (resourceDependency, asset) {
                var oldName = asset.name;

                if (asset) {
                    var block = this._blocks[parseInt(resourceDependency.id)];

                    // Reset name of texture to the one defined in the AWD file,
                    // as opposed to whatever the image parser came up with.
                    asset.resetAssetPath(block.name, null, true);
                }

                var newName = asset.name;

                asset.name = oldName;

                return newName;
            };

            /**
            * @inheritDoc
            */
            AWDParser.prototype._pProceedParsing = function () {
                if (!this._startedParsing) {
                    this._byteData = this._pGetByteData();
                    this._startedParsing = true;
                }

                if (!this._parsed_header) {
                    //----------------------------------------------------------------------------
                    // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                    //----------------------------------------------------------------------------
                    //this._byteData.endian = Endian.LITTLE_ENDIAN;
                    //----------------------------------------------------------------------------
                    //----------------------------------------------------------------------------
                    // Parse header and decompress body if needed
                    this.parseHeader();

                    switch (this._compression) {
                        case AWDParser.DEFLATE:
                        case AWDParser.LZMA:
                            this._pDieWithError('Compressed AWD formats not yet supported');
                            break;

                        case AWDParser.UNCOMPRESSED:
                            this._body = this._byteData;
                            break;
                    }

                    this._parsed_header = true;
                    //----------------------------------------------------------------------------
                    // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                    //----------------------------------------------------------------------------
                    //this._body.endian = Endian.LITTLE_ENDIAN;// Should be default
                    //----------------------------------------------------------------------------
                }

                if (this._body) {
                    while (this._body.getBytesAvailable() > 0 && !this.parsingPaused) {
                        this.parseNextBlock();
                    }

                    if (this._body.getBytesAvailable() == 0) {
                        this.dispose();
                        return away.parsers.ParserBase.PARSING_DONE;
                    } else {
                        return away.parsers.ParserBase.MORE_TO_PARSE;
                    }
                } else {
                    switch (this._compression) {
                        case AWDParser.DEFLATE:
                        case AWDParser.LZMA:
                            if (this._debug) {
                                console.log("(!) AWDParser Error: Compressed AWD formats not yet supported (!)");
                            }

                            break;
                    }

                    // Error - most likely _body not set because we do not support compression.
                    return away.parsers.ParserBase.PARSING_DONE;
                }
            };

            AWDParser.prototype.dispose = function () {
                for (var c in this._blocks) {
                    var b = this._blocks[c];
                    b.dispose();
                }
            };

            AWDParser.prototype.parseNextBlock = function () {
                var block;
                var assetData;
                var isParsed = false;
                var ns;
                var type;
                var flags;
                var len;

                this._cur_block_id = this._body.readUnsignedInt();

                ns = this._body.readUnsignedByte();
                type = this._body.readUnsignedByte();
                flags = this._body.readUnsignedByte();
                len = this._body.readUnsignedInt();

                var blockCompression = bitFlags.test(flags, bitFlags.FLAG4);
                var blockCompressionLZMA = bitFlags.test(flags, bitFlags.FLAG5);

                if (this._accuracyOnBlocks) {
                    this._accuracyMatrix = bitFlags.test(flags, bitFlags.FLAG1);
                    this._accuracyGeo = bitFlags.test(flags, bitFlags.FLAG2);
                    this._accuracyProps = bitFlags.test(flags, bitFlags.FLAG3);
                    this._geoNrType = AWDParser.FLOAT32;

                    if (this._accuracyGeo) {
                        this._geoNrType = AWDParser.FLOAT64;
                    }

                    this._matrixNrType = AWDParser.FLOAT32;

                    if (this._accuracyMatrix) {
                        this._matrixNrType = AWDParser.FLOAT64;
                    }

                    this._propsNrType = AWDParser.FLOAT32;

                    if (this._accuracyProps) {
                        this._propsNrType = AWDParser.FLOAT64;
                    }
                }

                var blockEndAll = this._body.position + len;

                if (len > this._body.getBytesAvailable()) {
                    this._pDieWithError('AWD2 block length is bigger than the bytes that are available!');
                    this._body.position += this._body.getBytesAvailable();
                    return;
                }
                this._newBlockBytes = new away.utils.ByteArray();

                this._body.readBytes(this._newBlockBytes, 0, len);

                if (blockCompression) {
                    this._pDieWithError('Compressed AWD formats not yet supported');
                    /*
                    if (blockCompressionLZMA)
                    {
                    this._newBlockBytes.uncompress(AWDParser.COMPRESSIONMODE_LZMA);
                    }
                    else
                    {
                    this._newBlockBytes.uncompress();
                    }
                    */
                }

                //----------------------------------------------------------------------------
                // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                //----------------------------------------------------------------------------
                //this._newBlockBytes.endian = Endian.LITTLE_ENDIAN;
                //----------------------------------------------------------------------------
                this._newBlockBytes.position = 0;
                block = new AWDBlock();
                block.len = this._newBlockBytes.position + len;
                block.id = this._cur_block_id;

                var blockEndBlock = this._newBlockBytes.position + len;

                if (blockCompression) {
                    this._pDieWithError('Compressed AWD formats not yet supported');
                    //blockEndBlock   = this._newBlockBytes.position + this._newBlockBytes.length;
                    //block.len       = blockEndBlock;
                }

                if (this._debug) {
                    console.log("AWDBlock:  ID = " + this._cur_block_id + " | TypeID = " + type + " | Compression = " + blockCompression + " | Matrix-Precision = " + this._accuracyMatrix + " | Geometry-Precision = " + this._accuracyGeo + " | Properties-Precision = " + this._accuracyProps);
                }

                this._blocks[this._cur_block_id] = block;

                if ((this._version[0] == 2) && (this._version[1] == 1)) {
                    switch (type) {
                        case 11:
                            this.parsePrimitves(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 31:
                            this.parseSkyboxInstance(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 41:
                            this.parseLight(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 42:
                            this.parseCamera(this._cur_block_id);
                            isParsed = true;
                            break;

                        case 51:
                            this.parseLightPicker(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 81:
                            this.parseMaterial_v1(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 83:
                            this.parseCubeTexture(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 91:
                            this.parseSharedMethodBlock(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 92:
                            this.parseShadowMethodBlock(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 111:
                            this.parseMeshPoseAnimation(this._cur_block_id, true);
                            isParsed = true;
                            break;
                        case 112:
                            this.parseMeshPoseAnimation(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 113:
                            this.parseVertexAnimationSet(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 122:
                            this.parseAnimatorSet(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 253:
                            this.parseCommand(this._cur_block_id);
                            isParsed = true;
                            break;
                    }
                    //*/
                }

                if (isParsed == false) {
                    switch (type) {
                        case 1:
                            this.parseTriangleGeometrieBlock(this._cur_block_id);
                            break;
                        case 22:
                            this.parseContainer(this._cur_block_id);
                            break;
                        case 23:
                            this.parseMeshInstance(this._cur_block_id);
                            break;
                        case 81:
                            this.parseMaterial(this._cur_block_id);
                            break;
                        case 82:
                            this.parseTexture(this._cur_block_id);
                            break;
                        case 101:
                            this.parseSkeleton(this._cur_block_id);
                            break;
                        case 102:
                            this.parseSkeletonPose(this._cur_block_id);
                            break;
                        case 103:
                            this.parseSkeletonAnimation(this._cur_block_id);
                            break;
                        case 121:

                        case 254:
                            this.parseNameSpace(this._cur_block_id);
                            break;
                        case 255:
                            this.parseMetaData(this._cur_block_id);
                            break;
                        default:
                            if (this._debug) {
                                console.log("AWDBlock:   Unknown BlockType  (BlockID = " + this._cur_block_id + ") - Skip " + len + " bytes");
                            }
                            this._newBlockBytes.position += len;
                            break;
                    }
                }

                //*/
                var msgCnt = 0;
                if (this._newBlockBytes.position == blockEndBlock) {
                    if (this._debug) {
                        if (block.errorMessages) {
                            while (msgCnt < block.errorMessages.length) {
                                console.log("        (!) Error: " + block.errorMessages[msgCnt] + " (!)");
                                msgCnt++;
                            }
                        }
                    }
                    if (this._debug) {
                        console.log("\n");
                    }
                } else {
                    if (this._debug) {
                        console.log("  (!)(!)(!) Error while reading AWDBlock ID " + this._cur_block_id + " = skip to next block");

                        if (block.errorMessages) {
                            while (msgCnt < block.errorMessages.length) {
                                console.log("        (!) Error: " + block.errorMessages[msgCnt] + " (!)");
                                msgCnt++;
                            }
                        }
                    }
                }

                this._body.position = blockEndAll;
                this._newBlockBytes = null;
            };

            //--Parser Blocks---------------------------------------------------------------------------
            //Block ID = 1
            AWDParser.prototype.parseTriangleGeometrieBlock = function (blockID) {
                var geom = new away.base.Geometry();

                // Read name and sub count
                var name = this.parseVarStr();
                var num_subs = this._newBlockBytes.readUnsignedShort();

                // Read optional properties
                var props = this.parseProperties({ 1: this._geoNrType, 2: this._geoNrType });
                var geoScaleU = props.get(1, 1);
                var geoScaleV = props.get(2, 1);

                // Loop through sub meshes
                var subs_parsed = 0;
                while (subs_parsed < num_subs) {
                    var i;
                    var sm_len, sm_end;
                    var sub_geoms;
                    var w_indices;
                    var weights;

                    sm_len = this._newBlockBytes.readUnsignedInt();
                    sm_end = this._newBlockBytes.position + sm_len;

                    // Ignore for now
                    var subProps = this.parseProperties({ 1: this._geoNrType, 2: this._geoNrType });

                    while (this._newBlockBytes.position < sm_end) {
                        var idx = 0;
                        var str_ftype, str_type, str_len, str_end;

                        // Type, field type, length
                        str_type = this._newBlockBytes.readUnsignedByte();
                        str_ftype = this._newBlockBytes.readUnsignedByte();
                        str_len = this._newBlockBytes.readUnsignedInt();
                        str_end = this._newBlockBytes.position + str_len;

                        var x, y, z;

                        if (str_type == 1) {
                            var verts = new Array();

                            while (this._newBlockBytes.position < str_end) {
                                // TODO: Respect stream field type
                                x = this.readNumber(this._accuracyGeo);
                                y = this.readNumber(this._accuracyGeo);
                                z = this.readNumber(this._accuracyGeo);

                                verts[idx++] = x;
                                verts[idx++] = y;
                                verts[idx++] = z;
                            }
                        } else if (str_type == 2) {
                            var indices = new Array();

                            while (this._newBlockBytes.position < str_end) {
                                // TODO: Respect stream field type
                                indices[idx++] = this._newBlockBytes.readUnsignedShort();
                            }
                        } else if (str_type == 3) {
                            var uvs = new Array();
                            while (this._newBlockBytes.position < str_end) {
                                uvs[idx++] = this.readNumber(this._accuracyGeo);
                            }
                        } else if (str_type == 4) {
                            var normals = new Array();

                            while (this._newBlockBytes.position < str_end) {
                                normals[idx++] = this.readNumber(this._accuracyGeo);
                            }
                        } else if (str_type == 6) {
                            w_indices = Array();

                            while (this._newBlockBytes.position < str_end) {
                                w_indices[idx++] = this._newBlockBytes.readUnsignedShort() * 3;
                            }
                        } else if (str_type == 7) {
                            weights = new Array();

                            while (this._newBlockBytes.position < str_end) {
                                weights[idx++] = this.readNumber(this._accuracyGeo);
                            }
                        } else {
                            this._newBlockBytes.position = str_end;
                        }
                    }

                    this.parseUserAttributes();

                    sub_geoms = away.utils.GeometryUtils.fromVectors(verts, indices, uvs, normals, null, weights, w_indices);

                    var scaleU = subProps.get(1, 1);
                    var scaleV = subProps.get(2, 1);
                    var setSubUVs = false;

                    if ((geoScaleU != scaleU) || (geoScaleV != scaleV)) {
                        setSubUVs = true;
                        scaleU = geoScaleU / scaleU;
                        scaleV = geoScaleV / scaleV;
                    }

                    for (i = 0; i < sub_geoms.length; i++) {
                        if (setSubUVs)
                            sub_geoms[i].scaleUV(scaleU, scaleV);
                        geom.addSubGeometry(sub_geoms[i]);
                        // TODO: Somehow map in-sub to out-sub indices to enable look-up
                        // when creating meshes (and their material assignments.)
                    }
                    subs_parsed++;
                }
                if ((geoScaleU != 1) || (geoScaleV != 1))
                    geom.scaleUV(geoScaleU, geoScaleV);
                this.parseUserAttributes();
                this._pFinalizeAsset(geom, name);
                this._blocks[blockID].data = geom;

                if (this._debug) {
                    console.log("Parsed a TriangleGeometry: Name = " + name + "| SubGeometries = " + sub_geoms.length);
                }
            };

            //Block ID = 11
            AWDParser.prototype.parsePrimitves = function (blockID) {
                var name;
                var geom;
                var primType;
                var subs_parsed;
                var props;
                var bsm;

                // Read name and sub count
                name = this.parseVarStr();
                primType = this._newBlockBytes.readUnsignedByte();
                props = this.parseProperties({ 101: this._geoNrType, 102: this._geoNrType, 103: this._geoNrType, 110: this._geoNrType, 111: this._geoNrType, 301: AWDParser.UINT16, 302: AWDParser.UINT16, 303: AWDParser.UINT16, 701: AWDParser.BOOL, 702: AWDParser.BOOL, 703: AWDParser.BOOL, 704: AWDParser.BOOL });

                var primitveTypes = ["Unsupported Type-ID", "PlaneGeometry", "CubeGeometry", "SphereGeometry", "CylinderGeometry", "ConeGeometry", "CapsuleGeometry", "TorusGeometry"];

                switch (primType) {
                    case 1:
                        geom = new away.primitives.PlaneGeometry(props.get(101, 100), props.get(102, 100), props.get(301, 1), props.get(302, 1), props.get(701, true), props.get(702, false));
                        break;

                    case 2:
                        geom = new away.primitives.CubeGeometry(props.get(101, 100), props.get(102, 100), props.get(103, 100), props.get(301, 1), props.get(302, 1), props.get(303, 1), props.get(701, true));
                        break;

                    case 3:
                        geom = new away.primitives.SphereGeometry(props.get(101, 50), props.get(301, 16), props.get(302, 12), props.get(701, true));
                        break;

                    case 4:
                        geom = new away.primitives.CylinderGeometry(props.get(101, 50), props.get(102, 50), props.get(103, 100), props.get(301, 16), props.get(302, 1), true, true, true);
                        if (!props.get(701, true))
                            (geom).topClosed = false;
                        if (!props.get(702, true))
                            (geom).bottomClosed = false;
                        if (!props.get(703, true))
                            (geom).yUp = false;

                        break;

                    case 5:
                        geom = new away.primitives.ConeGeometry(props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 1), props.get(701, true), props.get(702, true));
                        break;

                    case 6:
                        geom = new away.primitives.CapsuleGeometry(props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 15), props.get(701, true));
                        break;

                    case 7:
                        geom = new away.primitives.TorusGeometry(props.get(101, 50), props.get(102, 50), props.get(301, 16), props.get(302, 8), props.get(701, true));
                        break;

                    default:
                        geom = new away.base.Geometry();
                        console.log("ERROR: UNSUPPORTED PRIMITIVE_TYPE");
                        break;
                }

                if ((props.get(110, 1) != 1) || (props.get(111, 1) != 1)) {
                    geom.subGeometries;
                    geom.scaleUV(props.get(110, 1), props.get(111, 1));
                }

                this.parseUserAttributes();
                geom.name = name;
                this._pFinalizeAsset(geom, name);
                this._blocks[blockID].data = geom;

                if (this._debug) {
                    if ((primType < 0) || (primType > 7)) {
                        primType = 0;
                    }
                    console.log("Parsed a Primivite: Name = " + name + "| type = " + primitveTypes[primType]);
                }
            };

            // Block ID = 22
            AWDParser.prototype.parseContainer = function (blockID) {
                var name;
                var par_id;
                var mtx;
                var ctr;
                var parent;

                par_id = this._newBlockBytes.readUnsignedInt();
                mtx = this.parseMatrix3D();
                name = this.parseVarStr();

                var parentName = "Root (TopLevel)";
                ctr = new away.containers.DisplayObjectContainer();
                ctr.transform.matrix3D = mtx;

                var returnedArray = this.getAssetByID(par_id, [AssetType.CONTAINER, AssetType.LIGHT, AssetType.MESH, AssetType.SEGMENT_SET]);

                if (returnedArray[0]) {
                    var obj = (returnedArray[1]).addChild(ctr);
                    parentName = (returnedArray[1]).name;
                } else if (par_id > 0) {
                    this._blocks[blockID].addError("Could not find a parent for this ObjectContainer3D");
                }

                if ((this._version[0] == 2) && (this._version[1] == 1)) {
                    var props = this.parseProperties({ 1: this._matrixNrType, 2: this._matrixNrType, 3: this._matrixNrType, 4: AWDParser.UINT8 });
                    ctr.pivotPoint = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                } else {
                    this.parseProperties(null);
                }

                // the extraProperties should only be set for AWD2.1-Files, but is read for both versions
                ctr.extra = this.parseUserAttributes();

                this._pFinalizeAsset(ctr, name);
                this._blocks[blockID].data = ctr;

                if (this._debug) {
                    console.log("Parsed a Container: Name = '" + name + "' | Parent-Name = " + parentName);
                }
            };

            // Block ID = 23
            AWDParser.prototype.parseMeshInstance = function (blockID) {
                var num_materials;
                var materials_parsed;
                var parent;
                var par_id = this._newBlockBytes.readUnsignedInt();
                var mtx = this.parseMatrix3D();
                var name = this.parseVarStr();
                var parentName = "Root (TopLevel)";
                var data_id = this._newBlockBytes.readUnsignedInt();
                var geom;
                var returnedArrayGeometry = this.getAssetByID(data_id, [AssetType.GEOMETRY]);

                if (returnedArrayGeometry[0]) {
                    geom = returnedArrayGeometry[1];
                } else {
                    this._blocks[blockID].addError("Could not find a Geometry for this Mesh. A empty Geometry is created!");
                    geom = new away.base.Geometry();
                }

                this._blocks[blockID].geoID = data_id;
                var materials = new Array();
                num_materials = this._newBlockBytes.readUnsignedShort();

                var materialNames = new Array();
                materials_parsed = 0;

                var returnedArrayMaterial;

                while (materials_parsed < num_materials) {
                    var mat_id;
                    mat_id = this._newBlockBytes.readUnsignedInt();
                    returnedArrayMaterial = this.getAssetByID(mat_id, [AssetType.MATERIAL]);
                    if ((!returnedArrayMaterial[0]) && (mat_id > 0)) {
                        this._blocks[blockID].addError("Could not find Material Nr " + materials_parsed + " (ID = " + mat_id + " ) for this Mesh");
                    }

                    var m = returnedArrayMaterial[1];

                    materials.push(m);
                    materialNames.push(m.name);

                    materials_parsed++;
                }

                var mesh = new Mesh(geom, null);
                mesh.transform.matrix3D = mtx;

                var returnedArrayParent = this.getAssetByID(par_id, [AssetType.CONTAINER, AssetType.LIGHT, AssetType.MESH, AssetType.SEGMENT_SET]);

                if (returnedArrayParent[0]) {
                    var objC = returnedArrayParent[1];
                    objC.addChild(mesh);
                    parentName = objC.name;
                } else if (par_id > 0) {
                    this._blocks[blockID].addError("Could not find a parent for this Mesh");
                }

                if (materials.length >= 1 && mesh.subMeshes.length == 1) {
                    mesh.material = materials[0];
                } else if (materials.length > 1) {
                    var i;

                    for (i = 0; i < mesh.subMeshes.length; i++) {
                        mesh.subMeshes[i].material = materials[Math.min(materials.length - 1, i)];
                    }
                }
                if ((this._version[0] == 2) && (this._version[1] == 1)) {
                    var props = this.parseProperties({ 1: this._matrixNrType, 2: this._matrixNrType, 3: this._matrixNrType, 4: AWDParser.UINT8, 5: AWDParser.BOOL });
                    mesh.pivotPoint = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                    mesh.castsShadows = props.get(5, true);
                } else {
                    this.parseProperties(null);
                }

                mesh.extra = this.parseUserAttributes();

                this._pFinalizeAsset(mesh, name);
                this._blocks[blockID].data = mesh;

                if (this._debug) {
                    console.log("Parsed a Mesh: Name = '" + name + "' | Parent-Name = " + parentName + "| Geometry-Name = " + geom.name + " | SubMeshes = " + mesh.subMeshes.length + " | Mat-Names = " + materialNames.toString());
                }
            };

            //Block ID 31
            AWDParser.prototype.parseSkyboxInstance = function (blockID) {
                var name = this.parseVarStr();
                var cubeTexAddr = this._newBlockBytes.readUnsignedInt();

                var returnedArrayCubeTex = this.getAssetByID(cubeTexAddr, [AssetType.TEXTURE], "CubeTexture");
                if ((!returnedArrayCubeTex[0]) && (cubeTexAddr != 0))
                    this._blocks[blockID].addError("Could not find the Cubetexture (ID = " + cubeTexAddr + " ) for this Skybox");
                var asset = new away.entities.Skybox(returnedArrayCubeTex[1]);

                this.parseProperties(null);
                asset.extra = this.parseUserAttributes();
                this._pFinalizeAsset(asset, name);
                this._blocks[blockID].data = asset;
                if (this._debug)
                    console.log("Parsed a Skybox: Name = '" + name + "' | CubeTexture-Name = " + (returnedArrayCubeTex[1]).name);
            };

            //Block ID = 41
            AWDParser.prototype.parseLight = function (blockID) {
                var light;
                var newShadowMapper;

                var par_id = this._newBlockBytes.readUnsignedInt();
                var mtx = this.parseMatrix3D();
                var name = this.parseVarStr();
                var lightType = this._newBlockBytes.readUnsignedByte();
                var props = this.parseProperties({ 1: this._propsNrType, 2: this._propsNrType, 3: AWDParser.COLOR, 4: this._propsNrType, 5: this._propsNrType, 6: AWDParser.BOOL, 7: AWDParser.COLOR, 8: this._propsNrType, 9: AWDParser.UINT8, 10: AWDParser.UINT8, 11: this._propsNrType, 12: AWDParser.UINT16, 21: this._matrixNrType, 22: this._matrixNrType, 23: this._matrixNrType });
                var shadowMapperType = props.get(9, 0);
                var parentName = "Root (TopLevel)";
                var lightTypes = ["Unsupported LightType", "PointLight", "DirectionalLight"];
                var shadowMapperTypes = ["No ShadowMapper", "DirectionalShadowMapper", "NearDirectionalShadowMapper", "CascadeShadowMapper", "CubeMapShadowMapper"];

                if (lightType == 1) {
                    light = new away.lights.PointLight();

                    (light).radius = props.get(1, 90000);
                    (light).fallOff = props.get(2, 100000);

                    if (shadowMapperType > 0) {
                        if (shadowMapperType == 4) {
                            newShadowMapper = new away.lights.CubeMapShadowMapper();
                        }
                    }

                    light.transform.matrix3D = mtx;
                }

                if (lightType == 2) {
                    light = new away.lights.DirectionalLight(props.get(21, 0), props.get(22, -1), props.get(23, 1));

                    if (shadowMapperType > 0) {
                        if (shadowMapperType == 1) {
                            newShadowMapper = new away.lights.DirectionalShadowMapper();
                        }
                        //if (shadowMapperType == 2)
                        //  newShadowMapper = new NearDirectionalShadowMapper(props.get(11, 0.5));
                        //if (shadowMapperType == 3)
                        //   newShadowMapper = new CascadeShadowMapper(props.get(12, 3));
                    }
                }
                light.color = props.get(3, 0xffffff);
                light.specular = props.get(4, 1.0);
                light.diffuse = props.get(5, 1.0);
                light.ambientColor = props.get(7, 0xffffff);
                light.ambient = props.get(8, 0.0);

                if (newShadowMapper) {
                    if (newShadowMapper instanceof away.lights.CubeMapShadowMapper) {
                        if (props.get(10, 1) != 1) {
                            newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 1)];
                        }
                    } else {
                        if (props.get(10, 2) != 2) {
                            newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 2)];
                        }
                    }

                    light.shadowMapper = newShadowMapper;
                    light.castsShadows = true;
                }

                if (par_id != 0) {
                    var returnedArrayParent = this.getAssetByID(par_id, [AssetType.CONTAINER, AssetType.LIGHT, AssetType.MESH, AssetType.SEGMENT_SET]);

                    if (returnedArrayParent[0]) {
                        (returnedArrayParent[1]).addChild(light);
                        parentName = (returnedArrayParent[1]).name;
                    } else {
                        this._blocks[blockID].addError("Could not find a parent for this Light");
                    }
                }

                this.parseUserAttributes();

                this._pFinalizeAsset(light, name);

                this._blocks[blockID].data = light;

                if (this._debug)
                    console.log("Parsed a Light: Name = '" + name + "' | Type = " + lightTypes[lightType] + " | Parent-Name = " + parentName + " | ShadowMapper-Type = " + shadowMapperTypes[shadowMapperType]);
            };

            //Block ID = 43
            AWDParser.prototype.parseCamera = function (blockID) {
                var par_id = this._newBlockBytes.readUnsignedInt();
                var mtx = this.parseMatrix3D();
                var name = this.parseVarStr();
                var parentName = "Root (TopLevel)";
                var projection;

                this._newBlockBytes.readUnsignedByte();
                this._newBlockBytes.readShort();

                var projectiontype = this._newBlockBytes.readShort();
                var props = this.parseProperties({ 101: this._propsNrType, 102: this._propsNrType, 103: this._propsNrType, 104: this._propsNrType });

                switch (projectiontype) {
                    case 5001:
                        projection = new away.projections.PerspectiveProjection(props.get(101, 60));
                        break;
                    case 5002:
                        projection = new away.projections.OrthographicProjection(props.get(101, 500));
                        break;
                    case 5003:
                        projection = new away.projections.OrthographicOffCenterProjection(props.get(101, -400), props.get(102, 400), props.get(103, -300), props.get(104, 300));
                        break;
                    default:
                        console.log("unsupportedLenstype");
                        return;
                }

                var camera = new away.entities.Camera(projection);
                camera.transform.matrix3D = mtx;

                var returnedArrayParent = this.getAssetByID(par_id, [AssetType.CONTAINER, AssetType.LIGHT, AssetType.MESH, AssetType.SEGMENT_SET]);

                if (returnedArrayParent[0]) {
                    var objC = returnedArrayParent[1];
                    objC.addChild(camera);

                    parentName = objC.name;
                } else if (par_id > 0) {
                    this._blocks[blockID].addError("Could not find a parent for this Camera");
                }

                camera.name = name;
                props = this.parseProperties({ 1: this._matrixNrType, 2: this._matrixNrType, 3: this._matrixNrType, 4: AWDParser.UINT8 });
                camera.pivotPoint = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                camera.extra = this.parseUserAttributes();

                this._pFinalizeAsset(camera, name);

                this._blocks[blockID].data = camera;

                if (this._debug) {
                    console.log("Parsed a Camera: Name = '" + name + "' | Projectiontype = " + projection + " | Parent-Name = " + parentName);
                }
            };

            //Block ID = 51
            AWDParser.prototype.parseLightPicker = function (blockID) {
                var name = this.parseVarStr();
                var numLights = this._newBlockBytes.readUnsignedShort();
                var lightsArray = new Array();
                var k = 0;
                var lightID = 0;

                var returnedArrayLight;
                var lightsArrayNames = new Array();

                for (k = 0; k < numLights; k++) {
                    lightID = this._newBlockBytes.readUnsignedInt();
                    returnedArrayLight = this.getAssetByID(lightID, [AssetType.LIGHT]);

                    if (returnedArrayLight[0]) {
                        lightsArray.push(returnedArrayLight[1]);
                        lightsArrayNames.push((returnedArrayLight[1]).name);
                    } else {
                        this._blocks[blockID].addError("Could not find a Light Nr " + k + " (ID = " + lightID + " ) for this LightPicker");
                    }
                }

                if (lightsArray.length == 0) {
                    this._blocks[blockID].addError("Could not create this LightPicker, cause no Light was found.");
                    this.parseUserAttributes();
                    return;
                }

                var lightPick = new away.materials.StaticLightPicker(lightsArray);
                lightPick.name = name;

                this.parseUserAttributes();
                this._pFinalizeAsset(lightPick, name);

                this._blocks[blockID].data = lightPick;
                if (this._debug) {
                    console.log("Parsed a StaticLightPicker: Name = '" + name + "' | Texture-Name = " + lightsArrayNames.toString());
                }
            };

            //Block ID = 81
            AWDParser.prototype.parseMaterial = function (blockID) {
                // TODO: not used
                ////blockLength = block.len;
                var name;
                var type;
                var props;
                var mat;
                var attributes;
                var finalize;
                var num_methods;
                var methods_parsed;
                var returnedArray;

                name = this.parseVarStr();
                type = this._newBlockBytes.readUnsignedByte();
                num_methods = this._newBlockBytes.readUnsignedByte();

                // Read material numerical properties
                // (1=color, 2=bitmap url, 10=alpha, 11=alpha_blending, 12=alpha_threshold, 13=repeat)
                props = this.parseProperties({ 1: AWDParser.INT32, 2: AWDParser.BADDR, 10: this._propsNrType, 11: AWDParser.BOOL, 12: this._propsNrType, 13: AWDParser.BOOL });

                methods_parsed = 0;
                while (methods_parsed < num_methods) {
                    var method_type;

                    method_type = this._newBlockBytes.readUnsignedShort();
                    this.parseProperties(null);
                    this.parseUserAttributes();
                    methods_parsed += 1;
                }
                var debugString = "";
                attributes = this.parseUserAttributes();
                if (type === 1) {
                    debugString += "Parsed a ColorMaterial(SinglePass): Name = '" + name + "' | ";
                    var color;
                    color = props.get(1, 0xcccccc);
                    if (this.materialMode < 2)
                        mat = new away.materials.ColorMaterial(color, props.get(10, 1.0));
else
                        mat = new away.materials.ColorMultiPassMaterial(color);
                } else if (type === 2) {
                    var tex_addr = props.get(2, 0);

                    returnedArray = this.getAssetByID(tex_addr, [AssetType.TEXTURE]);
                    if ((!returnedArray[0]) && (tex_addr > 0)) {
                        this._blocks[blockID].addError("Could not find the DiffsueTexture (ID = " + tex_addr + " ) for this Material");
                    }

                    if (this.materialMode < 2) {
                        mat = new away.materials.TextureMaterial(returnedArray[1]);

                        var txMaterial = mat;

                        txMaterial.alphaBlending = props.get(11, false);
                        txMaterial.alpha = props.get(10, 1.0);
                        debugString += "Parsed a TextureMaterial(SinglePass): Name = '" + name + "' | Texture-Name = " + mat.name;
                    } else {
                        mat = new away.materials.TextureMultiPassMaterial(returnedArray[1]);
                        debugString += "Parsed a TextureMaterial(MultipAss): Name = '" + name + "' | Texture-Name = " + mat.name;
                    }
                }

                mat.extra = attributes;
                if (this.materialMode < 2) {
                    var spmb = mat;
                    spmb.alphaThreshold = props.get(12, 0.0);
                } else {
                    var mpmb = mat;
                    mpmb.alphaThreshold = props.get(12, 0.0);
                }

                mat.repeat = props.get(13, false);
                this._pFinalizeAsset(mat, name);
                this._blocks[blockID].data = mat;

                if (this._debug) {
                    console.log(debugString);
                }
            };

            // Block ID = 81 AWD2.1
            AWDParser.prototype.parseMaterial_v1 = function (blockID) {
                var mat;
                var normalTexture;
                var specTexture;
                var returnedArray;

                var name = this.parseVarStr();
                var type = this._newBlockBytes.readUnsignedByte();
                var num_methods = this._newBlockBytes.readUnsignedByte();
                var props = this.parseProperties({ 1: AWDParser.UINT32, 2: AWDParser.BADDR, 3: AWDParser.BADDR, 4: AWDParser.UINT8, 5: AWDParser.BOOL, 6: AWDParser.BOOL, 7: AWDParser.BOOL, 8: AWDParser.BOOL, 9: AWDParser.UINT8, 10: this._propsNrType, 11: AWDParser.BOOL, 12: this._propsNrType, 13: AWDParser.BOOL, 15: this._propsNrType, 16: AWDParser.UINT32, 17: AWDParser.BADDR, 18: this._propsNrType, 19: this._propsNrType, 20: AWDParser.UINT32, 21: AWDParser.BADDR, 22: AWDParser.BADDR });
                var spezialType = props.get(4, 0);
                var debugString = "";

                if (spezialType >= 2) {
                    this._blocks[blockID].addError("Material-spezialType '" + spezialType + "' is not supported, can only be 0:singlePass, 1:MultiPass !");
                    return;
                }

                if (this.materialMode == 1) {
                    spezialType = 0;
                } else if (this.materialMode == 2) {
                    spezialType = 1;
                }

                if (spezialType < 2) {
                    if (type == 1) {
                        var color = props.get(1, 0xcccccc);

                        if (spezialType == 1) {
                            mat = new away.materials.ColorMultiPassMaterial(color);
                            debugString += "Parsed a ColorMaterial(MultiPass): Name = '" + name + "' | ";
                        } else {
                            mat = new away.materials.ColorMaterial(color, props.get(10, 1.0));
                            (mat).alphaBlending = props.get(11, false);
                            debugString += "Parsed a ColorMaterial(SinglePass): Name = '" + name + "' | ";
                        }
                    } else if (type == 2) {
                        var tex_addr = props.get(2, 0);
                        returnedArray = this.getAssetByID(tex_addr, [AssetType.TEXTURE]);

                        if ((!returnedArray[0]) && (tex_addr > 0)) {
                            this._blocks[blockID].addError("Could not find the DiffuseTexture (ID = " + tex_addr + " ) for this TextureMaterial");
                        }
                        var texture = returnedArray[1];
                        var ambientTexture;
                        var ambientTex_addr = props.get(17, 0);

                        returnedArray = this.getAssetByID(ambientTex_addr, [AssetType.TEXTURE]);

                        if ((!returnedArray[0]) && (ambientTex_addr != 0)) {
                            this._blocks[blockID].addError("Could not find the AmbientTexture (ID = " + ambientTex_addr + " ) for this TextureMaterial");
                        }

                        if (returnedArray[0]) {
                            ambientTexture = returnedArray[1];
                        }

                        if (spezialType == 1) {
                            mat = new away.materials.TextureMultiPassMaterial(texture);
                            debugString += "Parsed a TextureMaterial(MultiPass): Name = '" + name + "' | Texture-Name = " + texture.name;

                            if (ambientTexture) {
                                (mat).ambientTexture = ambientTexture;
                                debugString += " | AmbientTexture-Name = " + ambientTexture.name;
                            }
                        } else {
                            mat = new away.materials.TextureMaterial(texture);
                            debugString += "Parsed a TextureMaterial(SinglePass): Name = '" + name + "' | Texture-Name = " + texture.name;

                            if (ambientTexture) {
                                (mat).ambientTexture = ambientTexture;
                                debugString += " | AmbientTexture-Name = " + ambientTexture.name;
                            }

                            (mat).alpha = props.get(10, 1.0);
                            (mat).alphaBlending = props.get(11, false);
                        }
                    }

                    var normalTex_addr = props.get(3, 0);

                    returnedArray = this.getAssetByID(normalTex_addr, [AssetType.TEXTURE]);

                    if ((!returnedArray[0]) && (normalTex_addr != 0)) {
                        this._blocks[blockID].addError("Could not find the NormalTexture (ID = " + normalTex_addr + " ) for this TextureMaterial");
                    }

                    if (returnedArray[0]) {
                        normalTexture = returnedArray[1];
                        debugString += " | NormalTexture-Name = " + normalTexture.name;
                    }

                    var specTex_addr = props.get(21, 0);
                    returnedArray = this.getAssetByID(specTex_addr, [AssetType.TEXTURE]);

                    if ((!returnedArray[0]) && (specTex_addr != 0)) {
                        this._blocks[blockID].addError("Could not find the SpecularTexture (ID = " + specTex_addr + " ) for this TextureMaterial");
                    }
                    if (returnedArray[0]) {
                        specTexture = returnedArray[1];
                        debugString += " | SpecularTexture-Name = " + specTexture.name;
                    }

                    var lightPickerAddr = props.get(22, 0);
                    returnedArray = this.getAssetByID(lightPickerAddr, [AssetType.LIGHT_PICKER]);

                    if ((!returnedArray[0]) && (lightPickerAddr)) {
                        this._blocks[blockID].addError("Could not find the LightPicker (ID = " + lightPickerAddr + " ) for this TextureMaterial");
                    } else {
                        (mat).lightPicker = returnedArray[1];
                        //debugString+=" | Lightpicker-Name = "+LightPickerBase(returnedArray[1]).name;
                    }

                    (mat).smooth = props.get(5, true);
                    (mat).mipmap = props.get(6, true);
                    (mat).bothSides = props.get(7, false);
                    (mat).alphaPremultiplied = props.get(8, false);
                    (mat).blendMode = this.blendModeDic[props.get(9, 0)];
                    (mat).repeat = props.get(13, false);

                    if (spezialType == 0) {
                        if (normalTexture) {
                            (mat).normalMap = normalTexture;
                        }
                        if (specTexture) {
                            (mat).specularMap = specTexture;
                        }

                        (mat).alphaThreshold = props.get(12, 0.0);
                        (mat).ambient = props.get(15, 1.0);
                        (mat).ambientColor = props.get(16, 0xffffff);
                        (mat).specular = props.get(18, 1.0);
                        (mat).gloss = props.get(19, 50);
                        (mat).specularColor = props.get(20, 0xffffff);
                    } else {
                        if (normalTexture) {
                            (mat).normalMap = normalTexture;
                        }
                        if (specTexture) {
                            (mat).specularMap = specTexture;
                        }

                        (mat).alphaThreshold = props.get(12, 0.0);
                        (mat).ambient = props.get(15, 1.0);
                        (mat).ambientColor = props.get(16, 0xffffff);
                        (mat).specular = props.get(18, 1.0);
                        (mat).gloss = props.get(19, 50);
                        (mat).specularColor = props.get(20, 0xffffff);
                    }

                    var methods_parsed = 0;
                    var targetID;

                    while (methods_parsed < num_methods) {
                        var method_type;
                        method_type = this._newBlockBytes.readUnsignedShort();

                        props = this.parseProperties({ 1: AWDParser.BADDR, 2: AWDParser.BADDR, 3: AWDParser.BADDR, 101: this._propsNrType, 102: this._propsNrType, 103: this._propsNrType, 201: AWDParser.UINT32, 202: AWDParser.UINT32, 301: AWDParser.UINT16, 302: AWDParser.UINT16, 401: AWDParser.UINT8, 402: AWDParser.UINT8, 601: AWDParser.COLOR, 602: AWDParser.COLOR, 701: AWDParser.BOOL, 702: AWDParser.BOOL, 801: AWDParser.MTX4x4 });

                        switch (method_type) {
                            case 999:
                                targetID = props.get(1, 0);
                                returnedArray = this.getAssetByID(targetID, [AssetType.EFFECTS_METHOD]);

                                if (!returnedArray[0]) {
                                    this._blocks[blockID].addError("Could not find the EffectMethod (ID = " + targetID + " ) for this Material");
                                } else {
                                    if (spezialType == 0) {
                                        (mat).addMethod(returnedArray[1]);
                                    }
                                    if (spezialType == 1) {
                                        (mat).addMethod(returnedArray[1]);
                                    }

                                    debugString += " | EffectMethod-Name = " + (returnedArray[1]).name;
                                }

                                break;

                            case 998:
                                targetID = props.get(1, 0);
                                returnedArray = this.getAssetByID(targetID, [AssetType.SHADOW_MAP_METHOD]);

                                if (!returnedArray[0]) {
                                    this._blocks[blockID].addError("Could not find the ShadowMethod (ID = " + targetID + " ) for this Material");
                                } else {
                                    if (spezialType == 0) {
                                        (mat).shadowMethod = returnedArray[1];
                                    }

                                    if (spezialType == 1) {
                                        (mat).shadowMethod = returnedArray[1];
                                    }

                                    debugString += " | ShadowMethod-Name = " + (returnedArray[1]).name;
                                }

                                break;

                            case 102:
                                if (spezialType == 0)
                                    (mat).specularMethod = new PhongSpecularMethod();
                                if (spezialType == 1)
                                    (mat).specularMethod = new PhongSpecularMethod();
                                debugString += " | PhongSpecularMethod";
                                break;

                            case 104:
                                if (spezialType == 0) {
                                    (mat).specularMethod = new FresnelSpecularMethod(props.get(701, true), (mat).specularMethod);
                                    ((mat).specularMethod).fresnelPower = props.get(101, 5);
                                    ((mat).specularMethod).normalReflectance = props.get(102, 0.1);
                                }
                                if (spezialType == 1) {
                                    (mat).specularMethod = new FresnelSpecularMethod(props.get(701, true), (mat).specularMethod);
                                    ((mat).specularMethod).fresnelPower = props.get(101, 5);
                                    ((mat).specularMethod).normalReflectance = props.get(102, 0.1);
                                }
                                debugString += " | FresnelSpecularMethod";
                                break;
                        }
                        this.parseUserAttributes();
                        methods_parsed += 1;
                    }
                }
                (mat).extra = this.parseUserAttributes();
                this._pFinalizeAsset(mat, name);

                this._blocks[blockID].data = mat;
                if (this._debug) {
                    console.log(debugString);
                }
            };

            //Block ID = 82
            AWDParser.prototype.parseTexture = function (blockID) {
                var asset;

                this._blocks[blockID].name = this.parseVarStr();

                var type = this._newBlockBytes.readUnsignedByte();
                var data_len;

                this._texture_users[this._cur_block_id.toString()] = [];

                if (type == 0) {
                    data_len = this._newBlockBytes.readUnsignedInt();
                    var url;
                    url = this._newBlockBytes.readUTFBytes(data_len);
                    this._pAddDependency(this._cur_block_id.toString(), new away.net.URLRequest(url), false, null, true);
                } else {
                    data_len = this._newBlockBytes.readUnsignedInt();

                    var data;
                    data = new away.utils.ByteArray();
                    this._newBlockBytes.readBytes(data, 0, data_len);

                    //
                    // AWDParser - Fix for FireFox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=715075 .
                    //
                    // Converting data to image here instead of parser - fix FireFox bug where image width / height is 0 when created from data
                    // This gives the browser time to initialise image width / height.
                    this._pAddDependency(this._cur_block_id.toString(), null, false, away.parsers.ParserUtils.byteArrayToImage(data), true);
                    //this._pAddDependency(this._cur_block_id.toString(), null, false, data, true);
                }

                // Ignore for now
                this.parseProperties(null);
                this._blocks[blockID].extras = this.parseUserAttributes();
                this._pPauseAndRetrieveDependencies();
                this._blocks[blockID].data = asset;

                if (this._debug) {
                    var textureStylesNames = ["external", "embed"];
                    console.log("Start parsing a " + textureStylesNames[type] + " Bitmap for Texture");
                }
            };

            //Block ID = 83
            AWDParser.prototype.parseCubeTexture = function (blockID) {
                //blockLength = block.len;
                var data_len;
                var asset;
                var i;

                this._cubeTextures = new Array();
                this._texture_users[this._cur_block_id.toString()] = [];

                var type = this._newBlockBytes.readUnsignedByte();

                this._blocks[blockID].name = this.parseVarStr();

                for (i = 0; i < 6; i++) {
                    this._texture_users[this._cur_block_id.toString()] = [];
                    this._cubeTextures.push(null);

                    if (type == 0) {
                        data_len = this._newBlockBytes.readUnsignedInt();
                        var url;
                        url = this._newBlockBytes.readUTFBytes(data_len);

                        this._pAddDependency(this._cur_block_id.toString() + "#" + i, new away.net.URLRequest(url), false, null, true);
                    } else {
                        data_len = this._newBlockBytes.readUnsignedInt();
                        var data;
                        data = new away.utils.ByteArray();

                        this._newBlockBytes.readBytes(data, 0, data_len);

                        this._pAddDependency(this._cur_block_id.toString() + "#" + i, null, false, away.parsers.ParserUtils.byteArrayToImage(data), true);
                    }
                }

                // Ignore for now
                this.parseProperties(null);
                this._blocks[blockID].extras = this.parseUserAttributes();
                this._pPauseAndRetrieveDependencies();
                this._blocks[blockID].data = asset;

                if (this._debug) {
                    var textureStylesNames = ["external", "embed"];
                    console.log("Start parsing 6 " + textureStylesNames[type] + " Bitmaps for CubeTexture");
                }
            };

            //Block ID = 91
            AWDParser.prototype.parseSharedMethodBlock = function (blockID) {
                var asset;

                this._blocks[blockID].name = this.parseVarStr();
                asset = this.parseSharedMethodList(blockID);
                this.parseUserAttributes();
                this._blocks[blockID].data = asset;
                this._pFinalizeAsset(asset, this._blocks[blockID].name);
                this._blocks[blockID].data = asset;

                if (this._debug) {
                    console.log("Parsed a EffectMethod: Name = " + asset.name + " Type = " + asset);
                }
            };

            //Block ID = 92
            AWDParser.prototype.parseShadowMethodBlock = function (blockID) {
                var type;
                var data_len;
                var asset;
                var shadowLightID;
                this._blocks[blockID].name = this.parseVarStr();

                shadowLightID = this._newBlockBytes.readUnsignedInt();
                var returnedArray = this.getAssetByID(shadowLightID, [AssetType.LIGHT]);

                if (!returnedArray[0]) {
                    this._blocks[blockID].addError("Could not find the TargetLight (ID = " + shadowLightID + " ) for this ShadowMethod - ShadowMethod not created");
                    return;
                }

                asset = this.parseShadowMethodList(returnedArray[1], blockID);

                if (!asset)
                    return;

                this.parseUserAttributes();
                this._pFinalizeAsset(asset, this._blocks[blockID].name);
                this._blocks[blockID].data = asset;

                if (this._debug) {
                    console.log("Parsed a ShadowMapMethodMethod: Name = " + asset.name + " | Type = " + asset + " | Light-Name = ", (returnedArray[1]).name);
                }
            };

            //Block ID = 253
            AWDParser.prototype.parseCommand = function (blockID) {
                var hasBlocks = (this._newBlockBytes.readUnsignedByte() == 1);
                var par_id = this._newBlockBytes.readUnsignedInt();
                var mtx = this.parseMatrix3D();
                var name = this.parseVarStr();

                var parentObject;
                var targetObject;

                var returnedArray = this.getAssetByID(par_id, [AssetType.CONTAINER, AssetType.LIGHT, AssetType.MESH, AssetType.SEGMENT_SET]);

                if (returnedArray[0]) {
                    parentObject = returnedArray[1];
                }

                var numCommands = this._newBlockBytes.readShort();
                var typeCommand = this._newBlockBytes.readShort();

                var props = this.parseProperties({ 1: AWDParser.BADDR });

                switch (typeCommand) {
                    case 1:
                        var targetID = props.get(1, 0);
                        var returnedArrayTarget = this.getAssetByID(targetID, [AssetType.LIGHT, AssetType.TEXTURE_PROJECTOR]);

                        if ((!returnedArrayTarget[0]) && (targetID != 0)) {
                            this._blocks[blockID].addError("Could not find the light (ID = " + targetID + " ( for this CommandBock!");
                            return;
                        }

                        targetObject = returnedArrayTarget[1];

                        if (parentObject) {
                            parentObject.addChild(targetObject);
                        }

                        targetObject.transform.matrix3D = mtx;

                        break;
                }

                if (targetObject) {
                    props = this.parseProperties({ 1: this._matrixNrType, 2: this._matrixNrType, 3: this._matrixNrType, 4: AWDParser.UINT8 });

                    targetObject.pivotPoint = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                    targetObject.extra = this.parseUserAttributes();
                }
                this._blocks[blockID].data = targetObject;

                if (this._debug) {
                    console.log("Parsed a CommandBlock: Name = '" + name);
                }
            };

            //blockID 255
            AWDParser.prototype.parseMetaData = function (blockID) {
                var props = this.parseProperties({ 1: AWDParser.UINT32, 2: AWDParser.AWDSTRING, 3: AWDParser.AWDSTRING, 4: AWDParser.AWDSTRING, 5: AWDParser.AWDSTRING });

                if (this._debug) {
                    console.log("Parsed a MetaDataBlock: TimeStamp         = " + props.get(1, 0));
                    console.log("                        EncoderName       = " + props.get(2, "unknown"));
                    console.log("                        EncoderVersion    = " + props.get(3, "unknown"));
                    console.log("                        GeneratorName     = " + props.get(4, "unknown"));
                    console.log("                        GeneratorVersion  = " + props.get(5, "unknown"));
                }
            };

            //blockID 254
            AWDParser.prototype.parseNameSpace = function (blockID) {
                var id = this._newBlockBytes.readUnsignedByte();
                var nameSpaceString = this.parseVarStr();
                if (this._debug)
                    console.log("Parsed a NameSpaceBlock: ID = " + id + " | String = " + nameSpaceString);
            };

            //--Parser UTILS---------------------------------------------------------------------------
            // this functions reads and creates a ShadowMethodMethod
            AWDParser.prototype.parseShadowMethodList = function (light, blockID) {
                var methodType = this._newBlockBytes.readUnsignedShort();
                var shadowMethod;
                var props = this.parseProperties({ 1: AWDParser.BADDR, 2: AWDParser.BADDR, 3: AWDParser.BADDR, 101: this._propsNrType, 102: this._propsNrType, 103: this._propsNrType, 201: AWDParser.UINT32, 202: AWDParser.UINT32, 301: AWDParser.UINT16, 302: AWDParser.UINT16, 401: AWDParser.UINT8, 402: AWDParser.UINT8, 601: AWDParser.COLOR, 602: AWDParser.COLOR, 701: AWDParser.BOOL, 702: AWDParser.BOOL, 801: AWDParser.MTX4x4 });

                var targetID;
                var returnedArray;
                switch (methodType) {
                    case 1002:
                        targetID = props.get(1, 0);
                        returnedArray = this.getAssetByID(targetID, [AssetType.SHADOW_MAP_METHOD]);
                        if (!returnedArray[0]) {
                            this._blocks[blockID].addError("Could not find the ShadowBaseMethod (ID = " + targetID + " ) for this NearShadowMapMethod - ShadowMethod not created");
                            return shadowMethod;
                        }
                        shadowMethod = new NearShadowMapMethod(returnedArray[1]);
                        break;
                    case 1101:
                        shadowMethod = new FilteredShadowMapMethod(light);
                        (shadowMethod).alpha = props.get(101, 1);
                        (shadowMethod).epsilon = props.get(102, 0.002);
                        break;

                    case 1102:
                        shadowMethod = new DitheredShadowMapMethod(light, props.get(201, 5));
                        (shadowMethod).alpha = props.get(101, 1);
                        (shadowMethod).epsilon = props.get(102, 0.002);
                        (shadowMethod).range = props.get(103, 1);

                        break;
                    case 1103:
                        shadowMethod = new SoftShadowMapMethod(light, props.get(201, 5));
                        (shadowMethod).alpha = props.get(101, 1);
                        (shadowMethod).epsilon = props.get(102, 0.002);
                        (shadowMethod).range = props.get(103, 1);

                        break;
                    case 1104:
                        shadowMethod = new HardShadowMapMethod(light);
                        (shadowMethod).alpha = props.get(101, 1);
                        (shadowMethod).epsilon = props.get(102, 0.002);
                        break;
                }
                this.parseUserAttributes();
                return shadowMethod;
            };

            //Block ID 101
            AWDParser.prototype.parseSkeleton = function (blockID/*uint*/ ) {
                var name = this.parseVarStr();
                var num_joints = this._newBlockBytes.readUnsignedShort();
                var skeleton = new Skeleton();
                this.parseProperties(null);

                var joints_parsed = 0;
                while (joints_parsed < num_joints) {
                    var joint;
                    var ibp;

                    // Ignore joint id
                    this._newBlockBytes.readUnsignedShort();
                    joint = new SkeletonJoint();
                    joint.parentIndex = this._newBlockBytes.readUnsignedShort() - 1;
                    joint.name = this.parseVarStr();

                    ibp = this.parseMatrix3D();
                    joint.inverseBindPose = ibp.rawData;

                    // Ignore joint props/attributes for now
                    this.parseProperties(null);
                    this.parseUserAttributes();
                    skeleton.joints.push(joint);
                    joints_parsed++;
                }

                // Discard attributes for now
                this.parseUserAttributes();
                this._pFinalizeAsset(skeleton, name);
                this._blocks[blockID].data = skeleton;
                if (this._debug)
                    console.log("Parsed a Skeleton: Name = " + skeleton.name + " | Number of Joints = " + joints_parsed);
            };

            //Block ID = 102
            AWDParser.prototype.parseSkeletonPose = function (blockID/*uint*/ ) {
                var name = this.parseVarStr();
                var num_joints = this._newBlockBytes.readUnsignedShort();
                this.parseProperties(null);

                var pose = new SkeletonPose();

                var joints_parsed = 0;
                while (joints_parsed < num_joints) {
                    var joint_pose;
                    var has_transform/*uint*/ ;
                    joint_pose = new JointPose();
                    has_transform = this._newBlockBytes.readUnsignedByte();
                    if (has_transform == 1) {
                        var mtx_data = this.parseMatrix43RawData();

                        var mtx = new Matrix3D(mtx_data);
                        joint_pose.orientation.fromMatrix(mtx);
                        joint_pose.translation.copyFrom(mtx.position);

                        pose.jointPoses[joints_parsed] = joint_pose;
                    }
                    joints_parsed++;
                }

                // Skip attributes for now
                this.parseUserAttributes();
                this._pFinalizeAsset(pose, name);
                this._blocks[blockID].data = pose;
                if (this._debug)
                    console.log("Parsed a SkeletonPose: Name = " + pose.name + " | Number of Joints = " + joints_parsed);
            };

            //blockID 103
            AWDParser.prototype.parseSkeletonAnimation = function (blockID/*uint*/ ) {
                var frame_dur;
                var pose_addr/*uint*/ ;
                var name = this.parseVarStr();
                var clip = new SkeletonClipNode();
                var num_frames = this._newBlockBytes.readUnsignedShort();
                this.parseProperties(null);

                var frames_parsed = 0;
                var returnedArray;
                while (frames_parsed < num_frames) {
                    pose_addr = this._newBlockBytes.readUnsignedInt();
                    frame_dur = this._newBlockBytes.readUnsignedShort();
                    returnedArray = this.getAssetByID(pose_addr, [AssetType.SKELETON_POSE]);
                    if (!returnedArray[0])
                        this._blocks[blockID].addError("Could not find the SkeletonPose Frame # " + frames_parsed + " (ID = " + pose_addr + " ) for this SkeletonClipNode");
else
                        clip.addFrame(this._blocks[pose_addr].data, frame_dur);
                    frames_parsed++;
                }
                if (clip.frames.length == 0) {
                    this._blocks[blockID].addError("Could not this SkeletonClipNode, because no Frames where set.");
                    return;
                }

                // Ignore attributes for now
                this.parseUserAttributes();
                this._pFinalizeAsset(clip, name);
                this._blocks[blockID].data = clip;
                if (this._debug)
                    console.log("Parsed a SkeletonClipNode: Name = " + clip.name + " | Number of Frames = " + clip.frames.length);
            };

            //Block ID = 111 /  Block ID = 112
            AWDParser.prototype.parseMeshPoseAnimation = function (blockID/*uint*/ , poseOnly) {
                if (typeof poseOnly === "undefined") { poseOnly = false; }
                var num_frames = 1;
                var num_submeshes/*uint*/ ;
                var frames_parsed/*uint*/ ;
                var subMeshParsed/*uint*/ ;
                var frame_dur;
                var x;
                var y;
                var z;
                var str_len;
                var str_end;
                var geometry;
                var subGeom;
                var idx = 0;
                var clip = new VertexClipNode();
                var indices/*uint*/ ;
                var verts;
                var num_Streams = 0;
                var streamsParsed = 0;
                var streamtypes = new Array()/*int*/ ;
                var props;
                var thisGeo;
                var name = this.parseVarStr();
                var geoAdress = this._newBlockBytes.readUnsignedInt();
                var returnedArray = this.getAssetByID(geoAdress, [AssetType.GEOMETRY]);
                if (!returnedArray[0]) {
                    this._blocks[blockID].addError("Could not find the target-Geometry-Object " + geoAdress + " ) for this VertexClipNode");
                    return;
                }
                var uvs = this.getUVForVertexAnimation(geoAdress);
                if (!poseOnly)
                    num_frames = this._newBlockBytes.readUnsignedShort();

                num_submeshes = this._newBlockBytes.readUnsignedShort();
                num_Streams = this._newBlockBytes.readUnsignedShort();
                streamsParsed = 0;
                while (streamsParsed < num_Streams) {
                    streamtypes.push(this._newBlockBytes.readUnsignedShort());
                    streamsParsed++;
                }
                props = this.parseProperties({ 1: AWDParser.BOOL, 2: AWDParser.BOOL });

                clip.looping = props.get(1, true);
                clip.stitchFinalFrame = props.get(2, false);

                frames_parsed = 0;
                while (frames_parsed < num_frames) {
                    frame_dur = this._newBlockBytes.readUnsignedShort();
                    geometry = new Geometry();
                    subMeshParsed = 0;
                    while (subMeshParsed < num_submeshes) {
                        streamsParsed = 0;
                        str_len = this._newBlockBytes.readUnsignedInt();
                        str_end = this._newBlockBytes.position + str_len;
                        while (streamsParsed < num_Streams) {
                            if (streamtypes[streamsParsed] == 1) {
                                indices = (returnedArray[1]).subGeometries[subMeshParsed].indexData;
                                verts = new Array();
                                idx = 0;
                                while (this._newBlockBytes.position < str_end) {
                                    x = this.readNumber(this._accuracyGeo);
                                    y = this.readNumber(this._accuracyGeo);
                                    z = this.readNumber(this._accuracyGeo);
                                    verts[idx++] = x;
                                    verts[idx++] = y;
                                    verts[idx++] = z;
                                }
                                subGeom = new CompactSubGeometry();
                                subGeom.fromVectors(verts, uvs[subMeshParsed], null, null);
                                subGeom.updateIndexData(indices);
                                subGeom.vertexNormalData;
                                subGeom.vertexTangentData;
                                subGeom.autoDeriveVertexNormals = false;
                                subGeom.autoDeriveVertexTangents = false;
                                subMeshParsed++;
                                geometry.addSubGeometry(subGeom);
                            } else
                                this._newBlockBytes.position = str_end;
                            streamsParsed++;
                        }
                    }
                    clip.addFrame(geometry, frame_dur);
                    frames_parsed++;
                }
                this.parseUserAttributes();
                this._pFinalizeAsset(clip, name);

                this._blocks[blockID].data = clip;
                if (this._debug)
                    console.log("Parsed a VertexClipNode: Name = " + clip.name + " | Target-Geometry-Name = " + (returnedArray[1]).name + " | Number of Frames = " + clip.frames.length);
            };

            //BlockID 113
            AWDParser.prototype.parseVertexAnimationSet = function (blockID/*uint*/ ) {
                var poseBlockAdress;
                var outputString = "";
                var name = this.parseVarStr();
                var num_frames = this._newBlockBytes.readUnsignedShort();
                var props = this.parseProperties({ 1: AWDParser.UINT16 });
                var frames_parsed = 0;
                var skeletonFrames = new Array();
                var vertexFrames = new Array();
                while (frames_parsed < num_frames) {
                    poseBlockAdress = this._newBlockBytes.readUnsignedInt();
                    var returnedArray = this.getAssetByID(poseBlockAdress, [AssetType.ANIMATION_NODE]);
                    if (!returnedArray[0])
                        this._blocks[blockID].addError("Could not find the AnimationClipNode Nr " + frames_parsed + " ( " + poseBlockAdress + " ) for this AnimationSet");
else {
                        if (returnedArray[1] instanceof VertexClipNode)
                            vertexFrames.push(returnedArray[1]);
                        if (returnedArray[1] instanceof SkeletonClipNode)
                            skeletonFrames.push(returnedArray[1]);
                    }
                    frames_parsed++;
                }
                if ((vertexFrames.length == 0) && (skeletonFrames.length == 0)) {
                    this._blocks[blockID].addError("Could not create this AnimationSet, because it contains no animations");
                    return;
                }
                this.parseUserAttributes();
                if (vertexFrames.length > 0) {
                    var newVertexAnimationSet = new VertexAnimationSet();
                    for (var i = 0; i < vertexFrames.length; i++)
                        newVertexAnimationSet.addAnimation(vertexFrames[i]);
                    this._pFinalizeAsset(newVertexAnimationSet, name);
                    this._blocks[blockID].data = newVertexAnimationSet;
                    if (this._debug)
                        console.log("Parsed a VertexAnimationSet: Name = " + name + " | Animations = " + newVertexAnimationSet.animations.length + " | Animation-Names = " + newVertexAnimationSet.animationNames.toString());
                } else if (skeletonFrames.length > 0) {
                    returnedArray = this.getAssetByID(poseBlockAdress, [AssetType.ANIMATION_NODE]);
                    var newSkeletonAnimationSet = new SkeletonAnimationSet(props.get(1, 4));
                    for (var i = 0; i < skeletonFrames.length; i++)
                        newSkeletonAnimationSet.addAnimation(skeletonFrames[i]);
                    this._pFinalizeAsset(newSkeletonAnimationSet, name);
                    this._blocks[blockID].data = newSkeletonAnimationSet;
                    if (this._debug)
                        console.log("Parsed a SkeletonAnimationSet: Name = " + name + " | Animations = " + newSkeletonAnimationSet.animations.length + " | Animation-Names = " + newSkeletonAnimationSet.animationNames.toString());
                }
            };

            //BlockID 122
            AWDParser.prototype.parseAnimatorSet = function (blockID/*uint*/ ) {
                var targetMesh;
                var animSetBlockAdress;
                var targetAnimationSet;
                var outputString = "";
                var name = this.parseVarStr();
                var type = this._newBlockBytes.readUnsignedShort();

                var props = this.parseProperties({ 1: AWDParser.BADDR });

                animSetBlockAdress = this._newBlockBytes.readUnsignedInt();
                var targetMeshLength = this._newBlockBytes.readUnsignedShort();
                var meshAdresses = new Array()/*uint*/ ;
                for (var i = 0; i < targetMeshLength; i++)
                    meshAdresses.push(this._newBlockBytes.readUnsignedInt());

                var activeState = this._newBlockBytes.readUnsignedShort();
                var autoplay = (this._newBlockBytes.readUnsignedByte() == 1);
                this.parseUserAttributes();
                this.parseUserAttributes();

                var returnedArray;
                var targetMeshes = new Array();

                for (i = 0; i < meshAdresses.length; i++) {
                    returnedArray = this.getAssetByID(meshAdresses[i], [AssetType.MESH]);
                    if (returnedArray[0])
                        targetMeshes.push(returnedArray[1]);
                }
                returnedArray = this.getAssetByID(animSetBlockAdress, [AssetType.ANIMATION_SET]);
                if (!returnedArray[0]) {
                    this._blocks[blockID].addError("Could not find the AnimationSet ( " + animSetBlockAdress + " ) for this Animator");
                    ;
                    return;
                }
                targetAnimationSet = returnedArray[1];
                var thisAnimator;
                if (type == 1) {
                    returnedArray = this.getAssetByID(props.get(1, 0), [AssetType.SKELETON]);
                    if (!returnedArray[0]) {
                        this._blocks[blockID].addError("Could not find the Skeleton ( " + props.get(1, 0) + " ) for this Animator");
                        return;
                    }
                    thisAnimator = new SkeletonAnimator(targetAnimationSet, returnedArray[1]);
                } else if (type == 2)
                    thisAnimator = new VertexAnimator(targetAnimationSet);

                this._pFinalizeAsset(thisAnimator, name);
                this._blocks[blockID].data = thisAnimator;
                for (i = 0; i < targetMeshes.length; i++) {
                    if (type == 1)
                        targetMeshes[i].animator = (thisAnimator);
                    if (type == 2)
                        targetMeshes[i].animator = (thisAnimator);
                }
                if (this._debug)
                    console.log("Parsed a Animator: Name = " + name);
            };

            // this functions reads and creates a EffectMethod
            AWDParser.prototype.parseSharedMethodList = function (blockID) {
                var methodType = this._newBlockBytes.readUnsignedShort();
                var effectMethodReturn;

                var props = this.parseProperties({ 1: AWDParser.BADDR, 2: AWDParser.BADDR, 3: AWDParser.BADDR, 101: this._propsNrType, 102: this._propsNrType, 103: this._propsNrType, 104: this._propsNrType, 105: this._propsNrType, 106: this._propsNrType, 107: this._propsNrType, 201: AWDParser.UINT32, 202: AWDParser.UINT32, 301: AWDParser.UINT16, 302: AWDParser.UINT16, 401: AWDParser.UINT8, 402: AWDParser.UINT8, 601: AWDParser.COLOR, 602: AWDParser.COLOR, 701: AWDParser.BOOL, 702: AWDParser.BOOL });
                var targetID;
                var returnedArray;

                switch (methodType) {
                    case 403:
                        targetID = props.get(1, 0);
                        console.log('ENV MAP', targetID);

                        returnedArray = this.getAssetByID(targetID, [AssetType.TEXTURE], "CubeTexture");
                        if (!returnedArray[0])
                            this._blocks[blockID].addError("Could not find the EnvMap (ID = " + targetID + " ) for this EnvMapMethod");
                        effectMethodReturn = new away.materials.EnvMapMethod(returnedArray[1], props.get(101, 1));
                        targetID = props.get(2, 0);
                        if (targetID > 0) {
                            returnedArray = this.getAssetByID(targetID, [AssetType.TEXTURE]);
                            if (!returnedArray[0])
                                this._blocks[blockID].addError("Could not find the Mask-texture (ID = " + targetID + " ) for this EnvMapMethod");
                            // Todo: test mask with EnvMapMethod
                            //(<away.materials.EnvMapMethod> effectMethodReturn).mask = <away.textures.Texture2DBase> returnedArray[1];
                        }
                        break;
                }
                this.parseUserAttributes();
                return effectMethodReturn;
            };

            AWDParser.prototype.parseUserAttributes = function () {
                var attributes;
                var list_len;
                var attibuteCnt;

                list_len = this._newBlockBytes.readUnsignedInt();

                if (list_len > 0) {
                    var list_end;

                    attributes = {};

                    list_end = this._newBlockBytes.position + list_len;

                    while (this._newBlockBytes.position < list_end) {
                        var ns_id;
                        var attr_key;
                        var attr_type;
                        var attr_len;
                        var attr_val;

                        // TODO: Properly tend to namespaces in attributes
                        ns_id = this._newBlockBytes.readUnsignedByte();
                        attr_key = this.parseVarStr();
                        attr_type = this._newBlockBytes.readUnsignedByte();
                        attr_len = this._newBlockBytes.readUnsignedInt();

                        if ((this._newBlockBytes.position + attr_len) > list_end) {
                            console.log("           Error in reading attribute # " + attibuteCnt + " = skipped to end of attribute-list");
                            this._newBlockBytes.position = list_end;
                            return attributes;
                        }

                        switch (attr_type) {
                            case AWDParser.AWDSTRING:
                                attr_val = this._newBlockBytes.readUTFBytes(attr_len);
                                break;
                            case AWDParser.INT8:
                                attr_val = this._newBlockBytes.readByte();
                                break;
                            case AWDParser.INT16:
                                attr_val = this._newBlockBytes.readShort();
                                break;
                            case AWDParser.INT32:
                                attr_val = this._newBlockBytes.readInt();
                                break;
                            case AWDParser.BOOL:
                            case AWDParser.UINT8:
                                attr_val = this._newBlockBytes.readUnsignedByte();
                                break;
                            case AWDParser.UINT16:
                                attr_val = this._newBlockBytes.readUnsignedShort();
                                break;
                            case AWDParser.UINT32:
                            case AWDParser.BADDR:
                                attr_val = this._newBlockBytes.readUnsignedInt();
                                break;
                            case AWDParser.FLOAT32:
                                attr_val = this._newBlockBytes.readFloat();
                                break;
                            case AWDParser.FLOAT64:
                                attr_val = this._newBlockBytes.readDouble();
                                break;
                            default:
                                attr_val = 'unimplemented attribute type ' + attr_type;
                                this._newBlockBytes.position += attr_len;
                                break;
                        }

                        if (this._debug) {
                            console.log("attribute = name: " + attr_key + "  / value = " + attr_val);
                        }

                        attributes[attr_key] = attr_val;
                        attibuteCnt += 1;
                    }
                }

                return attributes;
            };

            AWDParser.prototype.parseProperties = function (expected) {
                var list_end;
                var list_len;
                var propertyCnt = 0;
                var props = new AWDProperties();

                list_len = this._newBlockBytes.readUnsignedInt();
                list_end = this._newBlockBytes.position + list_len;

                if (expected) {
                    while (this._newBlockBytes.position < list_end) {
                        var len;
                        var key;
                        var type;

                        key = this._newBlockBytes.readUnsignedShort();
                        len = this._newBlockBytes.readUnsignedInt();

                        if ((this._newBlockBytes.position + len) > list_end) {
                            console.log("           Error in reading property # " + propertyCnt + " = skipped to end of propertie-list");
                            this._newBlockBytes.position = list_end;
                            return props;
                        }

                        if (expected.hasOwnProperty(key.toString())) {
                            type = expected[key];
                            props.set(key, this.parseAttrValue(type, len));
                        } else {
                            this._newBlockBytes.position += len;
                        }

                        propertyCnt += 1;
                    }
                } else {
                    this._newBlockBytes.position = list_end;
                }

                return props;
            };

            AWDParser.prototype.parseAttrValue = function (type, len) {
                var elem_len;
                var read_func;

                switch (type) {
                    case AWDParser.BOOL:
                    case AWDParser.INT8:
                        elem_len = 1;
                        read_func = this._newBlockBytes.readByte;
                        break;

                    case AWDParser.INT16:
                        elem_len = 2;
                        read_func = this._newBlockBytes.readShort;
                        break;

                    case AWDParser.INT32:
                        elem_len = 4;
                        read_func = this._newBlockBytes.readInt;
                        break;

                    case AWDParser.UINT8:
                        elem_len = 1;
                        read_func = this._newBlockBytes.readUnsignedByte;
                        break;

                    case AWDParser.UINT16:
                        elem_len = 2;
                        read_func = this._newBlockBytes.readUnsignedShort;
                        break;

                    case AWDParser.UINT32:
                    case AWDParser.COLOR:
                    case AWDParser.BADDR:
                        elem_len = 4;
                        read_func = this._newBlockBytes.readUnsignedInt;
                        break;

                    case AWDParser.FLOAT32:
                        elem_len = 4;
                        read_func = this._newBlockBytes.readFloat;
                        break;

                    case AWDParser.FLOAT64:
                        elem_len = 8;
                        read_func = this._newBlockBytes.readDouble;
                        break;

                    case AWDParser.AWDSTRING:
                        return this._newBlockBytes.readUTFBytes(len);

                    case AWDParser.VECTOR2x1:
                    case AWDParser.VECTOR3x1:
                    case AWDParser.VECTOR4x1:
                    case AWDParser.MTX3x2:
                    case AWDParser.MTX3x3:
                    case AWDParser.MTX4x3:
                    case AWDParser.MTX4x4:
                        elem_len = 8;
                        read_func = this._newBlockBytes.readDouble;
                        break;
                }

                if (elem_len < len) {
                    var list = [];
                    var num_read = 0;
                    var num_elems = len / elem_len;

                    while (num_read < num_elems) {
                        list.push(read_func.apply(this._newBlockBytes));
                        num_read++;
                    }

                    return list;
                } else {
                    var val = read_func.apply(this._newBlockBytes);
                    return val;
                }
            };

            AWDParser.prototype.parseHeader = function () {
                var flags;
                var body_len;

                this._byteData.position = 3;

                this._version[0] = this._byteData.readUnsignedByte();
                this._version[1] = this._byteData.readUnsignedByte();

                flags = this._byteData.readUnsignedShort();

                this._streaming = bitFlags.test(flags, bitFlags.FLAG1);

                if ((this._version[0] == 2) && (this._version[1] == 1)) {
                    this._accuracyMatrix = bitFlags.test(flags, bitFlags.FLAG2);
                    this._accuracyGeo = bitFlags.test(flags, bitFlags.FLAG3);
                    this._accuracyProps = bitFlags.test(flags, bitFlags.FLAG4);
                }

                // if we set _accuracyOnBlocks, the precision-values are read from each block-header.
                // set storagePrecision types
                this._geoNrType = AWDParser.FLOAT32;

                if (this._accuracyGeo) {
                    this._geoNrType = AWDParser.FLOAT64;
                }

                this._matrixNrType = AWDParser.FLOAT32;

                if (this._accuracyMatrix) {
                    this._matrixNrType = AWDParser.FLOAT64;
                }

                this._propsNrType = AWDParser.FLOAT32;

                if (this._accuracyProps) {
                    this._propsNrType = AWDParser.FLOAT64;
                }

                this._compression = this._byteData.readUnsignedByte();

                if (this._debug) {
                    console.log("Import AWDFile of version = " + this._version[0] + " - " + this._version[1]);
                    console.log("Global Settings = Compression = " + this._compression + " | Streaming = " + this._streaming + " | Matrix-Precision = " + this._accuracyMatrix + " | Geometry-Precision = " + this._accuracyGeo + " | Properties-Precision = " + this._accuracyProps);
                }

                // Check file integrity
                body_len = this._byteData.readUnsignedInt();
                if (!this._streaming && body_len != this._byteData.getBytesAvailable()) {
                    this._pDieWithError('AWD2 body length does not match header integrity field');
                }
            };

            // Helper - functions
            AWDParser.prototype.getUVForVertexAnimation = function (meshID/*uint*/ ) {
                if (this._blocks[meshID].data instanceof Mesh)
                    meshID = this._blocks[meshID].geoID;
                if (this._blocks[meshID].uvsForVertexAnimation)
                    return this._blocks[meshID].uvsForVertexAnimation;
                var geometry = (this._blocks[meshID].data);
                var geoCnt = 0;
                var ud;
                var uStride/*uint*/ ;
                var uOffs/*uint*/ ;
                var numPoints/*uint*/ ;
                var i/*int*/ ;
                var newUvs;
                this._blocks[meshID].uvsForVertexAnimation = new Array();
                while (geoCnt < geometry.subGeometries.length) {
                    newUvs = new Array();
                    numPoints = geometry.subGeometries[geoCnt].numVertices;
                    ud = geometry.subGeometries[geoCnt].UVData;
                    uStride = geometry.subGeometries[geoCnt].UVStride;
                    uOffs = geometry.subGeometries[geoCnt].UVOffset;
                    for (i = 0; i < numPoints; i++) {
                        newUvs.push(ud[uOffs + i * uStride + 0]);
                        newUvs.push(ud[uOffs + i * uStride + 1]);
                    }
                    this._blocks[meshID].uvsForVertexAnimation.push(newUvs);
                    geoCnt++;
                }
                return this._blocks[meshID].uvsForVertexAnimation;
            };

            AWDParser.prototype.parseVarStr = function () {
                var len = this._newBlockBytes.readUnsignedShort();
                return this._newBlockBytes.readUTFBytes(len);
            };

            AWDParser.prototype.getAssetByID = function (assetID, assetTypesToGet, extraTypeInfo) {
                if (typeof extraTypeInfo === "undefined") { extraTypeInfo = "SingleTexture"; }
                var returnArray = new Array();
                var typeCnt = 0;
                if (assetID > 0) {
                    if (this._blocks[assetID]) {
                        if (this._blocks[assetID].data) {
                            while (typeCnt < assetTypesToGet.length) {
                                var iasset = this._blocks[assetID].data;

                                if (iasset.assetType == assetTypesToGet[typeCnt]) {
                                    if ((assetTypesToGet[typeCnt] == AssetType.TEXTURE) && (extraTypeInfo == "CubeTexture")) {
                                        if (this._blocks[assetID].data instanceof away.textures.ImageCubeTexture) {
                                            returnArray.push(true);
                                            returnArray.push(this._blocks[assetID].data);
                                            return returnArray;
                                        }
                                    }
                                    if ((assetTypesToGet[typeCnt] == AssetType.TEXTURE) && (extraTypeInfo == "SingleTexture")) {
                                        if (this._blocks[assetID].data instanceof away.textures.ImageTexture) {
                                            returnArray.push(true);
                                            returnArray.push(this._blocks[assetID].data);
                                            return returnArray;
                                        }
                                    } else {
                                        returnArray.push(true);
                                        returnArray.push(this._blocks[assetID].data);
                                        return returnArray;
                                    }
                                }

                                if ((assetTypesToGet[typeCnt] == AssetType.GEOMETRY) && (iasset.assetType == AssetType.MESH)) {
                                    var mesh = this._blocks[assetID].data;

                                    returnArray.push(true);
                                    returnArray.push(mesh.geometry);
                                    return returnArray;
                                }

                                typeCnt++;
                            }
                        }
                    }
                }

                // if the has not returned anything yet, the asset is not found, or the found asset is not the right type.
                returnArray.push(false);
                returnArray.push(this.getDefaultAsset(assetTypesToGet[0], extraTypeInfo));
                return returnArray;
            };

            AWDParser.prototype.getDefaultAsset = function (assetType, extraTypeInfo) {
                switch (true) {
                    case (assetType == AssetType.TEXTURE):
                        if (extraTypeInfo == "CubeTexture")
                            return this.getDefaultCubeTexture();
                        if (extraTypeInfo == "SingleTexture")
                            return this.getDefaultTexture();
                        break;

                    case (assetType == AssetType.MATERIAL):
                        return this.getDefaultMaterial();
                        break;

                    default:
                        break;
                }

                return null;
            };

            AWDParser.prototype.getDefaultMaterial = function () {
                if (!this._defaultBitmapMaterial)
                    this._defaultBitmapMaterial = away.materials.DefaultMaterialManager.getDefaultMaterial();
                return this._defaultBitmapMaterial;
            };

            AWDParser.prototype.getDefaultTexture = function () {
                if (!this._defaultTexture) {
                    this._defaultTexture = away.materials.DefaultMaterialManager.getDefaultTexture();
                }

                return this._defaultTexture;
            };

            AWDParser.prototype.getDefaultCubeTexture = function () {
                if (!this._defaultCubeTexture) {
                    var defaultBitmap = away.materials.DefaultMaterialManager.createCheckeredBitmapData();

                    this._defaultCubeTexture = new away.textures.BitmapCubeTexture(defaultBitmap, defaultBitmap, defaultBitmap, defaultBitmap, defaultBitmap, defaultBitmap);
                    this._defaultCubeTexture.name = "defaultTexture";
                }

                return this._defaultCubeTexture;
            };

            AWDParser.prototype.readNumber = function (precision) {
                if (typeof precision === "undefined") { precision = false; }
                if (precision)
                    return this._newBlockBytes.readDouble();
                return this._newBlockBytes.readFloat();
            };

            AWDParser.prototype.parseMatrix3D = function () {
                return new Matrix3D(this.parseMatrix43RawData());
            };

            AWDParser.prototype.parseMatrix32RawData = function () {
                var i;
                var mtx_raw = new Array(6);
                for (i = 0; i < 6; i++) {
                    mtx_raw[i] = this._newBlockBytes.readFloat();
                }

                return mtx_raw;
            };

            AWDParser.prototype.parseMatrix43RawData = function () {
                var mtx_raw = new Array(16);

                mtx_raw[0] = this.readNumber(this._accuracyMatrix);
                mtx_raw[1] = this.readNumber(this._accuracyMatrix);
                mtx_raw[2] = this.readNumber(this._accuracyMatrix);
                mtx_raw[3] = 0.0;
                mtx_raw[4] = this.readNumber(this._accuracyMatrix);
                mtx_raw[5] = this.readNumber(this._accuracyMatrix);
                mtx_raw[6] = this.readNumber(this._accuracyMatrix);
                mtx_raw[7] = 0.0;
                mtx_raw[8] = this.readNumber(this._accuracyMatrix);
                mtx_raw[9] = this.readNumber(this._accuracyMatrix);
                mtx_raw[10] = this.readNumber(this._accuracyMatrix);
                mtx_raw[11] = 0.0;
                mtx_raw[12] = this.readNumber(this._accuracyMatrix);
                mtx_raw[13] = this.readNumber(this._accuracyMatrix);
                mtx_raw[14] = this.readNumber(this._accuracyMatrix);
                mtx_raw[15] = 1.0;

                if (isNaN(mtx_raw[0])) {
                    mtx_raw[0] = 1;
                    mtx_raw[1] = 0;
                    mtx_raw[2] = 0;
                    mtx_raw[4] = 0;
                    mtx_raw[5] = 1;
                    mtx_raw[6] = 0;
                    mtx_raw[8] = 0;
                    mtx_raw[9] = 0;
                    mtx_raw[10] = 1;
                    mtx_raw[12] = 0;
                    mtx_raw[13] = 0;
                    mtx_raw[14] = 0;
                }

                return mtx_raw;
            };
            AWDParser.COMPRESSIONMODE_LZMA = "lzma";
            AWDParser.UNCOMPRESSED = 0;
            AWDParser.DEFLATE = 1;
            AWDParser.LZMA = 2;
            AWDParser.INT8 = 1;
            AWDParser.INT16 = 2;
            AWDParser.INT32 = 3;
            AWDParser.UINT8 = 4;
            AWDParser.UINT16 = 5;
            AWDParser.UINT32 = 6;
            AWDParser.FLOAT32 = 7;
            AWDParser.FLOAT64 = 8;
            AWDParser.BOOL = 21;
            AWDParser.COLOR = 22;
            AWDParser.BADDR = 23;
            AWDParser.AWDSTRING = 31;
            AWDParser.AWDBYTEARRAY = 32;
            AWDParser.VECTOR2x1 = 41;
            AWDParser.VECTOR3x1 = 42;
            AWDParser.VECTOR4x1 = 43;
            AWDParser.MTX3x2 = 44;
            AWDParser.MTX3x3 = 45;
            AWDParser.MTX4x3 = 46;
            AWDParser.MTX4x4 = 47;
            return AWDParser;
        })(away.parsers.ParserBase);
        parsers.AWDParser = AWDParser;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));

var AWDBlock = (function () {
    function AWDBlock() {
    }
    AWDBlock.prototype.dispose = function () {
        this.id = null;
        this.bytes = null;
        this.errorMessages = null;
        this.uvsForVertexAnimation = null;
    };

    AWDBlock.prototype.addError = function (errorMsg) {
        if (!this.errorMessages)
            this.errorMessages = new Array();
        this.errorMessages.push(errorMsg);
    };
    return AWDBlock;
})();

var bitFlags = (function () {
    function bitFlags() {
    }
    bitFlags.test = function (flags, testFlag) {
        return (flags & testFlag) == testFlag;
    };
    bitFlags.FLAG1 = 1;
    bitFlags.FLAG2 = 2;
    bitFlags.FLAG3 = 4;
    bitFlags.FLAG4 = 8;
    bitFlags.FLAG5 = 16;
    bitFlags.FLAG6 = 32;
    bitFlags.FLAG7 = 64;
    bitFlags.FLAG8 = 128;
    bitFlags.FLAG9 = 256;
    bitFlags.FLAG10 = 512;
    bitFlags.FLAG11 = 1024;
    bitFlags.FLAG12 = 2048;
    bitFlags.FLAG13 = 4096;
    bitFlags.FLAG14 = 8192;
    bitFlags.FLAG15 = 16384;
    bitFlags.FLAG16 = 32768;
    return bitFlags;
})();

var AWDProperties = (function () {
    function AWDProperties() {
    }
    AWDProperties.prototype.set = function (key, value) {
        this[key.toString()] = value;
    };

    AWDProperties.prototype.get = function (key, fallback) {
        console.log('this.hasOwnProperty(key.toString());', key, fallback, this.hasOwnProperty(key.toString()));

        if (this.hasOwnProperty(key.toString())) {
            return this[key.toString()];
        } else {
            return fallback;
        }
    };
    return AWDProperties;
})();
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (parsers) {
        var ColorMaterial = away.materials.ColorMaterial;
        var ColorMultiPassMaterial = away.materials.ColorMultiPassMaterial;
        var DefaultMaterialManager = away.materials.DefaultMaterialManager;
        var MultiPassMaterialBase = away.materials.MultiPassMaterialBase;
        var SinglePassMaterialBase = away.materials.SinglePassMaterialBase;
        var TextureMaterial = away.materials.TextureMaterial;
        var TextureMultiPassMaterial = away.materials.TextureMultiPassMaterial;
        var MaterialBase = away.materials.MaterialBase;
        var URLLoaderDataFormat = away.net.URLLoaderDataFormat;
        var Texture2DBase = away.textures.Texture2DBase;
        var ByteArray = away.utils.ByteArray;
        var GeometryUtils = away.utils.GeometryUtils;

        /**
        * Max3DSParser provides a parser for the 3ds data type.
        */
        var Max3DSParser = (function (_super) {
            __extends(Max3DSParser, _super);
            /**
            * Creates a new <code>Max3DSParser</code> object.
            *
            * @param useSmoothingGroups Determines whether the parser looks for smoothing groups in the 3ds file or assumes uniform smoothing. Defaults to true.
            */
            function Max3DSParser(useSmoothingGroups) {
                if (typeof useSmoothingGroups === "undefined") { useSmoothingGroups = true; }
                _super.call(this, URLLoaderDataFormat.ARRAY_BUFFER);

                this._useSmoothingGroups = useSmoothingGroups;
            }
            Max3DSParser.supportsType = /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            function (extension) {
                extension = extension.toLowerCase();
                return extension == "3ds";
            };

            Max3DSParser.supportsData = /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            function (data) {
                var ba;

                ba = parsers.ParserUtils.toByteArray(data);
                if (ba) {
                    ba.position = 0;
                    if (ba.readShort() == 0x4d4d)
                        return true;
                }

                return false;
            };

            /**
            * @inheritDoc
            */
            Max3DSParser.prototype._iResolveDependency = function (resourceDependency) {
                if (resourceDependency.assets.length == 1) {
                    var asset;

                    asset = resourceDependency.assets[0];
                    if (asset.assetType == away.library.AssetType.TEXTURE) {
                        var tex;

                        tex = this._textures[resourceDependency.id];
                        tex.texture = asset;
                    }
                }
            };

            /**
            * @inheritDoc
            */
            Max3DSParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
                // TODO: Implement
            };

            /**
            * @inheritDoc
            */
            Max3DSParser.prototype._pProceedParsing = function () {
                if (!this._byteData) {
                    this._byteData = this._pGetByteData();
                    this._byteData.position = 0;

                    //----------------------------------------------------------------------------
                    // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                    //----------------------------------------------------------------------------
                    //this._byteData.endian = Endian.LITTLE_ENDIAN;// Should be default
                    //----------------------------------------------------------------------------
                    this._textures = {};
                    this._materials = {};
                    this._unfinalized_objects = {};
                }

                while (this._pHasTime()) {
                    if (this._cur_mat && this._byteData.position >= this._cur_mat_end)
                        this.finalizeCurrentMaterial();
else if (this._cur_obj && this._byteData.position >= this._cur_obj_end) {
                        // Can't finalize at this point, because we have to wait until the full
                        // animation section has been parsed for any potential pivot definitions
                        this._unfinalized_objects[this._cur_obj.name] = this._cur_obj;
                        this._cur_obj_end = Number.MAX_VALUE;
                        ;
                        this._cur_obj = null;
                    }

                    if (this._byteData.getBytesAvailable() > 0) {
                        var cid/*uint*/ ;
                        var len/*uint*/ ;
                        var end/*uint*/ ;

                        cid = this._byteData.readUnsignedShort();
                        len = this._byteData.readUnsignedInt();
                        end = this._byteData.position + (len - 6);

                        switch (cid) {
                            case 0x4D4D:
                            case 0x3D3D:
                            case 0xB000:
                                continue;
                                break;

                            case 0xAFFF:
                                this._cur_mat_end = end;
                                this._cur_mat = this.parseMaterial();
                                break;

                            case 0x4000:
                                this._cur_obj_end = end;
                                this._cur_obj = new ObjectVO();
                                this._cur_obj.name = this.readNulTermstring();
                                this._cur_obj.materials = new Array();
                                this._cur_obj.materialFaces = {};
                                break;

                            case 0x4100:
                                this._cur_obj.type = away.library.AssetType.MESH;
                                break;

                            case 0x4110:
                                this.parseVertexList();
                                break;

                            case 0x4120:
                                this.parseFaceList();
                                break;

                            case 0x4140:
                                this.parseUVList();
                                break;

                            case 0x4130:
                                this.parseFaceMaterialList();
                                break;

                            case 0x4160:
                                this._cur_obj.transform = this.readTransform();
                                break;

                            case 0xB002:
                                this.parseObjectAnimation(end);
                                break;

                            case 0x4150:
                                this.parseSmoothingGroups();
                                break;

                            default:
                                // Skip this (unknown) chunk
                                this._byteData.position += (len - 6);
                                break;
                        }

                        if (this.dependencies.length) {
                            this._pPauseAndRetrieveDependencies();
                            break;
                        }
                    }
                }

                if (this._byteData.getBytesAvailable() || this._cur_obj || this._cur_mat)
                    return parsers.ParserBase.MORE_TO_PARSE;
else {
                    var name;

                    for (name in this._unfinalized_objects) {
                        var obj;
                        obj = this.constructObject(this._unfinalized_objects[name]);
                        if (obj)
                            this._pFinalizeAsset(obj, name);
                    }

                    return parsers.ParserBase.PARSING_DONE;
                }
            };

            Max3DSParser.prototype.parseMaterial = function () {
                var mat;

                mat = new MaterialVO();

                while (this._byteData.position < this._cur_mat_end) {
                    var cid/*uint*/ ;
                    var len/*uint*/ ;
                    var end/*uint*/ ;

                    cid = this._byteData.readUnsignedShort();
                    len = this._byteData.readUnsignedInt();
                    end = this._byteData.position + (len - 6);

                    switch (cid) {
                        case 0xA000:
                            mat.name = this.readNulTermstring();
                            break;

                        case 0xA010:
                            mat.ambientColor = this.readColor();
                            break;

                        case 0xA020:
                            mat.diffuseColor = this.readColor();
                            break;

                        case 0xA030:
                            mat.specularColor = this.readColor();
                            break;

                        case 0xA081:
                            mat.twoSided = true;
                            break;

                        case 0xA200:
                            mat.colorMap = this.parseTexture(end);
                            break;

                        case 0xA204:
                            mat.specularMap = this.parseTexture(end);
                            break;

                        default:
                            this._byteData.position = end;
                            break;
                    }
                }

                return mat;
            };

            Max3DSParser.prototype.parseTexture = function (end/*uint*/ ) {
                var tex;

                tex = new TextureVO();

                while (this._byteData.position < end) {
                    var cid/*uint*/ ;
                    var len/*uint*/ ;

                    cid = this._byteData.readUnsignedShort();
                    len = this._byteData.readUnsignedInt();

                    switch (cid) {
                        case 0xA300:
                            tex.url = this.readNulTermstring();
                            break;

                        default:
                            // Skip this unknown texture sub-chunk
                            this._byteData.position += (len - 6);
                            break;
                    }
                }

                this._textures[tex.url] = tex;
                this._pAddDependency(tex.url, new away.net.URLRequest(tex.url));

                return tex;
            };

            Max3DSParser.prototype.parseVertexList = function () {
                var i/*uint*/ ;
                var len/*uint*/ ;
                var count/*uint*/ ;

                count = this._byteData.readUnsignedShort();
                this._cur_obj.verts = new Array(count * 3);

                i = 0;
                len = this._cur_obj.verts.length;
                while (i < len) {
                    var x, y, z;

                    x = this._byteData.readFloat();
                    y = this._byteData.readFloat();
                    z = this._byteData.readFloat();

                    this._cur_obj.verts[i++] = x;
                    this._cur_obj.verts[i++] = z;
                    this._cur_obj.verts[i++] = y;
                }
            };

            Max3DSParser.prototype.parseFaceList = function () {
                var i/*uint*/ ;
                var len/*uint*/ ;
                var count/*uint*/ ;

                count = this._byteData.readUnsignedShort();
                this._cur_obj.indices = new Array(count * 3);

                i = 0;
                len = this._cur_obj.indices.length;
                while (i < len) {
                    var i0/*uint*/ , i1, i2;

                    i0 = this._byteData.readUnsignedShort();
                    i1 = this._byteData.readUnsignedShort();
                    i2 = this._byteData.readUnsignedShort();

                    this._cur_obj.indices[i++] = i0;
                    this._cur_obj.indices[i++] = i2;
                    this._cur_obj.indices[i++] = i1;

                    // Skip "face info", irrelevant in Away3D
                    this._byteData.position += 2;
                }

                this._cur_obj.smoothingGroups = new Array(count);
            };

            Max3DSParser.prototype.parseSmoothingGroups = function () {
                var len = this._cur_obj.indices.length / 3;
                var i = 0;
                while (i < len) {
                    this._cur_obj.smoothingGroups[i] = this._byteData.readUnsignedInt();
                    i++;
                }
            };

            Max3DSParser.prototype.parseUVList = function () {
                var i/*uint*/ ;
                var len/*uint*/ ;
                var count/*uint*/ ;

                count = this._byteData.readUnsignedShort();
                this._cur_obj.uvs = new Array(count * 2);

                i = 0;
                len = this._cur_obj.uvs.length;
                while (i < len) {
                    this._cur_obj.uvs[i++] = this._byteData.readFloat();
                    this._cur_obj.uvs[i++] = 1.0 - this._byteData.readFloat();
                }
            };

            Max3DSParser.prototype.parseFaceMaterialList = function () {
                var mat;
                var count/*uint*/ ;
                var i/*uint*/ ;
                var faces/*uint*/ ;

                mat = this.readNulTermstring();
                count = this._byteData.readUnsignedShort();

                faces = new Array(count);
                i = 0;
                while (i < faces.length)
                    faces[i++] = this._byteData.readUnsignedShort();

                this._cur_obj.materials.push(mat);
                this._cur_obj.materialFaces[mat] = faces;
            };

            Max3DSParser.prototype.parseObjectAnimation = function (end) {
                var vo;
                var obj;
                var pivot;
                var name;
                var hier/*uint*/ ;

                // Pivot defaults to origin
                pivot = new away.geom.Vector3D();

                while (this._byteData.position < end) {
                    var cid/*uint*/ ;
                    var len/*uint*/ ;

                    cid = this._byteData.readUnsignedShort();
                    len = this._byteData.readUnsignedInt();

                    switch (cid) {
                        case 0xb010:
                            name = this.readNulTermstring();
                            this._byteData.position += 4;
                            hier = this._byteData.readShort();
                            break;

                        case 0xb013:
                            pivot.x = this._byteData.readFloat();
                            pivot.z = this._byteData.readFloat();
                            pivot.y = this._byteData.readFloat();
                            break;

                        default:
                            this._byteData.position += (len - 6);
                            break;
                    }
                }

                if (name != '$$$DUMMY' && this._unfinalized_objects.hasOwnProperty(name)) {
                    vo = this._unfinalized_objects[name];
                    obj = this.constructObject(vo, pivot);

                    if (obj)
                        this._pFinalizeAsset(obj, vo.name);

                    delete this._unfinalized_objects[name];
                }
            };

            Max3DSParser.prototype.constructObject = function (obj, pivot) {
                if (typeof pivot === "undefined") { pivot = null; }
                if (obj.type == away.library.AssetType.MESH) {
                    var i/*uint*/ ;
                    var subs;
                    var geom;
                    var mat;
                    var mesh;
                    var mtx;
                    var vertices;
                    var faces;

                    if (obj.materials.length > 1)
                        console.log("The Away3D 3DS parser does not support multiple materials per mesh at this point.");

                    if (!obj.indices || obj.indices.length == 0)
                        return null;

                    vertices = new Array(obj.verts.length / 3);
                    faces = new Array(obj.indices.length / 3);

                    this.prepareData(vertices, faces, obj);

                    if (this._useSmoothingGroups)
                        this.applySmoothGroups(vertices, faces);

                    obj.verts = new Array(vertices.length * 3);
                    for (i = 0; i < vertices.length; i++) {
                        obj.verts[i * 3] = vertices[i].x;
                        obj.verts[i * 3 + 1] = vertices[i].y;
                        obj.verts[i * 3 + 2] = vertices[i].z;
                    }
                    obj.indices = new Array(faces.length * 3);
                    ;
                    for (i = 0; i < faces.length; i++) {
                        obj.indices[i * 3] = faces[i].a;
                        obj.indices[i * 3 + 1] = faces[i].b;
                        obj.indices[i * 3 + 2] = faces[i].c;
                    }

                    if (obj.uvs) {
                        // If the object had UVs to start with, use UVs generated by
                        // smoothing group splitting algorithm. Otherwise those UVs
                        // will be nonsense and should be skipped.
                        obj.uvs = new Array(vertices.length * 2);
                        for (i = 0; i < vertices.length; i++) {
                            obj.uvs[i * 2] = vertices[i].u;
                            obj.uvs[i * 2 + 1] = vertices[i].v;
                        }
                    }

                    geom = new away.base.Geometry();

                    // Construct sub-geometries (potentially splitting buffers)
                    // and add them to geometry.
                    subs = GeometryUtils.fromVectors(obj.verts, obj.indices, obj.uvs, null, null, null, null);
                    for (i = 0; i < subs.length; i++)
                        geom.subGeometries.push(subs[i]);

                    if (obj.materials.length > 0) {
                        var mname;
                        mname = obj.materials[0];
                        mat = this._materials[mname].material;
                    }

                    if (pivot) {
                        if (obj.transform) {
                            // If a transform was found while parsing the
                            // object chunk, use it to find the local pivot vector
                            var dat = obj.transform.concat();
                            dat[12] = 0;
                            dat[13] = 0;
                            dat[14] = 0;
                            mtx = new away.geom.Matrix3D(dat);
                            pivot = mtx.transformVector(pivot);
                        }

                        pivot.scaleBy(-1);

                        mtx = new away.geom.Matrix3D();
                        mtx.appendTranslation(pivot.x, pivot.y, pivot.z);
                        geom.applyTransformation(mtx);
                    }

                    if (obj.transform) {
                        mtx = new away.geom.Matrix3D(obj.transform);
                        mtx.invert();
                        geom.applyTransformation(mtx);
                    }

                    // Final transform applied to geometry. Finalize the geometry,
                    // which will no longer be modified after this point.
                    this._pFinalizeAsset(geom, obj.name.concat('_geom'));

                    // Build mesh and return it
                    mesh = new away.entities.Mesh(geom, mat);
                    mesh.transform.matrix3D = new away.geom.Matrix3D(obj.transform);
                    return mesh;
                }

                // If reached, unknown
                return null;
            };

            Max3DSParser.prototype.prepareData = function (vertices, faces, obj) {
                // convert raw ObjectVO's data to structured VertexVO and FaceVO
                var i/*int*/ ;
                var j/*int*/ ;
                var k/*int*/ ;
                var len = obj.verts.length;
                for (i = 0, j = 0, k = 0; i < len;) {
                    var v = new VertexVO();
                    v.x = obj.verts[i++];
                    v.y = obj.verts[i++];
                    v.z = obj.verts[i++];
                    if (obj.uvs) {
                        v.u = obj.uvs[j++];
                        v.v = obj.uvs[j++];
                    }
                    vertices[k++] = v;
                }
                len = obj.indices.length;
                for (i = 0, k = 0; i < len;) {
                    var f = new FaceVO();
                    f.a = obj.indices[i++];
                    f.b = obj.indices[i++];
                    f.c = obj.indices[i++];
                    f.smoothGroup = obj.smoothingGroups[k] || 0;
                    faces[k++] = f;
                }
            };

            Max3DSParser.prototype.applySmoothGroups = function (vertices, faces) {
                // clone vertices according to following rule:
                // clone if vertex's in faces from groups 1+2 and 3
                // don't clone if vertex's in faces from groups 1+2, 3 and 1+3
                var i/*int*/ ;
                var j/*int*/ ;
                var k/*int*/ ;
                var l/*int*/ ;
                var len/*int*/ ;
                var numVerts = vertices.length;
                var numFaces = faces.length;

                // extract groups data for vertices
                var vGroups = new Array(numVerts)/*uint*/ ;
                for (i = 0; i < numVerts; i++)
                    vGroups[i] = new Array();
                for (i = 0; i < numFaces; i++) {
                    var face = faces[i];
                    for (j = 0; j < 3; j++) {
                        var groups = vGroups[(j == 0) ? face.a : ((j == 1) ? face.b : face.c)];
                        var group = face.smoothGroup;
                        for (k = groups.length - 1; k >= 0; k--) {
                            if ((group & groups[k]) > 0) {
                                group |= groups[k];
                                groups.splice(k, 1);
                                k = groups.length - 1;
                            }
                        }
                        groups.push(group);
                    }
                }

                // clone vertices
                var vClones = new Array(numVerts)/*uint*/ ;
                for (i = 0; i < numVerts; i++) {
                    if ((len = vGroups[i].length) < 1)
                        continue;
                    var clones = new Array(len)/*uint*/ ;
                    vClones[i] = clones;
                    clones[0] = i;
                    var v0 = vertices[i];
                    for (j = 1; j < len; j++) {
                        var v1 = new VertexVO();
                        v1.x = v0.x;
                        v1.y = v0.y;
                        v1.z = v0.z;
                        v1.u = v0.u;
                        v1.v = v0.v;
                        clones[j] = vertices.length;
                        vertices.push(v1);
                    }
                }
                numVerts = vertices.length;

                for (i = 0; i < numFaces; i++) {
                    face = faces[i];
                    group = face.smoothGroup;
                    for (j = 0; j < 3; j++) {
                        k = (j == 0) ? face.a : ((j == 1) ? face.b : face.c);
                        groups = vGroups[k];
                        len = groups.length;
                        clones = vClones[k];
                        for (l = 0; l < len; l++) {
                            if (((group == 0) && (groups[l] == 0)) || ((group & groups[l]) > 0)) {
                                var index = clones[l];
                                if (group == 0) {
                                    // vertex is unique if no smoothGroup found
                                    groups.splice(l, 1);
                                    clones.splice(l, 1);
                                }
                                if (j == 0)
                                    face.a = index;
else if (j == 1)
                                    face.b = index;
else
                                    face.c = index;
                                l = len;
                            }
                        }
                    }
                }
            };

            Max3DSParser.prototype.finalizeCurrentMaterial = function () {
                var mat;
                if (this.materialMode < 2) {
                    if (this._cur_mat.colorMap)
                        mat = new TextureMaterial(this._cur_mat.colorMap.texture || DefaultMaterialManager.getDefaultTexture());
else
                        mat = new ColorMaterial(this._cur_mat.diffuseColor);
                    (mat).ambientColor = this._cur_mat.ambientColor;
                    (mat).specularColor = this._cur_mat.specularColor;
                } else {
                    if (this._cur_mat.colorMap)
                        mat = new TextureMultiPassMaterial(this._cur_mat.colorMap.texture || DefaultMaterialManager.getDefaultTexture());
else
                        mat = new ColorMultiPassMaterial(this._cur_mat.diffuseColor);
                    (mat).ambientColor = this._cur_mat.ambientColor;
                    (mat).specularColor = this._cur_mat.specularColor;
                }

                mat.bothSides = this._cur_mat.twoSided;

                this._pFinalizeAsset(mat, this._cur_mat.name);

                this._materials[this._cur_mat.name] = this._cur_mat;
                this._cur_mat.material = mat;

                this._cur_mat = null;
            };

            Max3DSParser.prototype.readNulTermstring = function () {
                var chr/*int*/ ;
                var str = "";

                while ((chr = this._byteData.readUnsignedByte()) > 0)
                    str += String.fromCharCode(chr);

                return str;
            };

            Max3DSParser.prototype.readTransform = function () {
                var data;

                data = new Array(16);

                // X axis
                data[0] = this._byteData.readFloat();
                data[2] = this._byteData.readFloat();
                data[1] = this._byteData.readFloat();
                data[3] = 0;

                // Z axis
                data[8] = this._byteData.readFloat();
                data[10] = this._byteData.readFloat();
                data[9] = this._byteData.readFloat();
                data[11] = 0;

                // Y Axis
                data[4] = this._byteData.readFloat();
                data[6] = this._byteData.readFloat();
                data[5] = this._byteData.readFloat();
                data[7] = 0;

                // Translation
                data[12] = this._byteData.readFloat();
                data[14] = this._byteData.readFloat();
                data[13] = this._byteData.readFloat();
                data[15] = 1;

                return data;
            };

            Max3DSParser.prototype.readColor = function () {
                var cid/*int*/ ;
                var len/*int*/ ;
                var r/*int*/ , g, b;

                cid = this._byteData.readUnsignedShort();
                len = this._byteData.readUnsignedInt();

                switch (cid) {
                    case 0x0010:
                        r = this._byteData.readFloat() * 255;
                        g = this._byteData.readFloat() * 255;
                        b = this._byteData.readFloat() * 255;
                        break;
                    case 0x0011:
                        r = this._byteData.readUnsignedByte();
                        g = this._byteData.readUnsignedByte();
                        b = this._byteData.readUnsignedByte();
                        break;
                    default:
                        this._byteData.position += (len - 6);
                        break;
                }

                return (r << 16) | (g << 8) | b;
            };
            return Max3DSParser;
        })(parsers.ParserBase);
        parsers.Max3DSParser = Max3DSParser;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));

var Vector3D = away.geom.Vector3D;

var TextureVO = (function () {
    function TextureVO() {
    }
    return TextureVO;
})();

var MaterialVO = (function () {
    function MaterialVO() {
    }
    return MaterialVO;
})();

var ObjectVO = (function () {
    function ObjectVO() {
    }
    return ObjectVO;
})();

var VertexVO = (function () {
    function VertexVO() {
    }
    return VertexVO;
})();

var FaceVO = (function () {
    function FaceVO() {
    }
    return FaceVO;
})();
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (parsers) {
        var Geometry = away.base.Geometry;
        var CompactSubGeometry = away.base.CompactSubGeometry;
        var VertexAnimationSet = away.animators.VertexAnimationSet;
        var VertexClipNode = away.animators.VertexClipNode;
        var URLLoaderDataFormat = away.net.URLLoaderDataFormat;
        var Texture2DBase = away.textures.Texture2DBase;
        var ByteArray = away.utils.ByteArray;

        /**
        * MD2Parser provides a parser for the MD2 data type.
        */
        var MD2Parser = (function (_super) {
            __extends(MD2Parser, _super);
            /**
            * Creates a new MD2Parser object.
            * @param textureType The extension of the texture (e.g. jpg/png/...)
            * @param ignoreTexturePath If true, the path of the texture is ignored
            */
            function MD2Parser(textureType, ignoreTexturePath) {
                if (typeof textureType === "undefined") { textureType = "jpg"; }
                if (typeof ignoreTexturePath === "undefined") { ignoreTexturePath = true; }
                _super.call(this, URLLoaderDataFormat.ARRAY_BUFFER);
                this._clipNodes = new Object();
                // the current subgeom being built
                this._animationSet = new VertexAnimationSet();
                this.materialFinal = false;
                this.geoCreated = false;
                this._textureType = textureType;
                this._ignoreTexturePath = ignoreTexturePath;
            }
            MD2Parser.supportsType = /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            function (extension) {
                extension = extension.toLowerCase();
                return extension == "md2";
            };

            MD2Parser.supportsData = /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            function (data) {
                return (parsers.ParserUtils.toString(data, 4) == 'IDP2');
            };

            /**
            * @inheritDoc
            */
            MD2Parser.prototype._iResolveDependency = function (resourceDependency) {
                if (resourceDependency.assets.length != 1)
                    return;

                var asset = resourceDependency.assets[0];
                if (asset) {
                    var material;
                    if (this.materialMode < 2)
                        material = new away.materials.TextureMaterial(asset);
else
                        material = new away.materials.TextureMultiPassMaterial(asset);

                    material.name = this._mesh.material.name;
                    this._mesh.material = material;
                    this._pFinalizeAsset(material);
                    this._pFinalizeAsset(this._mesh.geometry);
                    this._pFinalizeAsset(this._mesh);
                }
                this.materialFinal = true;
            };

            /**
            * @inheritDoc
            */
            MD2Parser.prototype._iResolveDependencyFailure = function (resourceDependency) {
                if (this.materialMode < 2)
                    this._mesh.material = away.materials.DefaultMaterialManager.getDefaultMaterial();
else
                    this._mesh.material = new away.materials.TextureMultiPassMaterial(away.materials.DefaultMaterialManager.getDefaultTexture());

                this._pFinalizeAsset(this._mesh.geometry);
                this._pFinalizeAsset(this._mesh);
                this.materialFinal = true;
            };

            /**
            * @inheritDoc
            */
            MD2Parser.prototype._pProceedParsing = function () {
                if (!this._startedParsing) {
                    this._byteData = this._pGetByteData();
                    this._startedParsing = true;

                    // Reset bytearray read position (which may have been
                    // moved forward by the supportsData() function.)
                    this._byteData.position = 0;
                }

                while (this._pHasTime()) {
                    if (!this._parsedHeader) {
                        //----------------------------------------------------------------------------
                        // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                        //----------------------------------------------------------------------------
                        //this._byteData.endian = Endian.LITTLE_ENDIAN;
                        // TODO: Create a mesh only when encountered (if it makes sense
                        // for this file format) and return it using this._pFinalizeAsset()
                        this._geometry = new Geometry();
                        this._mesh = new away.entities.Mesh(this._geometry, null);
                        if (this.materialMode < 2)
                            this._mesh.material = away.materials.DefaultMaterialManager.getDefaultMaterial();
else
                            this._mesh.material = new away.materials.TextureMultiPassMaterial(away.materials.DefaultMaterialManager.getDefaultTexture());

                        //_geometry.animation = new VertexAnimation(2, VertexAnimationMode.ABSOLUTE);
                        //_animator = new VertexAnimator(VertexAnimationState(_mesh.animationState));
                        // Parse header and decompress body
                        this.parseHeader();
                        this.parseMaterialNames();
                    } else if (!this._parsedUV)
                        this.parseUV();
else if (!this._parsedFaces)
                        this.parseFaces();
else if (!this._parsedFrames)
                        this.parseFrames();
else if ((this.geoCreated) && (this.materialFinal))
                        return away.parsers.ParserBase.PARSING_DONE;
else if (!this.geoCreated) {
                        this.geoCreated = true;
                        this.createDefaultSubGeometry();

                        // Force name to be chosen by this._pFinalizeAsset()
                        this._mesh.name = "";
                        if (this.materialFinal) {
                            this._pFinalizeAsset(this._mesh.geometry);
                            this._pFinalizeAsset(this._mesh);
                        }

                        this._pPauseAndRetrieveDependencies();
                    }
                }

                return away.parsers.ParserBase.MORE_TO_PARSE;
            };

            /**
            * Reads in all that MD2 Header data that is declared as private variables.
            * I know its a lot, and it looks ugly, but only way to do it in Flash
            */
            MD2Parser.prototype.parseHeader = function () {
                this._ident = this._byteData.readInt();
                this._version = this._byteData.readInt();
                this._skinWidth = this._byteData.readInt();
                this._skinHeight = this._byteData.readInt();

                //skip this._frameSize
                this._byteData.readInt();
                this._numSkins = this._byteData.readInt();
                this._numVertices = this._byteData.readInt();
                this._numST = this._byteData.readInt();
                this._numTris = this._byteData.readInt();

                //skip this._numGlCmds
                this._byteData.readInt();
                this._numFrames = this._byteData.readInt();
                this._offsetSkins = this._byteData.readInt();
                this._offsetST = this._byteData.readInt();
                this._offsetTris = this._byteData.readInt();
                this._offsetFrames = this._byteData.readInt();

                //skip this._offsetGlCmds
                this._byteData.readInt();
                this._offsetEnd = this._byteData.readInt();

                this._parsedHeader = true;
            };

            /**
            * Parses the file names for the materials.
            */
            MD2Parser.prototype.parseMaterialNames = function () {
                var url;
                var name;
                var extIndex/*int*/ ;
                var slashIndex/*int*/ ;
                this._materialNames = new Array();
                this._byteData.position = this._offsetSkins;

                var regExp = new RegExp("[^a-zA-Z0-9\\_\/.]", "g");
                for (var i = 0; i < this._numSkins; ++i) {
                    name = this._byteData.readUTFBytes(64);
                    name = name.replace(regExp, "");
                    extIndex = name.lastIndexOf(".");
                    if (this._ignoreTexturePath)
                        slashIndex = name.lastIndexOf("/");
                    if (name.toLowerCase().indexOf(".jpg") == -1 && name.toLowerCase().indexOf(".png") == -1) {
                        name = name.substring(slashIndex + 1, extIndex);
                        url = name + "." + this._textureType;
                    } else
                        url = name;

                    this._materialNames[i] = name;

                    if (this.dependencies.length == 0)
                        this._pAddDependency(name, new away.net.URLRequest(url));
                }

                if (this._materialNames.length > 0)
                    this._mesh.material.name = this._materialNames[0];
else
                    this.materialFinal = true;
            };

            /**
            * Parses the uv data for the mesh.
            */
            MD2Parser.prototype.parseUV = function () {
                var j = 0;

                this._uvs = new Array(this._numST * 2);
                this._byteData.position = this._offsetST;
                for (var i = 0; i < this._numST; i++) {
                    this._uvs[j++] = this._byteData.readShort() / this._skinWidth;
                    this._uvs[j++] = this._byteData.readShort() / this._skinHeight;
                }

                this._parsedUV = true;
            };

            /**
            * Parses unique indices for the faces.
            */
            MD2Parser.prototype.parseFaces = function () {
                var a/*uint*/ , b, c, ta, tb, tc;
                var i/*uint*/ ;

                this._vertIndices = new Array();
                this._uvIndices = new Array();
                this._indices = new Array();

                this._byteData.position = this._offsetTris;

                for (i = 0; i < this._numTris; i++) {
                    //collect vertex indices
                    a = this._byteData.readUnsignedShort();
                    b = this._byteData.readUnsignedShort();
                    c = this._byteData.readUnsignedShort();

                    //collect uv indices
                    ta = this._byteData.readUnsignedShort();
                    tb = this._byteData.readUnsignedShort();
                    tc = this._byteData.readUnsignedShort();

                    this.addIndex(a, ta);
                    this.addIndex(b, tb);
                    this.addIndex(c, tc);
                }

                var len = this._uvIndices.length;
                this._finalUV = new Array(len * 2);

                for (i = 0; i < len; ++i) {
                    this._finalUV[i << 1] = this._uvs[this._uvIndices[i] << 1];
                    this._finalUV[(i << 1) + 1] = this._uvs[(this._uvIndices[i] << 1) + 1];
                }

                this._parsedFaces = true;
            };

            /**
            * Adds a face index to the list if it doesn't exist yet, based on vertexIndex and uvIndex, and adds the
            * corresponding vertex and uv data in the correct location.
            * @param vertexIndex The original index in the vertex list.
            * @param uvIndex The original index in the uv list.
            */
            MD2Parser.prototype.addIndex = function (vertexIndex/*uint*/ , uvIndex/*uint*/ ) {
                var index = this.findIndex(vertexIndex, uvIndex);

                if (index == -1) {
                    this._indices.push(this._vertIndices.length);
                    this._vertIndices.push(vertexIndex);
                    this._uvIndices.push(uvIndex);
                } else
                    this._indices.push(index);
            };

            /**
            * Finds the final index corresponding to the original MD2's vertex and uv indices. Returns -1 if it wasn't added yet.
            * @param vertexIndex The original index in the vertex list.
            * @param uvIndex The original index in the uv list.
            * @return The index of the final mesh corresponding to the original vertex and uv index. -1 if it doesn't exist yet.
            */
            MD2Parser.prototype.findIndex = function (vertexIndex/*uint*/ , uvIndex/*uint*/ ) {
                var len = this._vertIndices.length;

                for (var i = 0; i < len; ++i) {
                    if (this._vertIndices[i] == vertexIndex && this._uvIndices[i] == uvIndex)
                        return i;
                }

                return -1;
            };

            /**
            * Parses all the frame geometries.
            */
            MD2Parser.prototype.parseFrames = function () {
                var sx, sy, sz;
                var tx, ty, tz;
                var geometry;
                var subGeom;
                var vertLen = this._vertIndices.length;
                var fvertices;
                var tvertices;
                var i/*uint*/ , j, k;

                //var ch : number /*uint*/;
                var name = "";
                var prevClip = null;

                this._byteData.position = this._offsetFrames;

                for (i = 0; i < this._numFrames; i++) {
                    subGeom = new CompactSubGeometry();

                    if (this._firstSubGeom == null)
                        this._firstSubGeom = subGeom;

                    geometry = new Geometry();
                    geometry.addSubGeometry(subGeom);
                    tvertices = new Array();
                    fvertices = new Array(vertLen * 3);

                    sx = this._byteData.readFloat();
                    sy = this._byteData.readFloat();
                    sz = this._byteData.readFloat();

                    tx = this._byteData.readFloat();
                    ty = this._byteData.readFloat();
                    tz = this._byteData.readFloat();

                    name = this.readFrameName();

                    for (j = 0; j < this._numVertices; j++, this._byteData.position++)
                        tvertices.push(sx * this._byteData.readUnsignedByte() + tx, sy * this._byteData.readUnsignedByte() + ty, sz * this._byteData.readUnsignedByte() + tz);

                    k = 0;
                    for (j = 0; j < vertLen; j++) {
                        fvertices[k++] = tvertices[this._vertIndices[j] * 3];
                        fvertices[k++] = tvertices[this._vertIndices[j] * 3 + 2];
                        fvertices[k++] = tvertices[this._vertIndices[j] * 3 + 1];
                    }

                    subGeom.fromVectors(fvertices, this._finalUV, null, null);
                    subGeom.updateIndexData(this._indices);
                    subGeom.vertexNormalData;
                    subGeom.vertexTangentData;
                    subGeom.autoDeriveVertexNormals = false;
                    subGeom.autoDeriveVertexTangents = false;

                    var clip = this._clipNodes[name];

                    if (!clip) {
                        if (prevClip) {
                            this._pFinalizeAsset(prevClip);
                            this._animationSet.addAnimation(prevClip);
                        }

                        clip = new VertexClipNode();
                        clip.name = name;
                        clip.stitchFinalFrame = true;

                        this._clipNodes[name] = clip;

                        prevClip = clip;
                    }
                    clip.addFrame(geometry, 1000 / away.parsers.MD2Parser.FPS);
                }

                if (prevClip) {
                    this._pFinalizeAsset(prevClip);
                    this._animationSet.addAnimation(prevClip);
                }

                // Force this._pFinalizeAsset() to decide name
                this._pFinalizeAsset(this._animationSet);

                this._parsedFrames = true;
            };

            MD2Parser.prototype.readFrameName = function () {
                var name = "";
                var k = 0;
                for (var j = 0; j < 16; j++) {
                    var ch = this._byteData.readUnsignedByte();

                    if (Math.floor(ch) > 0x39 && Math.floor(ch) <= 0x7A && k == 0)
                        name += String.fromCharCode(ch);

                    if (Math.floor(ch) >= 0x30 && Math.floor(ch) <= 0x39)
                        k++;
                }
                return name;
            };

            MD2Parser.prototype.createDefaultSubGeometry = function () {
                var sub = new CompactSubGeometry();
                sub.updateData(this._firstSubGeom.vertexData);
                sub.updateIndexData(this._indices);
                this._geometry.addSubGeometry(sub);
            };
            MD2Parser.FPS = 6;
            return MD2Parser;
        })(parsers.ParserBase);
        parsers.MD2Parser = MD2Parser;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (parsers) {
        var JointPose = away.animators.JointPose;
        var SkeletonPose = away.animators.SkeletonPose;
        var SkeletonClipNode = away.animators.SkeletonClipNode;
        var Quaternion = away.geom.Quaternion;
        var Vector3D = away.geom.Vector3D;
        var URLLoaderDataFormat = away.net.URLLoaderDataFormat;

        /**
        * MD5AnimParser provides a parser for the md5anim data type, providing an animation sequence for the md5 format.
        *
        * todo: optimize
        */
        var MD5AnimParser = (function (_super) {
            __extends(MD5AnimParser, _super);
            /**
            * Creates a new MD5AnimParser object.
            * @param uri The url or id of the data or file to be parsed.
            * @param extra The holder for extra contextual data that the parser might need.
            */
            function MD5AnimParser(additionalRotationAxis, additionalRotationRadians) {
                if (typeof additionalRotationAxis === "undefined") { additionalRotationAxis = null; }
                if (typeof additionalRotationRadians === "undefined") { additionalRotationRadians = 0; }
                _super.call(this, URLLoaderDataFormat.TEXT);
                this._parseIndex = 0;
                this._line = 0;
                this._charLineIndex = 0;
                this._rotationQuat = new Quaternion();
                var t1 = new Quaternion();
                var t2 = new Quaternion();

                t1.fromAxisAngle(Vector3D.X_AXIS, -Math.PI * .5);
                t2.fromAxisAngle(Vector3D.Y_AXIS, -Math.PI * .5);

                this._rotationQuat.multiply(t2, t1);

                if (additionalRotationAxis) {
                    this._rotationQuat.multiply(t2, t1);
                    t1.fromAxisAngle(additionalRotationAxis, additionalRotationRadians);
                    this._rotationQuat.multiply(t1, this._rotationQuat);
                }
            }
            MD5AnimParser.supportsType = /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            function (extension) {
                extension = extension.toLowerCase();
                return extension == "md5anim";
            };

            MD5AnimParser.supportsData = /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            function (data) {
                return false;
            };

            /**
            * @inheritDoc
            */
            MD5AnimParser.prototype._pProceedParsing = function () {
                var token;

                if (!this._startedParsing) {
                    this._textData = this._pGetTextData();
                    this._startedParsing = true;
                }

                while (this._pHasTime()) {
                    token = this.getNextToken();
                    switch (token) {
                        case MD5AnimParser.COMMENT_TOKEN:
                            this.ignoreLine();
                            break;
                        case "":
                            break;
                        case MD5AnimParser.VERSION_TOKEN:
                            this._version = this.getNextInt();
                            if (this._version != 10)
                                throw new Error("Unknown version number encountered!");
                            break;
                        case MD5AnimParser.COMMAND_LINE_TOKEN:
                            this.parseCMD();
                            break;
                        case MD5AnimParser.NUM_FRAMES_TOKEN:
                            this._numFrames = this.getNextInt();
                            this._bounds = new Array();
                            this._frameData = new Array();
                            break;
                        case MD5AnimParser.NUM_JOINTS_TOKEN:
                            this._numJoints = this.getNextInt();
                            this._hierarchy = new Array(this._numJoints);
                            this._baseFrameData = new Array(this._numJoints);
                            break;
                        case MD5AnimParser.FRAME_RATE_TOKEN:
                            this._frameRate = this.getNextInt();
                            break;
                        case MD5AnimParser.NUM_ANIMATED_COMPONENTS_TOKEN:
                            this._numAnimatedComponents = this.getNextInt();
                            break;
                        case MD5AnimParser.HIERARCHY_TOKEN:
                            this.parseHierarchy();
                            break;
                        case MD5AnimParser.BOUNDS_TOKEN:
                            this.parseBounds();
                            break;
                        case MD5AnimParser.BASE_FRAME_TOKEN:
                            this.parseBaseFrame();
                            break;
                        case MD5AnimParser.FRAME_TOKEN:
                            this.parseFrame();
                            break;
                        default:
                            if (!this._reachedEOF)
                                this.sendUnknownKeywordError();
                    }

                    if (this._reachedEOF) {
                        this._clip = new SkeletonClipNode();
                        this.translateClip();
                        this._pFinalizeAsset(this._clip);
                        return parsers.ParserBase.PARSING_DONE;
                    }
                }
                return parsers.ParserBase.MORE_TO_PARSE;
            };

            /**
            * Converts all key frame data to an SkinnedAnimationSequence.
            */
            MD5AnimParser.prototype.translateClip = function () {
                for (var i = 0; i < this._numFrames; ++i)
                    this._clip.addFrame(this.translatePose(this._frameData[i]), 1000 / this._frameRate);
            };

            /**
            * Converts a single key frame data to a SkeletonPose.
            * @param frameData The actual frame data.
            * @return A SkeletonPose containing the frame data's pose.
            */
            MD5AnimParser.prototype.translatePose = function (frameData) {
                var hierarchy;
                var pose;
                var base;
                var flags/*int*/ ;
                var j/*int*/ ;
                var translate = new Vector3D();
                var orientation = new Quaternion();
                var components = frameData.components;
                var skelPose = new SkeletonPose();
                var jointPoses = skelPose.jointPoses;

                for (var i = 0; i < this._numJoints; ++i) {
                    j = 0;
                    pose = new JointPose();
                    hierarchy = this._hierarchy[i];
                    base = this._baseFrameData[i];
                    flags = hierarchy.flags;
                    translate.x = base.position.x;
                    translate.y = base.position.y;
                    translate.z = base.position.z;
                    orientation.x = base.orientation.x;
                    orientation.y = base.orientation.y;
                    orientation.z = base.orientation.z;

                    if (flags & 1)
                        translate.x = components[hierarchy.startIndex + (j++)];
                    if (flags & 2)
                        translate.y = components[hierarchy.startIndex + (j++)];
                    if (flags & 4)
                        translate.z = components[hierarchy.startIndex + (j++)];
                    if (flags & 8)
                        orientation.x = components[hierarchy.startIndex + (j++)];
                    if (flags & 16)
                        orientation.y = components[hierarchy.startIndex + (j++)];
                    if (flags & 32)
                        orientation.z = components[hierarchy.startIndex + (j++)];

                    var w = 1 - orientation.x * orientation.x - orientation.y * orientation.y - orientation.z * orientation.z;
                    orientation.w = w < 0 ? 0 : -Math.sqrt(w);

                    if (hierarchy.parentIndex < 0) {
                        pose.orientation.multiply(this._rotationQuat, orientation);
                        pose.translation = this._rotationQuat.rotatePoint(translate);
                    } else {
                        pose.orientation.copyFrom(orientation);
                        pose.translation.x = translate.x;
                        pose.translation.y = translate.y;
                        pose.translation.z = translate.z;
                    }
                    pose.orientation.y = -pose.orientation.y;
                    pose.orientation.z = -pose.orientation.z;
                    pose.translation.x = -pose.translation.x;

                    jointPoses[i] = pose;
                }

                return skelPose;
            };

            /**
            * Parses the skeleton's hierarchy data.
            */
            MD5AnimParser.prototype.parseHierarchy = function () {
                var ch;
                var data;
                var token = this.getNextToken();
                var i = 0;

                if (token != "{")
                    this.sendUnknownKeywordError();

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    data = new HierarchyData();
                    data.name = this.parseLiteralstring();
                    data.parentIndex = this.getNextInt();
                    data.flags = this.getNextInt();
                    data.startIndex = this.getNextInt();
                    this._hierarchy[i++] = data;

                    ch = this.getNextChar();

                    if (ch == "/") {
                        this.putBack();
                        ch = this.getNextToken();
                        if (ch == MD5AnimParser.COMMENT_TOKEN)
                            this.ignoreLine();
                        ch = this.getNextChar();
                    }

                    if (ch != "}")
                        this.putBack();
                } while(ch != "}");
            };

            /**
            * Parses frame bounds.
            */
            MD5AnimParser.prototype.parseBounds = function () {
                var ch;
                var data;
                var token = this.getNextToken();
                var i = 0;

                if (token != "{")
                    this.sendUnknownKeywordError();

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    data = new BoundsData();
                    data.min = this.parseVector3D();
                    data.max = this.parseVector3D();
                    this._bounds[i++] = data;

                    ch = this.getNextChar();

                    if (ch == "/") {
                        this.putBack();
                        ch = this.getNextToken();
                        if (ch == MD5AnimParser.COMMENT_TOKEN)
                            this.ignoreLine();
                        ch = this.getNextChar();
                    }

                    if (ch != "}")
                        this.putBack();
                } while(ch != "}");
            };

            /**
            * Parses the base frame.
            */
            MD5AnimParser.prototype.parseBaseFrame = function () {
                var ch;
                var data;
                var token = this.getNextToken();
                var i = 0;

                if (token != "{")
                    this.sendUnknownKeywordError();

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    data = new BaseFrameData();
                    data.position = this.parseVector3D();
                    data.orientation = this.parseQuaternion();
                    this._baseFrameData[i++] = data;

                    ch = this.getNextChar();

                    if (ch == "/") {
                        this.putBack();
                        ch = this.getNextToken();
                        if (ch == MD5AnimParser.COMMENT_TOKEN)
                            this.ignoreLine();
                        ch = this.getNextChar();
                    }

                    if (ch != "}")
                        this.putBack();
                } while(ch != "}");
            };

            /**
            * Parses a single frame.
            */
            MD5AnimParser.prototype.parseFrame = function () {
                var ch;
                var data;
                var token;
                var frameIndex/*int*/ ;

                frameIndex = this.getNextInt();

                token = this.getNextToken();
                if (token != "{")
                    this.sendUnknownKeywordError();

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    data = new FrameData();
                    data.components = new Array(this._numAnimatedComponents);

                    for (var i = 0; i < this._numAnimatedComponents; ++i)
                        data.components[i] = this.getNextNumber();

                    this._frameData[frameIndex] = data;

                    ch = this.getNextChar();

                    if (ch == "/") {
                        this.putBack();
                        ch = this.getNextToken();
                        if (ch == MD5AnimParser.COMMENT_TOKEN)
                            this.ignoreLine();
                        ch = this.getNextChar();
                    }

                    if (ch != "}")
                        this.putBack();
                } while(ch != "}");
            };

            /**
            * Puts back the last read character into the data stream.
            */
            MD5AnimParser.prototype.putBack = function () {
                this._parseIndex--;
                this._charLineIndex--;
                this._reachedEOF = this._parseIndex >= this._textData.length;
            };

            /**
            * Gets the next token in the data stream.
            */
            MD5AnimParser.prototype.getNextToken = function () {
                var ch;
                var token = "";

                while (!this._reachedEOF) {
                    ch = this.getNextChar();
                    if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t") {
                        if (token != MD5AnimParser.COMMENT_TOKEN)
                            this.skipWhiteSpace();
                        if (token != "")
                            return token;
                    } else
                        token += ch;

                    if (token == MD5AnimParser.COMMENT_TOKEN)
                        return token;
                }

                return token;
            };

            /**
            * Skips all whitespace in the data stream.
            */
            MD5AnimParser.prototype.skipWhiteSpace = function () {
                var ch;

                do
                    ch = this.getNextChar(); while(ch == "\n" || ch == " " || ch == "\r" || ch == "\t");

                this.putBack();
            };

            /**
            * Skips to the next line.
            */
            MD5AnimParser.prototype.ignoreLine = function () {
                var ch;
                while (!this._reachedEOF && ch != "\n")
                    ch = this.getNextChar();
            };

            /**
            * Retrieves the next single character in the data stream.
            */
            MD5AnimParser.prototype.getNextChar = function () {
                var ch = this._textData.charAt(this._parseIndex++);

                if (ch == "\n") {
                    ++this._line;
                    this._charLineIndex = 0;
                } else if (ch != "\r")
                    ++this._charLineIndex;

                if (this._parseIndex == this._textData.length)
                    this._reachedEOF = true;

                return ch;
            };

            /**
            * Retrieves the next integer in the data stream.
            */
            MD5AnimParser.prototype.getNextInt = function () {
                var i = parseInt(this.getNextToken());
                if (isNaN(i))
                    this.sendParseError("int type");
                return i;
            };

            /**
            * Retrieves the next floating point number in the data stream.
            */
            MD5AnimParser.prototype.getNextNumber = function () {
                var f = parseFloat(this.getNextToken());
                if (isNaN(f))
                    this.sendParseError("float type");
                return f;
            };

            /**
            * Retrieves the next 3d vector in the data stream.
            */
            MD5AnimParser.prototype.parseVector3D = function () {
                var vec = new Vector3D();
                var ch = this.getNextToken();

                if (ch != "(")
                    this.sendParseError("(");
                vec.x = this.getNextNumber();
                vec.y = this.getNextNumber();
                vec.z = this.getNextNumber();

                if (this.getNextToken() != ")")
                    this.sendParseError(")");

                return vec;
            };

            /**
            * Retrieves the next quaternion in the data stream.
            */
            MD5AnimParser.prototype.parseQuaternion = function () {
                var quat = new Quaternion();
                var ch = this.getNextToken();

                if (ch != "(")
                    this.sendParseError("(");
                quat.x = this.getNextNumber();
                quat.y = this.getNextNumber();
                quat.z = this.getNextNumber();

                // quat supposed to be unit length
                var t = 1 - (quat.x * quat.x) - (quat.y * quat.y) - (quat.z * quat.z);
                quat.w = t < 0 ? 0 : -Math.sqrt(t);

                if (this.getNextToken() != ")")
                    this.sendParseError(")");

                return quat;
            };

            /**
            * Parses the command line data.
            */
            MD5AnimParser.prototype.parseCMD = function () {
                // just ignore the command line property
                this.parseLiteralstring();
            };

            /**
            * Retrieves the next literal string in the data stream. A literal string is a sequence of characters bounded
            * by double quotes.
            */
            MD5AnimParser.prototype.parseLiteralstring = function () {
                this.skipWhiteSpace();

                var ch = this.getNextChar();
                var str = "";

                if (ch != "\"")
                    this.sendParseError("\"");

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    ch = this.getNextChar();
                    if (ch != "\"")
                        str += ch;
                } while(ch != "\"");

                return str;
            };

            /**
            * Throws an end-of-file error when a premature end of file was encountered.
            */
            MD5AnimParser.prototype.sendEOFError = function () {
                throw new Error("Unexpected end of file");
            };

            /**
            * Throws an error when an unexpected token was encountered.
            * @param expected The token type that was actually expected.
            */
            MD5AnimParser.prototype.sendParseError = function (expected) {
                throw new Error("Unexpected token at line " + (this._line + 1) + ", character " + this._charLineIndex + ". " + expected + " expected, but " + this._textData.charAt(this._parseIndex - 1) + " encountered");
            };

            /**
            * Throws an error when an unknown keyword was encountered.
            */
            MD5AnimParser.prototype.sendUnknownKeywordError = function () {
                throw new Error("Unknown keyword at line " + (this._line + 1) + ", character " + this._charLineIndex + ". ");
            };
            MD5AnimParser.VERSION_TOKEN = "MD5Version";
            MD5AnimParser.COMMAND_LINE_TOKEN = "commandline";
            MD5AnimParser.NUM_FRAMES_TOKEN = "numFrames";
            MD5AnimParser.NUM_JOINTS_TOKEN = "numJoints";
            MD5AnimParser.FRAME_RATE_TOKEN = "frameRate";
            MD5AnimParser.NUM_ANIMATED_COMPONENTS_TOKEN = "numAnimatedComponents";

            MD5AnimParser.HIERARCHY_TOKEN = "hierarchy";
            MD5AnimParser.BOUNDS_TOKEN = "bounds";
            MD5AnimParser.BASE_FRAME_TOKEN = "baseframe";
            MD5AnimParser.FRAME_TOKEN = "frame";

            MD5AnimParser.COMMENT_TOKEN = "//";
            return MD5AnimParser;
        })(parsers.ParserBase);
        parsers.MD5AnimParser = MD5AnimParser;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));

// value objects
var HierarchyData = (function () {
    function HierarchyData() {
    }
    HierarchyData.prototype.HierarchyData = function () {
    };
    return HierarchyData;
})();

var BoundsData = (function () {
    function BoundsData() {
    }
    BoundsData.prototype.BoundsData = function () {
    };
    return BoundsData;
})();

var BaseFrameData = (function () {
    function BaseFrameData() {
    }
    BaseFrameData.prototype.BaseFrameData = function () {
    };
    return BaseFrameData;
})();

var FrameData = (function () {
    function FrameData() {
    }
    FrameData.prototype.FrameData = function () {
    };
    return FrameData;
})();
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (parsers) {
        var SkeletonAnimationSet = away.animators.SkeletonAnimationSet;
        var Skeleton = away.animators.Skeleton;
        var SkeletonJoint = away.animators.SkeletonJoint;
        var Geometry = away.base.Geometry;
        var SkinnedSubGeometry = away.base.SkinnedSubGeometry;
        var Matrix3D = away.geom.Matrix3D;
        var Quaternion = away.geom.Quaternion;
        var Vector3D = away.geom.Vector3D;
        var Mesh = away.entities.Mesh;
        var URLLoaderDataFormat = away.net.URLLoaderDataFormat;

        // todo: create animation system, parse skeleton
        /**
        * MD5MeshParser provides a parser for the md5mesh data type, providing the geometry of the md5 format.
        *
        * todo: optimize
        */
        var MD5MeshParser = (function (_super) {
            __extends(MD5MeshParser, _super);
            /**
            * Creates a new MD5MeshParser object.
            */
            function MD5MeshParser(additionalRotationAxis, additionalRotationRadians) {
                if (typeof additionalRotationAxis === "undefined") { additionalRotationAxis = null; }
                if (typeof additionalRotationRadians === "undefined") { additionalRotationRadians = 0; }
                _super.call(this, URLLoaderDataFormat.TEXT);
                this._parseIndex = 0;
                this._line = 0;
                this._charLineIndex = 0;
                this._rotationQuat = new Quaternion();

                this._rotationQuat.fromAxisAngle(Vector3D.X_AXIS, -Math.PI * .5);

                if (additionalRotationAxis) {
                    var quat = new Quaternion();
                    quat.fromAxisAngle(additionalRotationAxis, additionalRotationRadians);
                    this._rotationQuat.multiply(this._rotationQuat, quat);
                }
            }
            MD5MeshParser.supportsType = /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            function (extension) {
                extension = extension.toLowerCase();
                return extension == "md5mesh";
            };

            MD5MeshParser.supportsData = /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            function (data) {
                return false;
            };

            /**
            * @inheritDoc
            */
            MD5MeshParser.prototype._pProceedParsing = function () {
                var token;

                if (!this._startedParsing) {
                    this._textData = this._pGetTextData();
                    this._startedParsing = true;
                }

                while (this._pHasTime()) {
                    token = this.getNextToken();
                    switch (token) {
                        case MD5MeshParser.COMMENT_TOKEN:
                            this.ignoreLine();
                            break;
                        case MD5MeshParser.VERSION_TOKEN:
                            this._version = this.getNextInt();
                            if (this._version != 10)
                                throw new Error("Unknown version number encountered!");
                            break;
                        case MD5MeshParser.COMMAND_LINE_TOKEN:
                            this.parseCMD();
                            break;
                        case MD5MeshParser.NUM_JOINTS_TOKEN:
                            this._numJoints = this.getNextInt();
                            this._bindPoses = new Array(this._numJoints);
                            break;
                        case MD5MeshParser.NUM_MESHES_TOKEN:
                            this._numMeshes = this.getNextInt();
                            break;
                        case MD5MeshParser.JOINTS_TOKEN:
                            this.parseJoints();
                            break;
                        case MD5MeshParser.MESH_TOKEN:
                            this.parseMesh();
                            break;
                        default:
                            if (!this._reachedEOF)
                                this.sendUnknownKeywordError();
                    }

                    if (this._reachedEOF) {
                        this.calculateMaxJointCount();
                        this._animationSet = new SkeletonAnimationSet(this._maxJointCount);

                        this._mesh = new Mesh(new Geometry(), null);
                        this._geometry = this._mesh.geometry;

                        for (var i = 0; i < this._meshData.length; ++i)
                            this._geometry.addSubGeometry(this.translateGeom(this._meshData[i].vertexData, this._meshData[i].weightData, this._meshData[i].indices));

                        //_geometry.animation = _animation;
                        //					_mesh.animationController = _animationController;
                        this._pFinalizeAsset(this._geometry);
                        this._pFinalizeAsset(this._mesh);
                        this._pFinalizeAsset(this._skeleton);
                        this._pFinalizeAsset(this._animationSet);
                        return parsers.ParserBase.PARSING_DONE;
                    }
                }
                return parsers.ParserBase.MORE_TO_PARSE;
            };

            MD5MeshParser.prototype.calculateMaxJointCount = function () {
                this._maxJointCount = 0;

                var numMeshData = this._meshData.length;
                for (var i = 0; i < numMeshData; ++i) {
                    var meshData = this._meshData[i];
                    var vertexData = meshData.vertexData;
                    var numVerts = vertexData.length;

                    for (var j = 0; j < numVerts; ++j) {
                        var zeroWeights = this.countZeroWeightJoints(vertexData[j], meshData.weightData);
                        var totalJoints = vertexData[j].countWeight - zeroWeights;
                        if (totalJoints > this._maxJointCount)
                            this._maxJointCount = totalJoints;
                    }
                }
            };

            MD5MeshParser.prototype.countZeroWeightJoints = function (vertex, weights) {
                var start = vertex.startWeight;
                var end = vertex.startWeight + vertex.countWeight;
                var count = 0;
                var weight;

                for (var i = start; i < end; ++i) {
                    weight = weights[i].bias;
                    if (weight == 0)
                        ++count;
                }

                return count;
            };

            /**
            * Parses the skeleton's joints.
            */
            MD5MeshParser.prototype.parseJoints = function () {
                var ch;
                var joint;
                var pos;
                var quat;
                var i = 0;
                var token = this.getNextToken();

                if (token != "{")
                    this.sendUnknownKeywordError();

                this._skeleton = new Skeleton();

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    joint = new SkeletonJoint();
                    joint.name = this.parseLiteralstring();
                    joint.parentIndex = this.getNextInt();
                    pos = this.parseVector3D();
                    pos = this._rotationQuat.rotatePoint(pos);
                    quat = this.parseQuaternion();

                    // todo: check if this is correct, or maybe we want to actually store it as quats?
                    this._bindPoses[i] = quat.toMatrix3D();
                    this._bindPoses[i].appendTranslation(pos.x, pos.y, pos.z);
                    var inv = this._bindPoses[i].clone();
                    inv.invert();
                    joint.inverseBindPose = inv.rawData;

                    this._skeleton.joints[i++] = joint;

                    ch = this.getNextChar();

                    if (ch == "/") {
                        this.putBack();
                        ch = this.getNextToken();
                        if (ch == MD5MeshParser.COMMENT_TOKEN)
                            this.ignoreLine();
                        ch = this.getNextChar();
                    }

                    if (ch != "}")
                        this.putBack();
                } while(ch != "}");
            };

            /**
            * Puts back the last read character into the data stream.
            */
            MD5MeshParser.prototype.putBack = function () {
                this._parseIndex--;
                this._charLineIndex--;
                this._reachedEOF = this._parseIndex >= this._textData.length;
            };

            /**
            * Parses the mesh geometry.
            */
            MD5MeshParser.prototype.parseMesh = function () {
                var token = this.getNextToken();
                var ch;
                var vertexData;
                var weights;
                var indices/*uint*/ ;

                if (token != "{")
                    this.sendUnknownKeywordError();

                if (this._shaders == null)
                    this._shaders = new Array();

                while (ch != "}") {
                    ch = this.getNextToken();
                    switch (ch) {
                        case MD5MeshParser.COMMENT_TOKEN:
                            this.ignoreLine();
                            break;
                        case MD5MeshParser.MESH_SHADER_TOKEN:
                            this._shaders.push(this.parseLiteralstring());
                            break;
                        case MD5MeshParser.MESH_NUM_VERTS_TOKEN:
                            vertexData = new Array(this.getNextInt());
                            break;
                        case MD5MeshParser.MESH_NUM_TRIS_TOKEN:
                            indices = new Array(this.getNextInt() * 3);
                            break;
                        case MD5MeshParser.MESH_NUM_WEIGHTS_TOKEN:
                            weights = new Array(this.getNextInt());
                            break;
                        case MD5MeshParser.MESH_VERT_TOKEN:
                            this.parseVertex(vertexData);
                            break;
                        case MD5MeshParser.MESH_TRI_TOKEN:
                            this.parseTri(indices);
                            break;
                        case MD5MeshParser.MESH_WEIGHT_TOKEN:
                            this.parseJoint(weights);
                            break;
                    }
                }

                if (this._meshData == null)
                    this._meshData = new Array();

                var i = this._meshData.length;
                this._meshData[i] = new MeshData();
                this._meshData[i].vertexData = vertexData;
                this._meshData[i].weightData = weights;
                this._meshData[i].indices = indices;
            };

            /**
            * Converts the mesh data to a SkinnedSub instance.
            * @param vertexData The mesh's vertices.
            * @param weights The joint weights per vertex.
            * @param indices The indices for the faces.
            * @return A SkinnedSubGeometry instance containing all geometrical data for the current mesh.
            */
            MD5MeshParser.prototype.translateGeom = function (vertexData, weights, indices/*uint*/ ) {
                var len = vertexData.length;
                var v1/*int*/ , v2, v3;
                var vertex;
                var weight;
                var bindPose;
                var pos;
                var subGeom = new SkinnedSubGeometry(this._maxJointCount);
                var uvs = new Array(len * 2);
                var vertices = new Array(len * 3);
                var jointIndices = new Array(len * this._maxJointCount);
                var jointWeights = new Array(len * this._maxJointCount);
                var l = 0;
                var nonZeroWeights/*int*/ ;

                for (var i = 0; i < len; ++i) {
                    vertex = vertexData[i];
                    v1 = vertex.index * 3;
                    v2 = v1 + 1;
                    v3 = v1 + 2;
                    vertices[v1] = vertices[v2] = vertices[v3] = 0;

                    nonZeroWeights = 0;
                    for (var j = 0; j < vertex.countWeight; ++j) {
                        weight = weights[vertex.startWeight + j];
                        if (weight.bias > 0) {
                            bindPose = this._bindPoses[weight.joint];
                            pos = bindPose.transformVector(weight.pos);
                            vertices[v1] += pos.x * weight.bias;
                            vertices[v2] += pos.y * weight.bias;
                            vertices[v3] += pos.z * weight.bias;

                            // indices need to be multiplied by 3 (amount of matrix registers)
                            jointIndices[l] = weight.joint * 3;
                            jointWeights[l++] = weight.bias;
                            ++nonZeroWeights;
                        }
                    }

                    for (j = nonZeroWeights; j < this._maxJointCount; ++j) {
                        jointIndices[l] = 0;
                        jointWeights[l++] = 0;
                    }

                    v1 = vertex.index << 1;
                    uvs[v1++] = vertex.s;
                    uvs[v1] = vertex.t;
                }

                subGeom.updateIndexData(indices);
                subGeom.fromVectors(vertices, uvs, null, null);

                // cause explicit updates
                subGeom.vertexNormalData;
                subGeom.vertexTangentData;

                // turn auto updates off because they may be animated and set explicitly
                subGeom.autoDeriveVertexTangents = false;
                subGeom.autoDeriveVertexNormals = false;
                subGeom.iUpdateJointIndexData(jointIndices);
                subGeom.iUpdateJointWeightsData(jointWeights);

                return subGeom;
            };

            /**
            * Retrieve the next triplet of vertex indices that form a face.
            * @param indices The index list in which to store the read data.
            */
            MD5MeshParser.prototype.parseTri = function (indices/*uint*/ ) {
                var index = this.getNextInt() * 3;
                indices[index] = this.getNextInt();
                indices[index + 1] = this.getNextInt();
                indices[index + 2] = this.getNextInt();
            };

            /**
            * Reads a new joint data set for a single joint.
            * @param weights the target list to contain the weight data.
            */
            MD5MeshParser.prototype.parseJoint = function (weights) {
                var weight = new JointData();
                weight.index = this.getNextInt();
                weight.joint = this.getNextInt();
                weight.bias = this.getNextNumber();
                weight.pos = this.parseVector3D();
                weights[weight.index] = weight;
            };

            /**
            * Reads the data for a single vertex.
            * @param vertexData The list to contain the vertex data.
            */
            MD5MeshParser.prototype.parseVertex = function (vertexData) {
                var vertex = new VertexData();
                vertex.index = this.getNextInt();
                this.parseUV(vertex);
                vertex.startWeight = this.getNextInt();
                vertex.countWeight = this.getNextInt();

                //			if (vertex.countWeight > _maxJointCount) _maxJointCount = vertex.countWeight;
                vertexData[vertex.index] = vertex;
            };

            /**
            * Reads the next uv coordinate.
            * @param vertexData The vertexData to contain the UV coordinates.
            */
            MD5MeshParser.prototype.parseUV = function (vertexData) {
                var ch = this.getNextToken();
                if (ch != "(")
                    this.sendParseError("(");
                vertexData.s = this.getNextNumber();
                vertexData.t = this.getNextNumber();

                if (this.getNextToken() != ")")
                    this.sendParseError(")");
            };

            /**
            * Gets the next token in the data stream.
            */
            MD5MeshParser.prototype.getNextToken = function () {
                var ch;
                var token = "";

                while (!this._reachedEOF) {
                    ch = this.getNextChar();
                    if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t") {
                        if (token != MD5MeshParser.COMMENT_TOKEN)
                            this.skipWhiteSpace();
                        if (token != "")
                            return token;
                    } else
                        token += ch;

                    if (token == MD5MeshParser.COMMENT_TOKEN)
                        return token;
                }

                return token;
            };

            /**
            * Skips all whitespace in the data stream.
            */
            MD5MeshParser.prototype.skipWhiteSpace = function () {
                var ch;

                do
                    ch = this.getNextChar(); while(ch == "\n" || ch == " " || ch == "\r" || ch == "\t");

                this.putBack();
            };

            /**
            * Skips to the next line.
            */
            MD5MeshParser.prototype.ignoreLine = function () {
                var ch;
                while (!this._reachedEOF && ch != "\n")
                    ch = this.getNextChar();
            };

            /**
            * Retrieves the next single character in the data stream.
            */
            MD5MeshParser.prototype.getNextChar = function () {
                var ch = this._textData.charAt(this._parseIndex++);

                if (ch == "\n") {
                    ++this._line;
                    this._charLineIndex = 0;
                } else if (ch != "\r")
                    ++this._charLineIndex;

                if (this._parseIndex >= this._textData.length)
                    this._reachedEOF = true;

                return ch;
            };

            /**
            * Retrieves the next integer in the data stream.
            */
            MD5MeshParser.prototype.getNextInt = function () {
                var i = parseInt(this.getNextToken());
                if (isNaN(i))
                    this.sendParseError("int type");
                return i;
            };

            /**
            * Retrieves the next floating point number in the data stream.
            */
            MD5MeshParser.prototype.getNextNumber = function () {
                var f = parseFloat(this.getNextToken());
                if (isNaN(f))
                    this.sendParseError("float type");
                return f;
            };

            /**
            * Retrieves the next 3d vector in the data stream.
            */
            MD5MeshParser.prototype.parseVector3D = function () {
                var vec = new Vector3D();
                var ch = this.getNextToken();

                if (ch != "(")
                    this.sendParseError("(");
                vec.x = -this.getNextNumber();
                vec.y = this.getNextNumber();
                vec.z = this.getNextNumber();

                if (this.getNextToken() != ")")
                    this.sendParseError(")");

                return vec;
            };

            /**
            * Retrieves the next quaternion in the data stream.
            */
            MD5MeshParser.prototype.parseQuaternion = function () {
                var quat = new Quaternion();
                var ch = this.getNextToken();

                if (ch != "(")
                    this.sendParseError("(");
                quat.x = this.getNextNumber();
                quat.y = -this.getNextNumber();
                quat.z = -this.getNextNumber();

                // quat supposed to be unit length
                var t = 1 - quat.x * quat.x - quat.y * quat.y - quat.z * quat.z;
                quat.w = t < 0 ? 0 : -Math.sqrt(t);

                if (this.getNextToken() != ")")
                    this.sendParseError(")");

                var rotQuat = new Quaternion();
                rotQuat.multiply(this._rotationQuat, quat);
                return rotQuat;
            };

            /**
            * Parses the command line data.
            */
            MD5MeshParser.prototype.parseCMD = function () {
                // just ignore the command line property
                this.parseLiteralstring();
            };

            /**
            * Retrieves the next literal string in the data stream. A literal string is a sequence of characters bounded
            * by double quotes.
            */
            MD5MeshParser.prototype.parseLiteralstring = function () {
                this.skipWhiteSpace();

                var ch = this.getNextChar();
                var str = "";

                if (ch != "\"")
                    this.sendParseError("\"");

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    ch = this.getNextChar();
                    if (ch != "\"")
                        str += ch;
                } while(ch != "\"");

                return str;
            };

            /**
            * Throws an end-of-file error when a premature end of file was encountered.
            */
            MD5MeshParser.prototype.sendEOFError = function () {
                throw new Error("Unexpected end of file");
            };

            /**
            * Throws an error when an unexpected token was encountered.
            * @param expected The token type that was actually expected.
            */
            MD5MeshParser.prototype.sendParseError = function (expected) {
                throw new Error("Unexpected token at line " + (this._line + 1) + ", character " + this._charLineIndex + ". " + expected + " expected, but " + this._textData.charAt(this._parseIndex - 1) + " encountered");
            };

            /**
            * Throws an error when an unknown keyword was encountered.
            */
            MD5MeshParser.prototype.sendUnknownKeywordError = function () {
                throw new Error("Unknown keyword at line " + (this._line + 1) + ", character " + this._charLineIndex + ". ");
            };
            MD5MeshParser.VERSION_TOKEN = "MD5Version";
            MD5MeshParser.COMMAND_LINE_TOKEN = "commandline";
            MD5MeshParser.NUM_JOINTS_TOKEN = "numJoints";
            MD5MeshParser.NUM_MESHES_TOKEN = "numMeshes";
            MD5MeshParser.COMMENT_TOKEN = "//";
            MD5MeshParser.JOINTS_TOKEN = "joints";
            MD5MeshParser.MESH_TOKEN = "mesh";

            MD5MeshParser.MESH_SHADER_TOKEN = "shader";
            MD5MeshParser.MESH_NUM_VERTS_TOKEN = "numverts";
            MD5MeshParser.MESH_VERT_TOKEN = "vert";
            MD5MeshParser.MESH_NUM_TRIS_TOKEN = "numtris";
            MD5MeshParser.MESH_TRI_TOKEN = "tri";
            MD5MeshParser.MESH_NUM_WEIGHTS_TOKEN = "numweights";
            MD5MeshParser.MESH_WEIGHT_TOKEN = "weight";
            return MD5MeshParser;
        })(parsers.ParserBase);
        parsers.MD5MeshParser = MD5MeshParser;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));

var VertexData = (function () {
    function VertexData() {
    }
    return VertexData;
})();

var JointData = (function () {
    function JointData() {
    }
    return JointData;
})();

var MeshData = (function () {
    function MeshData() {
    }
    return MeshData;
})();
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (parsers) {
        var Parsers = (function () {
            function Parsers() {
            }
            Parsers.enableAllBundled = /**
            * Short-hand function to enable all bundled parsers for auto-detection. In practice,
            * this is the same as invoking enableParsers(Parsers.ALL_BUNDLED) on any of the
            * loader classes SingleFileLoader, AssetLoader, AssetLibrary or Loader3D.
            *
            * See notes about file size in the documentation for the ALL_BUNDLED constant.
            *
            * @see away.parsers.parsers.Parsers.ALL_BUNDLED
            */
            function () {
                away.net.AssetLoader.enableParsers(this.ALL_BUNDLED);
            };
            Parsers.ALL_BUNDLED = Array(away.parsers.AWDParser, away.parsers.Max3DSParser, away.parsers.MD2Parser, away.parsers.OBJParser);
            return Parsers;
        })();
        parsers.Parsers = Parsers;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (commands) {
        var DisplayObjectContainer = away.containers.DisplayObjectContainer;
        var Geometry = away.base.Geometry;
        
        var Matrix3DUtils = away.geom.Matrix3DUtils;
        var Mesh = away.entities.Mesh;
        var GeometryUtils = away.utils.GeometryUtils;

        /**
        *  Class Merge merges two or more static meshes into one.<code>Merge</code>
        */
        var Merge = (function () {
            /**
            * @param    keepMaterial    [optional]    Determines if the merged object uses the recevier mesh material information or keeps its source material(s). Defaults to false.
            * If false and receiver object has multiple materials, the last material found in receiver submeshes is applied to the merged submesh(es).
            * @param    disposeSources  [optional]    Determines if the mesh and geometry source(s) used for the merging are disposed. Defaults to false.
            * If true, only receiver geometry and resulting mesh are kept in  memory.
            * @param    objectSpace     [optional]    Determines if source mesh(es) is/are merged using objectSpace or worldspace. Defaults to false.
            */
            function Merge(keepMaterial, disposeSources, objectSpace) {
                if (typeof keepMaterial === "undefined") { keepMaterial = false; }
                if (typeof disposeSources === "undefined") { disposeSources = false; }
                if (typeof objectSpace === "undefined") { objectSpace = false; }
                this._keepMaterial = keepMaterial;
                this._disposeSources = disposeSources;
                this._objectSpace = objectSpace;
            }

            Object.defineProperty(Merge.prototype, "disposeSources", {
                get: function () {
                    return this._disposeSources;
                },
                set: /**
                * Determines if the mesh and geometry source(s) used for the merging are disposed. Defaults to false.
                */
                function (b) {
                    this._disposeSources = b;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Merge.prototype, "keepMaterial", {
                get: function () {
                    return this._keepMaterial;
                },
                set: /**
                * Determines if the material source(s) used for the merging are disposed. Defaults to false.
                */
                function (b) {
                    this._keepMaterial = b;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Merge.prototype, "objectSpace", {
                get: function () {
                    return this._objectSpace;
                },
                set: /**
                * Determines if source mesh(es) is/are merged using objectSpace or worldspace. Defaults to false.
                */
                function (b) {
                    this._objectSpace = b;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Merges all the children of a container into a single Mesh. If no Mesh object is found, method returns the receiver without modification.
            *
            * @param    receiver           The Mesh to receive the merged contents of the container.
            * @param    objectContainer    The DisplayObjectContainer holding the meshes to be mergd.
            *
            * @return The merged Mesh instance.
            */
            Merge.prototype.applyToContainer = function (receiver, objectContainer) {
                this.reset();

                //collect container meshes
                this.parseContainer(receiver, objectContainer);

                //collect receiver
                this.collect(receiver, false);

                //merge to receiver
                this.merge(receiver, this._disposeSources);
            };

            /**
            * Merges all the meshes found in the Array&lt;Mesh&gt; into a single Mesh.
            *
            * @param    receiver    The Mesh to receive the merged contents of the meshes.
            * @param    meshes      A series of Meshes to be merged with the reciever mesh.
            */
            Merge.prototype.applyToMeshes = function (receiver, meshes) {
                this.reset();

                if (!meshes.length)
                    return;

                for (var i = 0; i < meshes.length; i++)
                    if (meshes[i] != receiver)
                        this.collect(meshes[i], this._disposeSources);

                //collect receiver
                this.collect(receiver, false);

                //merge to receiver
                this.merge(receiver, this._disposeSources);
            };

            /**
            *  Merges 2 meshes into one. It is recommand to use apply when 2 meshes are to be merged. If more need to be merged, use either applyToMeshes or applyToContainer methods.
            *
            * @param    receiver    The Mesh to receive the merged contents of both meshes.
            * @param    mesh        The Mesh to be merged with the receiver mesh
            */
            Merge.prototype.apply = function (receiver, mesh) {
                this.reset();

                //collect mesh
                this.collect(mesh, this._disposeSources);

                //collect receiver
                this.collect(receiver, false);

                //merge to receiver
                this.merge(receiver, this._disposeSources);
            };

            Merge.prototype.reset = function () {
                this._toDispose = new Array();
                this._geomVOs = new Array();
            };

            Merge.prototype.merge = function (destMesh, dispose) {
                var i/*uint*/ ;
                var subIdx/*uint*/ ;
                var oldGeom;
                var destGeom;
                var useSubMaterials;

                oldGeom = destMesh.geometry;
                destGeom = destMesh.geometry = new Geometry();
                subIdx = destMesh.subMeshes.length;

                // Only apply materials directly to sub-meshes if necessary,
                // i.e. if there is more than one material available.
                useSubMaterials = (this._geomVOs.length > 1);

                for (i = 0; i < this._geomVOs.length; i++) {
                    var s/*uint*/ ;
                    var data;
                    var subs;

                    data = this._geomVOs[i];
                    subs = GeometryUtils.fromVectors(data.vertices, data.indices, data.uvs, data.normals, null, null, null);

                    for (s = 0; s < subs.length; s++) {
                        destGeom.addSubGeometry(subs[s]);

                        if (this._keepMaterial && useSubMaterials)
                            destMesh.subMeshes[subIdx].material = data.material;

                        subIdx++;
                    }
                }

                if (this._keepMaterial && !useSubMaterials && this._geomVOs.length)
                    destMesh.material = this._geomVOs[0].material;

                if (dispose) {
                    var m;
                    var len = this._toDispose.length;
                    for (var i; i < len; i++) {
                        m = this._toDispose[i];
                        m.geometry.dispose();
                        m.dispose();
                    }

                    //dispose of the original receiver geometry
                    oldGeom.dispose();
                }

                this._toDispose = null;
            };

            Merge.prototype.collect = function (mesh, dispose) {
                if (mesh.geometry) {
                    var subIdx/*uint*/ ;
                    var subGeometries = mesh.geometry.subGeometries;
                    var calc/*uint*/ ;
                    for (subIdx = 0; subIdx < subGeometries.length; subIdx++) {
                        var i/*uint*/ ;
                        var len/*uint*/ ;
                        var iIdx/*uint*/ , vIdx, nIdx, uIdx;
                        var indexOffset/*uint*/ ;
                        var subGeom;
                        var vo;
                        var vertices;
                        var normals;
                        var vStride/*uint*/ , nStride, uStride;
                        var vOffs/*uint*/ , nOffs, uOffs;
                        var vd, nd, ud;

                        subGeom = subGeometries[subIdx];
                        vd = subGeom.vertexData;
                        vStride = subGeom.vertexStride;
                        vOffs = subGeom.vertexOffset;
                        nd = subGeom.vertexNormalData;
                        nStride = subGeom.vertexNormalStride;
                        nOffs = subGeom.vertexNormalOffset;
                        ud = subGeom.UVData;
                        uStride = subGeom.UVStride;
                        uOffs = subGeom.UVOffset;

                        // Get (or create) a VO for this material
                        vo = this.getSubGeomData(mesh.subMeshes[subIdx].material || mesh.material);

                        // Vertices and normals are copied to temporary vectors, to be transformed
                        // before concatenated onto those of the data. This is unnecessary if no
                        // transformation will be performed, i.e. for object space merging.
                        vertices = (this._objectSpace) ? vo.vertices : new Array();
                        normals = (this._objectSpace) ? vo.normals : new Array();

                        // Copy over vertex attributes
                        vIdx = vertices.length;
                        nIdx = normals.length;
                        uIdx = vo.uvs.length;
                        len = subGeom.numVertices;
                        for (i = 0; i < len; i++) {
                            // Position
                            calc = vOffs + i * vStride;
                            vertices[vIdx++] = vd[calc];
                            vertices[vIdx++] = vd[calc + 1];
                            vertices[vIdx++] = vd[calc + 2];

                            // Normal
                            calc = nOffs + i * nStride;
                            normals[nIdx++] = nd[calc];
                            normals[nIdx++] = nd[calc + 1];
                            normals[nIdx++] = nd[calc + 2];

                            // UV
                            calc = uOffs + i * uStride;
                            vo.uvs[uIdx++] = ud[calc];
                            vo.uvs[uIdx++] = ud[calc + 1];
                        }

                        // Copy over triangle indices
                        indexOffset = (!this._objectSpace) ? vo.vertices.length / 3 : 0;
                        iIdx = vo.indices.length;
                        len = subGeom.numTriangles;
                        for (i = 0; i < len; i++) {
                            calc = i * 3;
                            vo.indices[iIdx++] = subGeom.indexData[calc] + indexOffset;
                            vo.indices[iIdx++] = subGeom.indexData[calc + 1] + indexOffset;
                            vo.indices[iIdx++] = subGeom.indexData[calc + 2] + indexOffset;
                        }

                        if (!this._objectSpace) {
                            mesh.sceneTransform.transformVectors(vertices, vertices);
                            Matrix3DUtils.deltaTransformVectors(mesh.sceneTransform, normals, normals);

                            // Copy vertex data from temporary (transformed) vectors
                            vIdx = vo.vertices.length;
                            nIdx = vo.normals.length;
                            len = vertices.length;
                            for (i = 0; i < len; i++) {
                                vo.vertices[vIdx++] = vertices[i];
                                vo.normals[nIdx++] = normals[i];
                            }
                        }
                    }

                    if (dispose)
                        this._toDispose.push(mesh);
                }
            };

            Merge.prototype.getSubGeomData = function (material) {
                var data;

                if (this._keepMaterial) {
                    var i/*uint*/ ;
                    var len/*uint*/ ;

                    len = this._geomVOs.length;
                    for (i = 0; i < len; i++) {
                        if (this._geomVOs[i].material == material) {
                            data = this._geomVOs[i];
                            break;
                        }
                    }
                } else if (this._geomVOs.length) {
                    // If materials are not to be kept, all data can be
                    // put into a single VO, so return that one.
                    data = this._geomVOs[0];
                }

                if (!data) {
                    data = new GeometryVO();
                    data.vertices = new Array();
                    data.normals = new Array();
                    data.uvs = new Array();
                    data.indices = new Array();
                    data.material = material;

                    this._geomVOs.push(data);
                }

                return data;
            };

            Merge.prototype.parseContainer = function (receiver, object) {
                var child;
                var i/*uint*/ ;

                if (object instanceof Mesh && object != (receiver))
                    this.collect(object, this._disposeSources);

                for (i = 0; i < object.numChildren; ++i) {
                    child = object.getChildAt(i);
                    this.parseContainer(receiver, child);
                }
            };
            return Merge;
        })();
        commands.Merge = Merge;
    })(away.commands || (away.commands = {}));
    var commands = away.commands;
})(away || (away = {}));

var GeometryVO = (function () {
    function GeometryVO() {
    }
    return GeometryVO;
})();
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (tools) {
        var Matrix = away.geom.Matrix;
        var Matrix3D = away.geom.Matrix3D;

        /**
        * ...
        */
        var ParticleGeometryTransform = (function () {
            function ParticleGeometryTransform() {
            }


            Object.defineProperty(ParticleGeometryTransform.prototype, "UVTransform", {
                get: function () {
                    return this._defaultUVTransform;
                },
                set: function (value) {
                    this._defaultUVTransform = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleGeometryTransform.prototype, "vertexTransform", {
                get: function () {
                    return this._defaultVertexTransform;
                },
                set: function (value) {
                    this._defaultVertexTransform = value;
                    this._defaultInvVertexTransform = value.clone();
                    this._defaultInvVertexTransform.invert();
                    this._defaultInvVertexTransform.transpose();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleGeometryTransform.prototype, "invVertexTransform", {
                get: function () {
                    return this._defaultInvVertexTransform;
                },
                enumerable: true,
                configurable: true
            });
            return ParticleGeometryTransform;
        })();
        tools.ParticleGeometryTransform = ParticleGeometryTransform;
    })(away.tools || (away.tools = {}));
    var tools = away.tools;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (tools) {
        var ParticleData = away.animators.ParticleData;
        var ParticleGeometry = away.base.ParticleGeometry;
        var CompactSubGeometry = away.base.CompactSubGeometry;
        var Geometry = away.base.Geometry;
        
        var Matrix = away.geom.Matrix;
        var Matrix3D = away.geom.Matrix3D;
        var Point = away.geom.Point;
        var Vector3D = away.geom.Vector3D;

        /**
        * ...
        */
        var ParticleGeometryHelper = (function () {
            function ParticleGeometryHelper() {
            }
            ParticleGeometryHelper.generateGeometry = function (geometries, transforms) {
                if (typeof transforms === "undefined") { transforms = null; }
                var verticesVector = new Array();
                var indicesVector = new Array()/*uint*/ ;
                var vertexCounters = new Array()/*uint*/ ;
                var particles = new Array();
                var subGeometries = new Array();
                var numParticles = geometries.length;

                var sourceSubGeometries;
                var sourceSubGeometry;
                var numSubGeometries/*uint*/ ;
                var vertices;
                var indices/*uint*/ ;
                var vertexCounter/*uint*/ ;
                var subGeometry;
                var i/*int*/ ;
                var j/*int*/ ;
                var sub2SubMap = new Array()/*int*/ ;

                var tempVertex = new Vector3D();
                var tempNormal = new Vector3D();
                var tempTangents = new Vector3D();
                var tempUV = new Point();

                for (i = 0; i < numParticles; i++) {
                    sourceSubGeometries = geometries[i].subGeometries;
                    numSubGeometries = sourceSubGeometries.length;
                    for (var srcIndex = 0; srcIndex < numSubGeometries; srcIndex++) {
                        if (sub2SubMap.length <= srcIndex) {
                            sub2SubMap.push(subGeometries.length);
                            verticesVector.push(new Array());
                            indicesVector.push(new Array());
                            subGeometries.push(new CompactSubGeometry());
                            vertexCounters.push(0);
                        }

                        sourceSubGeometry = sourceSubGeometries[srcIndex];

                        if (sourceSubGeometry.numVertices + vertexCounters[sub2SubMap[srcIndex]] > ParticleGeometryHelper.MAX_VERTEX) {
                            //update submap and add new subgeom vectors
                            sub2SubMap[srcIndex] = subGeometries.length;
                            verticesVector.push(new Array());
                            indicesVector.push(new Array());
                            subGeometries.push(new CompactSubGeometry());
                            vertexCounters.push(0);
                        }

                        j = sub2SubMap[srcIndex];

                        //select the correct vector
                        vertices = verticesVector[j];
                        indices = indicesVector[j];
                        vertexCounter = vertexCounters[j];
                        subGeometry = subGeometries[j];

                        var particleData = new ParticleData();
                        particleData.numVertices = sourceSubGeometry.numVertices;
                        particleData.startVertexIndex = vertexCounter;
                        particleData.particleIndex = i;
                        particleData.subGeometry = subGeometry;
                        particles.push(particleData);

                        vertexCounters[j] += sourceSubGeometry.numVertices;

                        var k/*int*/ ;
                        var tempLen/*int*/ ;
                        var compact = sourceSubGeometry;
                        var product/*uint*/ ;
                        var sourceVertices;

                        if (compact) {
                            tempLen = compact.numVertices;
                            compact.numTriangles;
                            sourceVertices = compact.vertexData;

                            if (transforms) {
                                var particleGeometryTransform = transforms[i];
                                var vertexTransform = particleGeometryTransform.vertexTransform;
                                var invVertexTransform = particleGeometryTransform.invVertexTransform;
                                var UVTransform = particleGeometryTransform.UVTransform;

                                for (k = 0; k < tempLen; k++) {
                                    /*
                                    * 0 - 2: vertex position X, Y, Z
                                    * 3 - 5: normal X, Y, Z
                                    * 6 - 8: tangent X, Y, Z
                                    * 9 - 10: U V
                                    * 11 - 12: Secondary U V*/
                                    product = k * 13;
                                    tempVertex.x = sourceVertices[product];
                                    tempVertex.y = sourceVertices[product + 1];
                                    tempVertex.z = sourceVertices[product + 2];
                                    tempNormal.x = sourceVertices[product + 3];
                                    tempNormal.y = sourceVertices[product + 4];
                                    tempNormal.z = sourceVertices[product + 5];
                                    tempTangents.x = sourceVertices[product + 6];
                                    tempTangents.y = sourceVertices[product + 7];
                                    tempTangents.z = sourceVertices[product + 8];
                                    tempUV.x = sourceVertices[product + 9];
                                    tempUV.y = sourceVertices[product + 10];
                                    if (vertexTransform) {
                                        tempVertex = vertexTransform.transformVector(tempVertex);
                                        tempNormal = invVertexTransform.deltaTransformVector(tempNormal);
                                        tempTangents = invVertexTransform.deltaTransformVector(tempNormal);
                                    }
                                    if (UVTransform)
                                        tempUV = UVTransform.transformPoint(tempUV);

                                    //this is faster than that only push one data
                                    vertices.push(tempVertex.x, tempVertex.y, tempVertex.z, tempNormal.x, tempNormal.y, tempNormal.z, tempTangents.x, tempTangents.y, tempTangents.z, tempUV.x, tempUV.y, sourceVertices[product + 11], sourceVertices[product + 12]);
                                }
                            } else {
                                for (k = 0; k < tempLen; k++) {
                                    product = k * 13;

                                    //this is faster than that only push one data
                                    vertices.push(sourceVertices[product], sourceVertices[product + 1], sourceVertices[product + 2], sourceVertices[product + 3], sourceVertices[product + 4], sourceVertices[product + 5], sourceVertices[product + 6], sourceVertices[product + 7], sourceVertices[product + 8], sourceVertices[product + 9], sourceVertices[product + 10], sourceVertices[product + 11], sourceVertices[product + 12]);
                                }
                            }
                        } else {
                            //Todo
                        }

                        var sourceIndices = sourceSubGeometry.indexData;
                        tempLen = sourceSubGeometry.numTriangles;
                        for (k = 0; k < tempLen; k++) {
                            product = k * 3;
                            indices.push(sourceIndices[product] + vertexCounter, sourceIndices[product + 1] + vertexCounter, sourceIndices[product + 2] + vertexCounter);
                        }
                    }
                }

                var particleGeometry = new ParticleGeometry();
                particleGeometry.particles = particles;
                particleGeometry.numParticles = numParticles;

                numParticles = subGeometries.length;
                for (i = 0; i < numParticles; i++) {
                    subGeometry = subGeometries[i];
                    subGeometry.updateData(verticesVector[i]);
                    subGeometry.updateIndexData(indicesVector[i]);
                    particleGeometry.addSubGeometry(subGeometry);
                }

                return particleGeometry;
            };
            ParticleGeometryHelper.MAX_VERTEX = 65535;
            return ParticleGeometryHelper;
        })();
        tools.ParticleGeometryHelper = ParticleGeometryHelper;
    })(away.tools || (away.tools = {}));
    var tools = away.tools;
})(away || (away = {}));
///<reference path="away/_definitions.ts"/>
away.Debug.THROW_ERRORS = false;
away.Debug.LOG_PI_ERRORS = false;

var away;
(function (away) {
    var Away3D = (function (_super) {
        __extends(Away3D, _super);
        function Away3D() {
            _super.call(this);
        }
        return Away3D;
    })(away.events.EventDispatcher);
    away.Away3D = Away3D;
})(away || (away = {}));
//# sourceMappingURL=away3d.next.js.map
